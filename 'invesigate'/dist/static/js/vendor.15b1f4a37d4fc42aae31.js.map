{"version":3,"sources":["webpack:///static/js/vendor.15b1f4a37d4fc42aae31.js","webpack:///./~/echarts/~/zrender/lib/core/util.js","webpack:///./~/echarts/lib/echarts.js","webpack:///./~/echarts/lib/util/graphic.js","webpack:///./~/echarts/lib/util/number.js","webpack:///./~/echarts/~/zrender/lib/core/vector.js","webpack:///./~/echarts/~/zrender/lib/graphic/Path.js","webpack:///./~/.2.4.1@core-js/library/modules/_wks.js","webpack:///./~/.2.4.1@core-js/library/modules/_global.js","webpack:///./~/echarts/lib/util/format.js","webpack:///./~/echarts/~/zrender/lib/core/env.js","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./~/echarts/lib/model/Model.js","webpack:///./~/echarts/lib/util/model.js","webpack:///./~/echarts/~/zrender/lib/core/BoundingRect.js","webpack:///./~/echarts/lib/util/clazz.js","webpack:///./~/.2.4.1@core-js/library/modules/_core.js","webpack:///./~/echarts/lib/model/Component.js","webpack:///./~/.2.4.1@core-js/library/modules/_an-object.js","webpack:///./~/.2.4.1@core-js/library/modules/_hide.js","webpack:///./~/echarts/lib/util/layout.js","webpack:///./~/echarts/~/zrender/lib/contain/text.js","webpack:///./~/echarts/~/zrender/lib/core/curve.js","webpack:///./~/.2.4.1@core-js/library/modules/_ctx.js","webpack:///./~/.2.4.1@core-js/library/modules/_descriptors.js","webpack:///./~/.2.4.1@core-js/library/modules/_iterators.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-dp.js","webpack:///./~/echarts/~/zrender/lib/core/matrix.js","webpack:///./~/echarts/~/zrender/lib/mixin/Eventful.js","webpack:///./~/echarts/~/zrender/lib/tool/color.js","webpack:///./~/.2.4.1@core-js/library/modules/_cof.js","webpack:///./~/.2.4.1@core-js/library/modules/_has.js","webpack:///./~/.2.4.1@core-js/library/modules/_is-object.js","webpack:///./~/echarts/lib/model/mixin/makeStyleMapper.js","webpack:///./~/echarts/lib/scale/Scale.js","webpack:///./~/echarts/~/zrender/lib/config.js","webpack:///./~/echarts/~/zrender/lib/container/Group.js","webpack:///./~/echarts/~/zrender/lib/core/PathProxy.js","webpack:///./~/echarts/~/zrender/lib/core/event.js","webpack:///./~/.2.4.1@core-js/library/modules/_a-function.js","webpack:///./~/.2.4.1@core-js/library/modules/_defined.js","webpack:///./~/.2.4.1@core-js/library/modules/_dom-create.js","webpack:///./~/.2.4.1@core-js/library/modules/_export.js","webpack:///./~/.2.4.1@core-js/library/modules/_property-desc.js","webpack:///./~/.2.4.1@core-js/library/modules/_set-to-string-tag.js","webpack:///./~/.2.4.1@core-js/library/modules/_shared-key.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-integer.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-iobject.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-length.js","webpack:///./~/.6.20.0@babel-runtime/core-js/array/from.js","webpack:///./~/.6.20.0@babel-runtime/core-js/json/stringify.js","webpack:///./~/echarts/lib/CoordinateSystem.js","webpack:///./~/echarts/lib/coord/axisHelper.js","webpack:///./~/echarts/lib/data/List.js","webpack:///./~/echarts/lib/scale/Interval.js","webpack:///./~/echarts/lib/util/component.js","webpack:///./~/echarts/~/zrender/lib/core/timsort.js","webpack:///./~/echarts/~/zrender/lib/graphic/Displayable.js","webpack:///./~/echarts/~/zrender/lib/graphic/Gradient.js","webpack:///./~/vue/dist/vue.common.js","webpack:///./~/.2.4.1@core-js/library/modules/_classof.js","webpack:///./~/.2.4.1@core-js/library/modules/_enum-bug-keys.js","webpack:///./~/.2.4.1@core-js/library/modules/_fails.js","webpack:///./~/.2.4.1@core-js/library/modules/_html.js","webpack:///./~/.2.4.1@core-js/library/modules/_is-array-iter.js","webpack:///./~/.2.4.1@core-js/library/modules/_iter-call.js","webpack:///./~/.2.4.1@core-js/library/modules/_iter-define.js","webpack:///./~/.2.4.1@core-js/library/modules/_iter-detect.js","webpack:///./~/.2.4.1@core-js/library/modules/_library.js","webpack:///./~/.2.4.1@core-js/library/modules/_shared.js","webpack:///./~/.2.4.1@core-js/library/modules/_task.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-object.js","webpack:///./~/.2.4.1@core-js/library/modules/_uid.js","webpack:///./~/.2.4.1@core-js/library/modules/core.get-iterator-method.js","webpack:///./~/.2.4.1@core-js/library/modules/es6.string.iterator.js","webpack:///./~/echarts/lib/component/grid.js","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./~/echarts/lib/coord/cartesian/Grid.js","webpack:///./~/echarts/lib/data/helper/completeDimensions.js","webpack:///./~/echarts/lib/model/Series.js","webpack:///./~/echarts/lib/model/mixin/colorPalette.js","webpack:///./~/echarts/lib/view/Chart.js","webpack:///./~/echarts/~/zrender/lib/Element.js","webpack:///./~/echarts/~/zrender/lib/animation/Animator.js","webpack:///./~/echarts/~/zrender/lib/animation/requestAnimationFrame.js","webpack:///./~/echarts/~/zrender/lib/contain/util.js","webpack:///./~/echarts/~/zrender/lib/core/guid.js","webpack:///./~/echarts/~/zrender/lib/core/log.js","webpack:///./~/echarts/~/zrender/lib/graphic/Image.js","webpack:///./~/echarts/~/zrender/lib/graphic/Pattern.js","webpack:///./~/echarts/~/zrender/lib/graphic/Style.js","webpack:///./~/echarts/~/zrender/lib/graphic/helper/poly.js","webpack:///./~/.2.4.1@core-js/library/fn/array/from.js","webpack:///./~/.2.4.1@core-js/library/fn/json/stringify.js","webpack:///./~/.2.4.1@core-js/library/fn/promise.js","webpack:///./~/.2.4.1@core-js/library/modules/_add-to-unscopables.js","webpack:///./~/.2.4.1@core-js/library/modules/_an-instance.js","webpack:///./~/.2.4.1@core-js/library/modules/_array-includes.js","webpack:///./~/.2.4.1@core-js/library/modules/_create-property.js","webpack:///./~/.2.4.1@core-js/library/modules/_for-of.js","webpack:///./~/.2.4.1@core-js/library/modules/_ie8-dom-define.js","webpack:///./~/.2.4.1@core-js/library/modules/_invoke.js","webpack:///./~/.2.4.1@core-js/library/modules/_iobject.js","webpack:///./~/.2.4.1@core-js/library/modules/_iter-create.js","webpack:///./~/.2.4.1@core-js/library/modules/_iter-step.js","webpack:///./~/.2.4.1@core-js/library/modules/_microtask.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-create.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-dps.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-gpo.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-keys-internal.js","webpack:///./~/.2.4.1@core-js/library/modules/_object-keys.js","webpack:///./~/.2.4.1@core-js/library/modules/_redefine-all.js","webpack:///./~/.2.4.1@core-js/library/modules/_redefine.js","webpack:///./~/.2.4.1@core-js/library/modules/_set-species.js","webpack:///./~/.2.4.1@core-js/library/modules/_species-constructor.js","webpack:///./~/.2.4.1@core-js/library/modules/_string-at.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-index.js","webpack:///./~/.2.4.1@core-js/library/modules/_to-primitive.js","webpack:///./~/.2.4.1@core-js/library/modules/es6.array.from.js","webpack:///./~/.2.4.1@core-js/library/modules/es6.array.iterator.js","webpack:///./~/.2.4.1@core-js/library/modules/es6.promise.js","webpack:///./~/.2.4.1@core-js/library/modules/web.dom.iterable.js","webpack:///./~/.6.20.0@babel-runtime/core-js/promise.js","webpack:///./~/echarts/lib/ExtensionAPI.js","webpack:///./~/echarts/lib/action/createDataSelectAction.js","webpack:///./~/echarts/lib/chart/bar.js","webpack:///./~/echarts/lib/chart/bar/BarSeries.js","webpack:///./~/echarts/lib/chart/bar/BarView.js","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js","webpack:///./~/echarts/lib/chart/bar/helper.js","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js","webpack:///./~/echarts/lib/chart/pie.js","webpack:///./~/echarts/lib/chart/pie/PieSeries.js","webpack:///./~/echarts/lib/chart/pie/PieView.js","webpack:///./~/echarts/lib/chart/pie/labelLayout.js","webpack:///./~/echarts/lib/chart/pie/pieLayout.js","webpack:///./~/echarts/lib/component/axis.js","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js","webpack:///./~/echarts/lib/component/axis/AxisView.js","webpack:///./~/echarts/lib/component/helper/listComponent.js","webpack:///./~/echarts/lib/component/helper/selectableMixin.js","webpack:///./~/echarts/lib/component/legend.js","webpack:///./~/echarts/lib/component/legend/LegendModel.js","webpack:///./~/echarts/lib/component/legend/LegendView.js","webpack:///./~/echarts/lib/component/legend/legendAction.js","webpack:///./~/echarts/lib/component/legend/legendFilter.js","webpack:///./~/echarts/lib/component/title.js","webpack:///./~/echarts/lib/component/tooltip.js","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js","webpack:///./~/echarts/lib/coord/Axis.js","webpack:///./~/echarts/lib/coord/axisDefault.js","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js","webpack:///./~/echarts/lib/coord/axisModelCreator.js","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js","webpack:///./~/echarts/lib/coord/cartesian/axisLabelInterval.js","webpack:///./~/echarts/lib/data/DataDiffer.js","webpack:///./~/echarts/lib/layout/barGrid.js","webpack:///./~/echarts/lib/loading/default.js","webpack:///./~/echarts/lib/model/Global.js","webpack:///./~/echarts/lib/model/OptionManager.js","webpack:///./~/echarts/lib/model/globalDefault.js","webpack:///./~/echarts/lib/model/mixin/areaStyle.js","webpack:///./~/echarts/lib/model/mixin/boxLayout.js","webpack:///./~/echarts/lib/model/mixin/itemStyle.js","webpack:///./~/echarts/lib/model/mixin/lineStyle.js","webpack:///./~/echarts/lib/model/mixin/textStyle.js","webpack:///./~/echarts/lib/preprocessor/backwardCompat.js","webpack:///./~/echarts/lib/preprocessor/helper/compatStyle.js","webpack:///./~/echarts/lib/processor/dataFilter.js","webpack:///./~/echarts/lib/scale/Log.js","webpack:///./~/echarts/lib/scale/Ordinal.js","webpack:///./~/echarts/lib/scale/Time.js","webpack:///./~/echarts/lib/util/symbol.js","webpack:///./~/echarts/lib/util/throttle.js","webpack:///./~/echarts/lib/view/Component.js","webpack:///./~/echarts/lib/visual/dataColor.js","webpack:///./~/echarts/lib/visual/seriesColor.js","webpack:///./~/echarts/~/zrender/lib/Handler.js","webpack:///./~/echarts/~/zrender/lib/Layer.js","webpack:///./~/echarts/~/zrender/lib/Painter.js","webpack:///./~/echarts/~/zrender/lib/Storage.js","webpack:///./~/echarts/~/zrender/lib/animation/Animation.js","webpack:///./~/echarts/~/zrender/lib/animation/Clip.js","webpack:///./~/echarts/~/zrender/lib/animation/easing.js","webpack:///./~/echarts/~/zrender/lib/contain/arc.js","webpack:///./~/echarts/~/zrender/lib/contain/cubic.js","webpack:///./~/echarts/~/zrender/lib/contain/line.js","webpack:///./~/echarts/~/zrender/lib/contain/path.js","webpack:///./~/echarts/~/zrender/lib/contain/quadratic.js","webpack:///./~/echarts/~/zrender/lib/contain/windingLine.js","webpack:///./~/echarts/~/zrender/lib/core/GestureMgr.js","webpack:///./~/echarts/~/zrender/lib/core/LRU.js","webpack:///./~/echarts/~/zrender/lib/core/bbox.js","webpack:///./~/echarts/~/zrender/lib/dom/HandlerProxy.js","webpack:///./~/echarts/~/zrender/lib/graphic/CompoundPath.js","webpack:///./~/echarts/~/zrender/lib/graphic/LinearGradient.js","webpack:///./~/echarts/~/zrender/lib/graphic/RadialGradient.js","webpack:///./~/echarts/~/zrender/lib/graphic/Text.js","webpack:///./~/echarts/~/zrender/lib/graphic/helper/roundRect.js","webpack:///./~/echarts/~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///./~/echarts/~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///./~/echarts/~/zrender/lib/graphic/mixin/RectText.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Arc.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Circle.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Line.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Polygon.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Polyline.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Rect.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Ring.js","webpack:///./~/echarts/~/zrender/lib/graphic/shape/Sector.js","webpack:///./~/echarts/~/zrender/lib/mixin/Animatable.js","webpack:///./~/echarts/~/zrender/lib/mixin/Draggable.js","webpack:///./~/echarts/~/zrender/lib/mixin/Transformable.js","webpack:///./~/echarts/~/zrender/lib/tool/path.js","webpack:///./~/echarts/~/zrender/lib/tool/transformPath.js","webpack:///./~/echarts/~/zrender/lib/zrender.js","webpack:///./~/vue-router/dist/vue-router.common.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/addStyles.js"],"names":["webpackJsonp","module","exports","clone","source","result","typeStr","objToString","call","i","len","length","TYPED_ARRAY","constructor","from","BUILTIN_OBJECT","isDom","key","hasOwnProperty","merge","target","overwrite","isObject","targetProp","sourceProp","isArray","isBuildInObject","mergeAll","targetAndSources","extend","defaults","overlay","createCanvas","document","createElement","getContext","_ctx","util","indexOf","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prototype","prop","superClass","mixin","isArrayLike","data","each","obj","cb","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","curry","this","isFunction","isString","type","nodeType","ownerDocument","eqNaN","retrieve","values","slice","Function","assert","condition","message","Error","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","Object","toString","arrayProto","Array","noop","__webpack_require__","global","createRegisterEventWithLowercaseName","method","eventName","handler","toLowerCase","Eventful","MessageCenter","ECharts","dom","theme","opts","prioritySortFunc","a","b","prio","themeStorage","id","group","_dom","zr","_zr","zrender","init","renderer","devicePixelRatio","width","height","_throttledZrFlush","throttle","zrUtil","flush","_theme","_chartsViews","_chartsMap","_componentsViews","_componentsMap","_api","ExtensionAPI","_coordSysMgr","CoordinateSystemManager","_messageCenter","_initEvents","resize","_pendingActions","timsort","visualFuncs","dataProcessorFuncs","animation","on","_onframe","doConvertPixel","methodName","finder","ecModel","_model","coordSysList","getCoordinateSystems","modelUtil","parseFinder","coordSys","__DEV__","console","warn","updateDirectly","ecIns","payload","mainType","subType","query","eachComponent","model","index","view","__viewId","__alive","doDispatchAction","silent","payloadType","actionWrap","actions","actionInfo","cptType","update","split","updateMethod","pop","parseClassType","IN_MAIN_PROCESS","payloads","batched","batch","item","eventObj","eventObjBatch","isHighDown","batchItem","action","event","main","sub","OPTION_UPDATED","updateMethods","prepareAndUpdate","trigger","flushPendingActions","pendingActions","shift","triggerUpdatedEvent","invokeUpdateMethod","api","component","componentModel","__model","updateZ","eachSeries","seriesModel","idx","chart","updateProgressiveAndBlend","updateHoverLayerStatus","prepareView","isComponent","viewList","viewMap","componentType","viewId","classType","Clazz","ComponentView","getClass","ChartView","add","__id","remove","dispose","splice","processData","process","stackSeriesData","stackedDataMap","series","stack","get","getData","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","clearColorPalette","doRender","componentView","render","chartView","storage","elCount","traverse","el","isGroup","env","node","useHoverLayer","ignore","frameDrawNum","needProgressive","progressive","Math","floor","stopAnimation","blendMode","canvasSupported","setStyle","z","zlevel","enableConnect","updateConnectedChartsStatus","charts","status","otherChart","STATUS_KEY","STATUS_PENDING","STATUS_UPDATING","STATUS_UPDATED","eventActionMap","actionType","eventType","connectedGroups","makeActionFromEvent","otherCharts","instances","dispatchAction","window","GlobalModel","OptionManager","ComponentModel","SeriesModel","graphic","colorTool","PRIORITY_PROCESSOR_FILTER","PRIORITY_PROCESSOR_STATISTIC","PRIORITY_VISUAL_LAYOUT","PRIORITY_VISUAL_GLOBAL","PRIORITY_VISUAL_CHART","PRIORITY_VISUAL_COMPONENT","PRIORITY_VISUAL_BRUSH","HAS_GRADIENT_OR_PATTERN_BG","ACTION_REG","off","one","echartsProto","getDom","getZr","setOption","option","notMerge","lazyUpdate","optionManager","__lastOnlyGraphic","o","optionPreprocessorFuncs","setTheme","log","getModel","getOption","getWidth","getHeight","getRenderedCanvas","pixelRatio","backgroundColor","list","getDisplayList","painter","getDataURL","excludeComponents","excludesComponentViews","self","url","toDataURL","getConnectedDataURL","groupId","mathMin","min","mathMax","max","MAX_NUMBER","Infinity","left","top","right","bottom","canvasList","dpr","canvas","boundingRect","getBoundingClientRect","targetCanvas","img","Image","style","x","y","image","refreshImmediately","convertToPixel","convertFromPixel","containPixel","models","coordinateSystem","containPoint","getVisual","visualType","defaultMainType","dataIndexInside","indexOfRawIndex","dataIndex","getItemVisual","coordSysMgr","restoreData","create","isSingleCanvas","configLayer","clearColor","colorArr","parse","stringify","colorStops","background","updateView","clearAllVisual","updateVisual","updateLayout","optionChanged","resetOption","_loadingFX","showLoading","name","cfg","hideLoading","loadingEffects","opt","browser","weChat","MOUSE_EVENT_NAMES","eveName","e","params","dataModel","getSeriesByIndex","seriesIndex","getDataParams","dataType","eventData","isDisposed","_disposed","clear","idBase","Date","groupIdBase","DOM_ATTRIBUTE_KEY","echarts","version","dependencies","replace","nodeName","toUpperCase","clientWidth","clientHeight","setAttribute","connect","disConnect","getInstanceByDom","getAttribute","getInstanceById","registerTheme","registerPreprocessor","preprocessorFunc","registerProcessor","priority","processorFunc","isNaN","registerAction","test","registerCoordinateSystem","CoordinateSystem","register","registerLayout","layoutFunc","registerVisual","visualFunc","registerLoading","loadingFx","extendComponentModel","extendComponentView","extendSeriesModel","extendChartView","setCanvasCreator","creator","List","Model","number","format","matrix","vector","color","PRIORITY","PROCESSOR","FILTER","STATISTIC","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","stroke","fill","hoverStyle","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","__zr","addHover","z2","doSingleLeaveHover","normalStl","removeHover","doEnterHover","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","zrByTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","animationEnabled","isAnimationEnabled","postfix","duration","getShallow","animationEasing","animationDelay","getAnimationDelayParams","animateTo","attr","pathTool","round","Path","Group","Text","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","extendShape","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","getBoundingRect","aspect","cx","cy","resizePath","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","position","positiveOrNegative","doubledPosition","setHoverStyle","hoverSilentOnTouch","setText","textStyle","labelModel","labelPosition","labelOffset","labelColor","textStyleModel","textDistance","textFont","getFont","textPosition","textOffset","textFill","getTextColor","updateProps","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","rotation","elMap1","oldEl","newProp","_trim","str","RADIAN_EPSILON","linearMap","val","domain","range","clamp","subDomain","subRange","parsePercent","percent","all","match","parseFloat","NaN","precision","toFixed","asc","arr","sort","getPrecision","count","getPrecisionSafe","dotIndex","getPixelPrecision","dataExtent","pixelExtent","LN10","dataQuantity","sizeQuantity","isFinite","MAX_SAFE_INTEGER","remRadian","radian","pi2","PI","isRadianAroundZero","parseDate","ret","quantity","pow","nice","nf","exp10","f","reformIntervals","littleThan","lg","interval","close","curr","currClose","isNumeric","v","ArrayCtor","Float32Array","out","copy","set","v1","v2","scaleAndAdd","sqrt","lenSquare","div","dot","scale","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Displayable","PathProxy","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","ctx","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","__dirty","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","rebuildPath","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirty","dirtyPath","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","store","uid","Symbol","USE_SYMBOL","$exports","__g","numberUtil","textContain","formatUtil","addCommas","toCamelCase","upperCaseFirst","group1","charAt","normalizeCssArray","encodeHTML","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","formatTpl","tpl","paramsList","encode","seriesLen","$vars","alias","k","s2d","formatTime","date","getFullYear","M","getMonth","getDate","h","getHours","getMinutes","getSeconds","capitalFirst","substr","truncateText","detect","ua","os","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","default","options","staticRenderFns","_scopeId","computed","keys","parentModel","doGet","pathArr","getParent","getParentMethod","clazzUtil","mergeOption","ignoreParent","parsePath","thisParentModel","isEmpty","Ctor","setReadOnly","properties","customizeGetParent","enableClassExtend","has","nubmerUtil","normalizeToArray","defaultEmphasis","subOpts","emphasisOpt","emphasis","normalOpt","normal","subOptName","LABEL_OPTIONS","getDataItemValue","dataItem","isDataItemOption","converDataValue","dimInfo","dimType","createDataFormatModel","dataFormatMixin","seriesName","rawValue","getRawValue","rawDataIndex","getRawIndex","getName","itemOpt","getRawDataItem","componentSubType","seriesType","getFormattedLabel","dimIndex","itemModel","getItemModel","formatter","formatTooltip","mappingToExists","exists","newCptOptions","exist","cptOption","isIdInner","makeIdAndName","mapResult","idMap","existCpt","keyInfo","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","seriesId","dataIndices","otherDataIndices","j","lenj","mapToArray","isData","mapA","mapB","queryDataIndex","indexOfName","parsedKey","queryType","queryParam","queryComponents","vec2","v2ApplyTransform","union","other","lt","rb","lb","rt","maxX","maxY","sx","sy","translate","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","checkClassType","superCall","superApply","TYPE_DELIMITER","IS_CONTAINER","MEMBER_PRIFIX","host","hasOwn","RootClass","mandatoryMethods","$constructor","proto","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","componentMainType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","core","__e","getDependencies","deps","arrayPush","componentUtil","componentIndex","defaultOption","dependentModels","layoutMode","extraOpt","getUID","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","optionUpdated","newCptOption","isInit","optList","Class","getReferringComponents","enableSubTypeDefaulter","enableTopologicalTravel","it","TypeError","dP","createDesc","object","boxLayout","orient","gap","maxWidth","maxHeight","currentLineMaxSize","eachChild","nextX","nextY","nextChild","childAt","nextChildRect","moveX","newline","moveY","LOCATION_PARAMS","box","vbox","hbox","getAvailableSize","positionInfo","containerRect","margin","containerWidth","containerHeight","getLayoutRect","verticalMargin","horizontalMargin","positionElement","hv","boundingMode","needLocalTransform","elPos","dx","dy","targetOption","newOption","names","newParams","newValueCount","merged","mergedValueCount","enoughParamNumber","ignoreSize","hasProp","hasValue","hNames","vNames","hResult","vResult","copyLayoutParams","getTextWidth","textWidthCache","textLines","l","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textAlign","textBaseline","textLineLen","lineHeight","adjustTextPositionOnRect","textRect","textHeight","halfHeight","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","join","charCode","charCodeAt","font","isAroundZero","EPSILON","isNotAroundZero","cubicAt","p0","p1","p2","p3","onet","cubicDerivativeAt","cubicRootAt","roots","c","A","B","C","n","t1","disc","K","t2","discSqrt","mathSqrt","Y1","Y2","mathPow","ONE_THIRD","T","theta","acos","ASqrt","tmp","cos","THREE_SQRT","sin","t3","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","x0","y0","x3","y3","prev","next","d1","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","aFunction","fn","that","undefined","defineProperty","anObject","IE8_DOM_DEFINE","toPrimitive","O","P","Attributes","m1","m2","out0","out1","out2","out3","out4","out5","rotate","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","arrySlice","_$handlers","_h","isSilent","newList","argLen","triggerWithContext","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","p","colorStr","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba","rgba2hsla","H","S","R","G","vMin","vMax","delta","L","deltaR","deltaG","deltaB","level","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","excludes","propName","Scale","_extent","_interval","scaleProto","extent","unionExtent","unionExtentFromData","dim","getDataExtent","getExtent","setExtent","start","end","thisExtent","getTicksLabels","labels","ticks","getTicks","getLabel","config","debugMode","Element","_children","__storage","children","childOfName","childCount","_doAdd","addBefore","nextSibling","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","removeAll","includeChildren","tmpRect","tmpMat","invisible","childRect","curve","bbox","CMD","Q","Z","min2","max2","mathCos","mathSin","mathAbs","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","r","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","toStatic","lineDashSum","offset","setData","appendPath","appendSize","appendPathData","cmd","_expandData","_prevCmd","newData","dash","dashSum","nDash","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","ux","uy","dTheta","psi","fs","scaleX","scaleY","isEllipse","clientToLocal","calculate","defaultGetZrXY","layerX","offsetX","zrX","zrY","layerY","offsetY","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","zrDelta","wheelDelta","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","stop","preventDefault","stopPropagation","cancelBubble","returnValue","Dispatcher","is","hide","PROTOTYPE","$export","own","IS_FORCED","IS_GLOBAL","IS_STATIC","IS_PROTO","IS_BIND","IS_WRAP","W","expProto","virtual","U","bitmap","enumerable","configurable","writable","def","TAG","tag","stat","shared","IObject","defined","toInteger","__esModule","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","OrdinalScale","IntervalScale","axisHelper","getScaleExtent","axis","axisDataLen","boundaryGap","span","scaleType","getMin","getMax","fixMin","fixMax","originalExtent","setBlank","getNeedCrossZero","niceScaleExtent","splitNumber","base","niceExtent","minInterval","getInterval","intervalScale","origin","setInterval","createScaleByModel","axisType","getCategories","ifAxisCrossZero","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","step","tickCoord","getFormattedLabels","labelFormatter","tick","normalizeDimensions","dimensions","cloneListForMapAndSample","original","excludeDimensions","allDimensions","getDimensionInfo","hostModel","transferProperties","_storage","originalStorage","dimStore","UNDEFINED","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","time","DataDiffer","TRANSFERABLE_PROPERTIES","__wrappedMethods","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","stackable","_dimensionInfos","indices","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","hasItemOption","getDimension","initData","nameList","dimValueGetter","size","dimensionInfoMap","idList","nameRepeatCount","DataCtor","dimName","dimStorage","stackedValue","getValues","dimData","dimExtent","getSum","sum","rawIndex","mid","indexOfNearest","maxDistance","nearestIdx","minDist","diff","rawIdx","getId","dims","dimSize","filterSelf","newIndices","keep","mapArray","tmpRetValue","retValue","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","prefix","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","clearItemLayouts","itemVisual","setItemVisual","setItemDataAndSeriesIndex","setItemGraphicEl","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","mathFloor","mathCeil","roundingErrorFix","niceTicks","_niceExtent","safeLimit","reverse","expandSize","DELIMITER","random","subTypeDefaulters","registerSubTypeDefaulter","defaulter","determineSubType","componentTypeMain","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","removeEdgeAndAdd","targetNameSet","currComponentType","currVertex","isInTargetNameSet","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Style","__clipPaths","RectText","draggable","dragging","culling","cursor","rectHover","beforeBrush","afterBrush","rectContain","coord","animateStyle","useStyle","Gradient","addColorStop","_toString","JSON","toNumber","expectsLowerCase","remove$1","isPrimitive","cached","cache","hit","bind$1","boundFn","_length","toArray","to","_from","isPlainObject","OBJECT_STRING","toObject","genStaticKeys","modules","staticKeys","looseEqual","isObjectA","isObjectB","looseIndexOf","isReserved","bailRE","segments","isNative","pushTarget","_target","Dep","targetStack","popTarget","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","property","getOwnPropertyDescriptor","getter","setter","childOb","depend","dependArray","newVal","notify","set$1","del","mergeData","toVal","fromVal","mergeHook","parentVal","childVal","mergeAssets","normalizeProps","camelize","normalizeDirectives","dirs","directives","mergeOptions","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","Vue$3","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","absent","isType","Boolean","hyphenate","getPropDefaultValue","prevShouldConvert","$options","getType","createTextVNode","VNode","cloneVNode","vnode","cloned","elm","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","$forceUpdate","resolveConstructorOptions","extractProps","functional","createFunctionalComponent","listeners","nativeOn","abstract","mergeHooks","_context","slots","resolveSlots","functionalContext","slot","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","_parentVnode","_parentListeners","_renderChildren","_parentElm","_refElm","inlineTemplate","hydrating","componentInstance","_isDestroyed","activeInstance","$mount","keepAlive","mountedNode","prepatch","oldVnode","_updateFromParent","insert","_isMounted","callHook","_inactive","destroy$1","$destroy","factory","requested","cbs","pendingCallbacks","sync","resolve","reject","reason","then","attrs","domProps","altKey","checkProp","hash","preserve","hook","hooksToMerge","fromParent","ours","hooks","mergeHook$1","two","mergeVNodeHook","hookKey","injectedHash","__injected","oldHook","createEventHandle","handle","invoker","arguments$1","updateListeners","oldOn","remove$$1","cur","old","once","capture","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","last","getFirstComponentChild","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","createEmptyVNode","scopedSlots","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","initRender","$vnode","_vnode","_staticTrees","parentVnode","renderContext","$slots","$scopedSlots","_c","$createElement","renderMixin","Vue","markStatic","tree","isOnce","markStaticNode","$nextTick","nextTick","_render","ref","_renderProxy","errorHandler","_s","_v","_n","_e","_q","_i","_m","isInFor","_o","_f","_l","fallback","bindObject","scopedSlotFn","slotNodes","_b","asProp","mustUseProp","_k","eventKeyCode","builtInAlias","keyCodes","defaultSlot","isComment","initEvents","_events","_hasHookEvent","updateComponentListeners","add$1","$once","$on","remove$2","$off","oldListeners","eventsMixin","hookRE","$emit","initLifecycle","$parent","$children","$root","$refs","_watcher","_isBeingDestroyed","lifecycleMixin","_mount","$el","Watcher","_update","prevVnode","prevActiveInstance","__patch__","__vue__","renderChildren","hasChildren","propKeys","_propKeys","teardown","_watchers","_data","handlers","resetSchedulerState","queue","has$1","waiting","flushing","flushSchedulerQueue","watcher","run","devtools","emit","queueWatcher","seenObjects","_traverse","seen","isA","depId","initState","methods","initMethods","initComputed","watch","initWatch","isRoot","proxy","userDef","computedSharedDefinition","makeComputedGetter","owner","lazy","evaluate","createWatcher","$watch","stateMixin","dataDef","$set","$delete","expOrFn","user","immediate","initMixin","_init","_uid","initInternalComponent","_self","super","superOptions","cachedSuperOptions","extendOptions","components","initUse","use","plugin","installed","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","_assetTypes","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","cachedNode","pruneCacheEntry","initGlobalAPI","configDef","delete","builtInComponents","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","inBrowser","unknownElementCache","HTMLUnknownElement","HTMLElement","querySelector","createElement$1","tagName","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","setTextContent","textContent","registerRef","isRemoval","refs","refInFor","isUndef","isDef","sameVnode","vnode1","vnode2","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","emptyNodeAt","nodeOps","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isRootInsert","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","transition","activate","emptyNode","i$1","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","rm","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hasData","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","firstChild","isRenderedModule","hooks$1","isInitialPatch","isRealElement","hasAttribute","removeAttribute","oldElm","parentElm$1","_leaveCb","updateDirectives","oldDir","dir","isCreate","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","add$2","oldHandler","target$1","ev","remove$3","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","activeElement","_vModifiers","trim","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","setProp","addClass","classList","removeClass","tar","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","onEnd","setTimeout","styles","getComputedStyle","transitioneDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","enter","toggleDisplay","cancelled","resolveTransition","_enterCb","css","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","expectsCSS","userWantsControl","show","pendingNode","_pending","leave","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","afterLeave","leaveCancelled","delayLeave","def$$1","autoCssTransition","called","_enter","_","setSelected","binding","isMultiple","multiple","selected","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","applyTranslation","oldPos","pos","moved","WebkitTransform","transitionDuration","shouldDecode","content","encoded","innerHTML","decode","html","decoder","decodeAttr","shouldDecodeNewlines","nlRE","ltRE","gtRE","ampRE","quoteRE","parseHTML","advance","substring","parseStartTag","startTagOpen","startTagClose","attribute","unarySlash","handleStartTag","expectHTML","lastTag","isNonPhrasingTag","parseEndTag","canBeLeftOpenTag","unary","isUnaryTag$$1","IS_REGEX_CAPTURING_BROKEN","lowerCasedTag","lowerCasedTagName","isUnaryTag","no","isScriptOrStyle","stackedTag","reStackedTag","reCache","RegExp","endTagLength","rest","endTag","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","rest$1","parseFilters","exp","pushFilter","filters","lastFilterIndex","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","wrapFilter","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","baseWarn","msg","error","pluckModuleFunction","addProp","addAttr","addDirective","arg","addHandler","important","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","parseModel","index$1","expressionPos","expressionEndPos","lastIndexOf","eof","chr","isStringStart","parseString","parseBracket","inBracket","stringQuote","template","warn$1","platformGetTagNamespace","platformMustUseProp","platformIsPreTag","isPreTag","preTransforms","transforms","postTransforms","root","currentParent","preserveWhitespace","inVPre","inPre","checkRootConstraints","isIE","guardIESVGBug","element","makeAttrsMap","isForbiddenTag","forbidden","processPre","pre","processRawAttrs","processFor","processIf","processOnce","processKey","processRef","processSlot","processComponent","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","i$2","lastNode","decodeHTMLCached","checkInFor","inMatch","forAliasRE","for","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","ifConditions","slotName","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","isStaticKey","genStaticKeysCached","isPlatformReservedTag","markStaticRoots","genStaticKeys$1","static","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","isBuiltInTag","isDirectChildOfTemplateFor","every","genHandlers","genHandler","code","modifierCode","genKeyFilter","handlerCode","simplePathRE","fnExpRE","genFilterCode","keyVal","bind$2","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","currentOptions","warn$2","transforms$1","dataGenFns","platformDirectives$1","isPlatformReservedTag$1","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","genIfConditions","conditions","genTernaryExp","genDirectives","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","baseDirectives","inlineRenderFns","genScopedSlot","scope","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","some","maybeComponent","genText","transformSpecialNewlines","bind$$1","componentName","compile$1","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","model$1","_warn","warn$3","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","genAssignmentCode","needCompositionGuard","valueExpression","assignment","modelRs","compile$$1","baseOptions","compileToFunctions","compiled","makeFunction","getOuterHTML","outerHTML","cloneNode","_isServer","_Set","camelizeRE","hyphenateRE","optionMergeStrategies","ignoredElements","_lifecycleHooks","_maxUpdateCount","hasProto","UA","isEdge","isAndroid","isIOS","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","logError","err","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","formatComponentName","uid$1","subs","addSub","removeSub","addDep","arrayMethods","observeArray","arrayKeys","getOwnPropertyNames","isSettingProps","augment","walk","items","instanceData","defaultData","freeze","defineReactive","raw","prototypeAccessors","defineProperties","uid$2","deep","active","newDeps","depIds","newDepIds","cleanupDeps","this$1","patternTypes","KeepAlive","include","exclude","created","destroyed","testEl","acceptValue","svg","math","isHTMLTag","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","platformModules","patch$1","vmodel","needReset","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","info","platformComponents","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","regexEscapeRE","open","esc","tab","space","up","down","prevent","ctrl","alt","meta","cloak","klass$1","style$1","modules$1","directives$1","idToTemplate","mount","documentElement","compile","cof","ARG","tryGet","callee","Iterators","ITERATOR","ArrayProto","iterator","entries","LIBRARY","redefine","$iterCreate","setToStringTag","getPrototypeOf","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","Constructor","DEFAULT","IS_SET","FORCED","IteratorPrototype","getMethod","kind","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","SAFE_CLOSING","riter","skipClosing","safe","iter","done","SHARED","defer","channel","port","invoke","cel","setTask","setImmediate","clearTask","clearImmediate","MessageChannel","ONREADYSTATECHANGE","listener","port2","port1","onmessage","postMessage","importScripts","px","classof","getIteratorMethod","$at","iterated","point","gridModel","getRect","getItemStyle","xAxis","yAxis","grid","getAxisType","axisDim","axisModelCreator","AxisModel","resetRange","getCoordSysModel","gridIndex","gridId","extraOption","isAxisUsedInTheGrid","axisModel","getLabelUnionRect","labelCount","isLabelIgnored","singleRect","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","toGlobalCoord","toLocalCoord","findAxesModels","axesTypes","isCartesian2D","Cartesian2D","Axis2D","gridProto","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","onZero","adjustAxes","axesList","isHorizontal","gridRect","inverse","getBoxLayoutParams","labelUnionRect","getAxis","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","_findConvertTarget","cartesian","dataToPoint","dataToCoord","pointToData","coordToData","xAxisModel","yAxisModel","coordsList","createAxisCreator","axisPosition","axisPositionUsed","isCategory","onBand","axesCount","addAxis","coordDimToDataDim","axesModels","grids","completeDimensions","defaultNames","extraPrefix","value0","retrieveValue","guessOrdinal","classUtil","colorPaletteMixin","legendDataProvider","visualColorAccessPath","getInitialData","label","fillDataTextStyle","newSeriesOption","getLinkedData","getRawData","coordDim","dataDimToCoordDim","dataDim","getBaseAxis","multipleSeries","formatArrayValue","valStr","formattedValue","colorEl","getColorFromPalette","getAxisTooltipDataIndex","getTooltipPosition","colorIdx","colorNameMap","colorPalette","Chart","elSetState","state","toggleHighlight","dataIdx","highlight","downplay","chartProto","guid","Transformable","Animatable","clipPath","drift","decomposeTransform","afterUpdate","updateTransform","setClipPath","addSelfToZr","removeClipPath","removeSelfFromZr","animators","addAnimator","removeAnimator","defaultGetter","defaultSetter","interpolateNumber","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","catmullRomInterpolate","v0","cloneValue","rgba2String","createTrackClip","animator","easing","oneTrackDone","keyframes","_getter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","lastValue","lastFrame","lastFramePercent","onframe","frame","clip","Clip","life","_loop","delay","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","tracks","during","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","forwardToLast","clipList","removeClip","getClips","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","PI2","normalizeRadian","angle","idStart","ZImage","LRU","globalImageCache","_image","cachedImgObj","onload","put","sWidth","sHeight","drawImage","repeat","_canvasPattern","createPattern","createLinearGradient","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","opacity","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textVerticalAlign","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","styleProto","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","$JSON","forbiddenField","toIObject","toLength","toIndex","IS_INCLUDES","$this","fromIndex","$defineProperty","isArrayIter","getIterFn","BREAK","RETURN","iterable","iterFn","un","propertyIsEnumerable","descriptor","macrotask","WebKitMutationObserver","isNode","head","toggle","promise","task","dPs","enumBugKeys","IE_PROTO","Empty","createDict","iframeDocument","iframe","gt","contentWindow","write","Properties","getKeys","ObjectProto","arrayIndexOf","$keys","DESCRIPTORS","SPECIES","KEY","D","TO_STRING","valueOf","createProperty","arrayLike","aLen","mapfn","mapping","addToUnscopables","Arguments","Internal","GenericPromiseCapability","Wrapper","anInstance","forOf","speciesConstructor","microtask","PROMISE","$Promise","empty","USE_NATIVE","FakePromise","PromiseRejectionEvent","sameConstructor","isThenable","newPromiseCapability","PromiseCapability","$$resolve","$$reject","perform","isReject","chain","ok","reaction","fail","onHandleUnhandled","onUnhandled","abrupt","isUnhandled","onunhandledrejection","_a","onrejectionhandled","$reject","_d","_w","$resolve","wrapper","executor","onFulfilled","onRejected","capability","$index","alreadyCalled","race","TO_STRING_TAG","collections","Collection","chartInstance","echartsAPIList","actionInfos","isSelected","barLayoutGrid","eachSeriesByType","brushSelector","createRect","animationModel","rectShape","animateProperty","animateTarget","removeRect","getRectItemLayout","fixedLineWidth","getLineWidth","signX","signY","itemStyleModel","getBarItemStyle","labelPositionOutside","helper","setLabel","rawLayout","BAR_BORDER_WIDTH_QUERY","BarView","coordinateSystemType","_renderOnCartesian","baseAxis","newIndex","oldIndex","execute","createListFromArray","getMarkerPosition","pt","offsetIndex","legendHoverLink","barMinHeight","itemStyle","getBorderLineDash","labelText","hoverLabelModel","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","coordSysName","creators","registeredCoordSys","axesInfo","categoryIndex","createNameList","categories","categoryAxesModels","isStackable","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","xAxisType","yAxisType","isXAxisCateogry","isYAxisCategory","singleAxis","singleAxisModel","singleAxisType","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","dataSelectableMixin","PieSeries","updateSelectedMap","_defaultLabelLine","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","hoverAnimation","center","clockwise","minAngle","selectedOffset","avoidLabelOverlap","stillShowZeroSum","lineStyle","borderWidth","animationType","updateDataSelected","hasAnimation","toggleItemSelected","midAngle","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","sector","updateData","getLabelStyle","isLabelInside","piePieceProto","firstCreate","sectorShape","r0","visualColor","lineJoin","_updateLabel","labelLayout","linePoints","verticalAlign","labelHoverModel","labelLineModel","labelLineHoverModel","getLineStyle","Pie","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","newIdx","oldIdx","_createClipPath","itemLayout","adjustSingleSide","viewWidth","viewHeight","shiftDown","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","labelRotate","RADIAN","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","makeAxisEventDataBase","innerTextLayout","rotationDiff","endTextLayout","textRotate","onLeft","tooltipOpt","AxisBuilder","nameDirection","tickDirection","labelDirection","dumbGroup","_transform","_dumbGroup","hasBuilder","builders","getGroup","axisLine","pt1","pt2","lineCap","axisTick","isBlank","tickModel","lineStyleModel","tickLen","tickInterval","labelInterval","ticksCoords","getTicksCoords","ifIgnoreOnTick","axisLabel","isTwoLabelOverlapped","current","firstRect","nextRect","axisLabelShow","labelMargin","labelRotation","categoryData","textEls","triggerEvent","tickVal","itemTextStyleModel","textColor","labelBeforeFormat","textEl","targetType","firstLabel","nextLabel","lastLabel","prevLabel","axisName","nameLocation","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","formatterParams","__fullText","__truncatedText","tooltip","rawTick","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","getLabelInterval","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","_splitLine","splitLineModel","lineColors","lineInterval","lineCount","colorIndex","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","areaInterval","areaStyle","getAreaStyle","positionGroup","addBackground","padding","targetList","_selectTargetMap","targetMap","select","unSelect","toggleSelected","LegendModel","_updateData","legendData","hasSelected","availableNames","getSeries","_availableNames","align","borderColor","itemGap","itemWidth","itemHeight","inactiveColor","dispatchSelectAction","dispatchHighlightAction","dataName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","legendModel","selectMode","itemAlign","legendDrawedMap","getSeriesByName","legendSymbolType","symbolType","itemGroup","_createItem","eachRawSeries","itemIcon","tooltipModel","legendGlobalTooltipModel","createSymbol","hitRect","legendIndex","legendSelectActionHandler","selectedMap","isToggleSelect","isItemSelected","legendModels","findComponents","filterSeries","subtext","subtarget","fontSize","fontWeight","subtextStyle","titleModel","subtextStyleModel","subText","subTextEl","link","sublink","groupRect","layoutOption","layoutRect","alignStyle","assembleTransition","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","zrColor","borderName","camelCase","TooltipContent","_x","_y","_container","_show","_hideTimeout","onmouseenter","enterable","clearTimeout","_inContent","onmousemove","eventUtil","dispatch","onmouseleave","hideLater","_hideDelay","gCssText","stl","currentStyle","defaultView","domStyle","setContent","isShow","showContent","triggerOn","alwaysShowContent","confine","showDelay","hideDelay","borderRadius","extraCssText","axisPointer","animationDurationUpdate","animationEasingUpdate","crossStyle","shadowStyle","dataEqual","makeLineShape","makeRectShape","makeSectorShape","refixTooltipPosition","confineTooltipPosition","calcTooltipPosition","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","ifSeriesSupportAxisTrigger","_axisPointers","tooltipContent","_tooltipContent","_tooltipModel","_ecModel","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_lastX","_lastY","_refreshUpdateTimeout","manuallyShowTip","_tryShow","_mousemove","_hide","_showTimeout","seriesHaveDataOnIndex","_series","isTriggerAxis","findHover","manuallyHideTip","seriesGroupByAxis","globalTrigger","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","subTooltipModel","defaultHtml","asyncTicket","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","contentNotChange","lastHover","valIndex","enableAnimation","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","moveGridLine","otherExtent","targetShape","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","bandWidth","getBandWidth","getGlobalExtent","_updateCrossText","otherAxis","moveSingleLine","movePolarLine","mouseCoord","pointToCoord","coordToPoint","movePolarShadow","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","crossStyleModel","pointerModel","initShape","axisPointers","pointerType","styleModel","isShadow","elementType","seriesList","rootTooltipModel","baseDimIndex","sampleSeriesIndex","payloadBatch","firstDataIndex","firstLine","seriesTooltipModel","ticket","cbTicket","fixExtentWithBands","nTick","normalizedExtent","Axis","containData","alignWithLabel","bands","getBands","coords","getLabelsCoords","_isBlank","nameRotate","nameTruncate","nameTextStyle","nameGap","inside","splitLine","splitArea","categoryAxis","valueAxis","timeAxis","logAxis","logBase","rangeStart","rangeEnd","setRange","axisDefault","AXIS_TYPES","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","axisLabelInterval","coordExtent","_labelInterval","dimAxisMapper","_axes","Cartesian","_dimList","getAxes","getAxesByScale","_dataCoordConvert","input","dimList","output","axisX","axisY","dataToPoints","getOtherAxis","containLabel","defaultKeyGetter","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","keyArr","keyGetter","existence","_add","_remove","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","getSeriesStackId","getAxisKey","calBarWidthAndOffset","barSeries","columnsMap","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","stacks","stackId","barWidth","barMaxWidth","barGap","barCategoryGap","barGapPercent","autoWidth","column","lastColumn","widthSum","barWidthAndOffset","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","sign","lastCoord","lastCoordOrigin","maskColor","mask","labelRect","mergeTheme","themeItem","initBase","baseOption","OPTION_INNER_KEY","_seriesIndices","globalDefault","getComponentsByTypes","componentsMap","existComponent","createSeriesIndices","seriesModels","filterBySubType","cpt","assertSeriesInitialized","_optionManager","mountOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","resultItem","ComponentModelClass","newCptTypes","componentOption","getComponent","cpts","isIdArray","isNameArray","getQueryCond","q","indexAttr","idAttr","nameAttr","doFilter","queryCond","queryResult","oneSeries","rawSeriesIndex","eachRawSeriesByType","filteredSeries","componentTypes","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","rawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","platform","fontFamily","fontStyle","animationDuration","animationThreshold","progressiveThreshold","hoverLayerThreshold","lineType","getLineDash","dotSize","dashSize","gTextStyleModel","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","seriesOpt","clockWise","pointerColor","dataRange","visualMap","compatItemStyle","itemStyleOpt","POSSIBLE_STYLES","normalItemStyleOpt","emphasisItemStyleOpt","markPoint","markLine","mpData","mlData","fixRoundingError","originalVal","intervalScaleProto","mathLog","LogScale","_originalScale","originalScale","powVal","__fixMin","__fixMax","approxTickNum","rank","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","TimeScale","stepLvl","_stepLvl","approxInterval","scaleLevelsLen","scaleLevels","yearSpan","yearStep","Triangle","Diamond","Pin","asin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","line","roundRect","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolUtil","symbolPath","setColor","lib","ORIGIN_METHOD","RATE","THROTTLE_TYPE","debounce","lastExec","getTime","timer","currCall","lastCall","createOrUpdate","fnAttr","throttleType","originFn","lastThrottleType","lastRate","Component","componentProto","paletteScope","dataAll","idxMap","filteredIdx","singleDataColor","encodeColor","colorAccessPath","makeEventPacket","eveType","gestureEvent","pinchX","pinchY","pinchScale","EmptyProxy","isHover","displayable","Draggable","handlerNames","Handler","painterRoot","_hovered","_lastTouchMoment","mousemove","hovered","lastHovered","setCursor","dispatchToElement","mouseout","innerDom","toElement","relatedTarget","eventArgs","setCursorStyle","cursorStyle","targetEl","eventHandler","eventPacket","eachOtherLayer","layer","_downel","_upel","returnFalse","createDom","newDom","newDomStyle","Layer","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","initContext","createBackBuffer","clearAll","haveMotionBLur","clearRect","clearColorGradientOrPattern","__canvasGradient","save","fillRect","restore","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","clipPaths","prevClipPaths","doClip","createRoot","domRoot","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","_opts","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","_domRoot","_getSize","pathToImage","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","getViewportRoot","paintAll","_paintList","refreshHover","_startProgessive","__hoverMir","elMirror","__from","hoverElements","clearHover","hoverLayer","displayableSortFunc","getLayer","originalEl","invTransform","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","clearLayer","imageLayer","displayList","whIdx","wh","cwh","plt","prb","_pathToImage","pathTransform","ImageShape","imgShape","me","shapeCompareFunc","Storage","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","addRoot","delRoot","elId","elements","_renderList","Animation","stage","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","deferredEvents","deferredClips","_needsRemove","fire","_startLoop","pause","resume","_life","_initialized","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","restart","remainder","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","atan2","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","containPath","isStroke","windingLine","cubic","quadratic","pointPair","GestureMgr","_track","recognize","_doTrack","_recognize","touches","trackItem","recognizers","gestureInfo","pinch","track","pinchEnd","pinchPre","pinchCenter","LinkedList","tail","linkedListProto","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","extremity","fromPoints","xDim","yDim","tx","ty","vec2Min","vec2Max","eventNameFix","processGesture","gestureMgr","_gestureMgr","setTouchTimer","instance","_touching","_touchTimer","isPointerFromTouch","initDomHandler","makeMouseHandler","touchHandlerNames","_handlers","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","eventTool","TOUCH_CLICK_DELAY","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","paths","_updatePathDirty","globalCoord","fillText","strokeText","r1","r2","r3","r4","total","v2Min","v2Max","v2Scale","v2Distance","v2Add","isLoop","constraint","prevPoint","nextPoint","cps","d0","cp0","interpolate","segs","w2","w3","maxValue","baseline","shadowColor","textShadowColor","unitX","unitY","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","pointAt","tangentAt","polyHelper","roundRectHelper","shadowTemp","modified","animatingShape","pathSplitted","_animateToShallow","objShallow","propertyCount","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","dropTarget","lastDropTarget","_dropTarget","mIdentity","transformableProto","parentHasTransform","tmpTransform","transformCoordToGlobal","processArc","fa","psiDeg","xp","yp","lambda","cxp","cyp","vAngle","u","vRatio","createPathProxyFromString","cs","cc","prevCmd","cpx","cpy","ctlPtx","ctlPty","createPathOptions","pathProxy","transformPath","vMag","pathEls","pathList","pathEl","pathBundle","nPoint","mathAtan2","delInstance","HandlerProxy","useVML","painterCtors","ZRender","getInstance","registerPainter","rendererType","vml","handerProxy","_needsRefresh","oldDelFromMap","oldAddToMap","zLevel","_needsRefreshHover","refreshHoverImmediately","clearAnimation","resolveProps","route","resolveQuery","extraQuery","parsedQuery","parseQuery","parts","stringifyQuery","val2","createRoute","record","location","redirectedFrom","fullPath","getFullPath","formatMatch","isSameRoute","START","trailingSlashRE","isObjectEqual","aKeys","bKeys","isIncludedRoute","queryIncludes","guardEvent","metaKey","ctrlKey","shiftKey","defaultPrevented","button","findAnchor","_Vue","_router","_route","beforeCreate","router","history","View","Link","beforeRouteEnter","beforeRouteLeave","resolvePath","relative","append","segment","hashIndex","queryIndex","cleanPath","createRouteMap","routes","oldPathMap","oldNameMap","pathMap","nameMap","addRouteRecord","matchAs","normalizePath","redirect","childMatchAs","aliasRoute","defaultDelimiter","delimiter","PATH_REGEXP","escaped","modifier","asterisk","partial","optional","escapeGroup","escapeString","tokensToFunction","encodeURIComponentPretty","encodeURI","encodeAsterisk","pretty","encodeURIComponent","isarray","attachKeys","re","flags","sensitive","regexpToRegexp","groups","arrayToRegexp","pathToRegexp","regexp","stringToRegexp","tokensToRegExp","strict","endsWithDelimiter","getRouteRegex","regexpCache","fillParams","routeMsg","filler","regexpCompileCache","normalizeLocation","_normalized","assign","rawPath","parsedPath","basePath","createMatcher","addRoutes","currentRoute","paramNames","_createRoute","matchRoute","originalRedirect","resolveRecordPath","resolvedPath","aliasedPath","aliasedMatch","aliasedRecord","pathname","decodeURIComponent","setupScroll","setStateKey","saveScrollPosition","handleScroll","isPop","app","behavior","scrollBehavior","getScrollPosition","shouldScroll","selector","getElementPosition","isValidPosition","normalizePosition","scrollTo","getStateKey","positionStore","pageXOffset","pageYOffset","docRect","elRect","isNumber","genKey","Time","now","_key","pushState","replaceState","runQueue","normalizeBase","baseEl","resolveQueue","activated","deactivated","extractGuards","records","guards","flatMapComponents","guard","extractGuard","flatten","extractLeaveGuards","bindGuard","extractUpdateHooks","extractEnterGuards","isValid","bindEnterGuard","poll","resolveAsyncComponents","resolvedDef","getLocation","search","checkFallback","ensureSlash","getHash","replaceHash","href","pushHash","createHref","routerView","$route","_routerViewCache","depth","inactive","routerViewDepth","encodeReserveRE","encodeReserveReplacer","commaRE","toTypes","eventTypes","required","exact","$router","classes","linkActiveClass","compareTarget","aData","aAttrs","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","supportsPushState","performance","History","ready","readyCbs","listen","onReady","transitionTo","onComplete","onAbort","confirmTransition","updateRoute","ensureURL","abort","beforeHooks","postEnterCbs","enterGuards","afterHooks","HTML5History","History$$1","expectScroll","go","getCurrentLocation","HashHistory","setupListeners","AbstractHistory","targetIndex","VueRouter","apps","matcher","setupHashListener","beforeEach","afterEach","back","forward","getMatchedComponents","normalizedTo","mediaQuery","alreadyImportedModules","addStylesToDom","stylesInDom","addStyle","listToStyles","newStyles","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","cssNode","childNodes","sources","btoa","unescape","memoize","isOldIE","getElementsByTagName","mayRemove","textStore","replacement"],"mappings":"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","file":"static/js/vendor.15b1f4a37d4fc42aae31.js","sourcesContent":["webpackJsonp([1,0],[\n/* 0 */,\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // mergeDate\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // For node-canvas\n\t        '[object Image]': 1,\n\t        '[object Canvas]': 1\n\t    };\n\t\n\t    var TYPED_ARRAY = {\n\t        '[object Int8Array]': 1,\n\t        '[object Uint8Array]': 1,\n\t        '[object Uint8ClampedArray]': 1,\n\t        '[object Int16Array]': 1,\n\t        '[object Uint16Array]': 1,\n\t        '[object Int32Array]': 1,\n\t        '[object Uint32Array]': 1,\n\t        '[object Float32Array]': 1,\n\t        '[object Float64Array]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * Those data types can be cloned:\n\t     *     Plain object, Array, TypedArray, number, string, null, undefined.\n\t     * Those data types will be assgined using the orginal data:\n\t     *     BUILTIN_OBJECT\n\t     * Instance of user defined class will be cloned to a plain object, without\n\t     * properties in prototype.\n\t     * Other data types is not supported (not sure what will happen).\n\t     *\n\t     * Caution: do not support clone Date, for performance consideration.\n\t     * (There might be a large number of date in `series.data`).\n\t     * So date should not be modified in and out of echarts.\n\t     *\n\t     * @param {*} source\n\t     * @return {*} new\n\t     */\n\t    function clone(source) {\n\t        if (source == null || typeof source != 'object') {\n\t            return source;\n\t        }\n\t\n\t        var result = source;\n\t        var typeStr = objToString.call(source);\n\t\n\t        if (typeStr === '[object Array]') {\n\t            result = [];\n\t            for (var i = 0, len = source.length; i < len; i++) {\n\t                result[i] = clone(source[i]);\n\t            }\n\t        }\n\t        else if (TYPED_ARRAY[typeStr]) {\n\t            result = source.constructor.from(source);\n\t        }\n\t        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n\t            result = {};\n\t            for (var key in source) {\n\t                if (source.hasOwnProperty(key)) {\n\t                    result[key] = clone(source[key]);\n\t                }\n\t            }\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // overwritetrue\n\t                    // NOTE target[key] \n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * \n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz \n\t     * @param {Function} baseClazz \n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return typeof value === 'object'\n\t            && typeof value.nodeType === 'number'\n\t            && typeof value.ownerDocument === 'object';\n\t    }\n\t\n\t    /**\n\t     * Whether is exactly NaN. Notice isNaN('a') returns true.\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function eqNaN(value) {\n\t        return value !== value;\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        eqNaN: eqNaN,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n\t// In build process 'typeof __DEV__' will be replace with 'boolean'\n\t// So this code will be removed or disabled anyway after built.\n\tif (typeof __DEV__ === 'undefined') {\n\t    // In browser\n\t    if (typeof window !== 'undefined') {\n\t        window.__DEV__ = true;\n\t    }\n\t    // In node\n\t    else if (typeof global !== 'undefined') {\n\t        global.__DEV__ = true;\n\t    }\n\t}\n\t\n\t/*!\n\t * ECharts, a javascript interactive chart library.\n\t *\n\t * Copyright (c) 2015, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n\t */\n\t\n\t/**\n\t * @module echarts\n\t */\n\t\n\t\n\t    var env = __webpack_require__(10);\n\t\n\t    var GlobalModel = __webpack_require__(182);\n\t    var ExtensionAPI = __webpack_require__(141);\n\t    var CoordinateSystemManager = __webpack_require__(54);\n\t    var OptionManager = __webpack_require__(183);\n\t\n\t    var ComponentModel = __webpack_require__(17);\n\t    var SeriesModel = __webpack_require__(84);\n\t\n\t    var ComponentView = __webpack_require__(198);\n\t    var ChartView = __webpack_require__(86);\n\t    var graphic = __webpack_require__(3);\n\t    var modelUtil = __webpack_require__(13);\n\t    var throttle = __webpack_require__(197);\n\t\n\t    var zrender = __webpack_require__(240);\n\t    var zrUtil = __webpack_require__(1);\n\t    var colorTool = __webpack_require__(29);\n\t    var Eventful = __webpack_require__(28);\n\t    var timsort = __webpack_require__(59);\n\t\n\t    var each = zrUtil.each;\n\t    var parseClassType = ComponentModel.parseClassType;\n\t\n\t    var PRIORITY_PROCESSOR_FILTER = 1000;\n\t    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\t\n\t\n\t    var PRIORITY_VISUAL_LAYOUT = 1000;\n\t    var PRIORITY_VISUAL_GLOBAL = 2000;\n\t    var PRIORITY_VISUAL_CHART = 3000;\n\t    var PRIORITY_VISUAL_COMPONENT = 4000;\n\t    // FIXME\n\t    // necessary?\n\t    var PRIORITY_VISUAL_BRUSH = 5000;\n\t\n\t    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n\t    // where they must not be invoked nestedly, except the only case: invoke\n\t    // dispatchAction with updateMethod \"none\" in main process.\n\t    // This flag is used to carry out this rule.\n\t    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n\t    var IN_MAIN_PROCESS = '__flagInMainProcess';\n\t    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n\t    var OPTION_UPDATED = '__optionUpdated';\n\t    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\t\n\t    function createRegisterEventWithLowercaseName(method) {\n\t        return function (eventName, handler, context) {\n\t            // Event name is all lowercase\n\t            eventName = eventName && eventName.toLowerCase();\n\t            Eventful.prototype[method].call(this, eventName, handler, context);\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @module echarts~MessageCenter\n\t     */\n\t    function MessageCenter() {\n\t        Eventful.call(this);\n\t    }\n\t    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n\t    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n\t    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n\t    zrUtil.mixin(MessageCenter, Eventful);\n\t\n\t    /**\n\t     * @module echarts~ECharts\n\t     */\n\t    function ECharts (dom, theme, opts) {\n\t        opts = opts || {};\n\t\n\t        // Get theme by name\n\t        if (typeof theme === 'string') {\n\t            theme = themeStorage[theme];\n\t        }\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id;\n\t        /**\n\t         * Group id\n\t         * @type {string}\n\t         */\n\t        this.group;\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         * @private\n\t         */\n\t        this._dom = dom;\n\t        /**\n\t         * @type {module:zrender/ZRender}\n\t         * @private\n\t         */\n\t        var zr = this._zr = zrender.init(dom, {\n\t            renderer: opts.renderer || 'canvas',\n\t            devicePixelRatio: opts.devicePixelRatio,\n\t            width: opts.width,\n\t            height: opts.height\n\t        });\n\t\n\t        /**\n\t         * Expect 60 pfs.\n\t         * @type {Function}\n\t         * @private\n\t         */\n\t        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._theme = zrUtil.clone(theme);\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Chart>}\n\t         * @private\n\t         */\n\t        this._chartsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsViews = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/view/Component>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * @type {module:echarts/ExtensionAPI}\n\t         * @private\n\t         */\n\t        this._api = new ExtensionAPI(this);\n\t\n\t        /**\n\t         * @type {module:echarts/CoordinateSystem}\n\t         * @private\n\t         */\n\t        this._coordSysMgr = new CoordinateSystemManager();\n\t\n\t        Eventful.call(this);\n\t\n\t        /**\n\t         * @type {module:echarts~MessageCenter}\n\t         * @private\n\t         */\n\t        this._messageCenter = new MessageCenter();\n\t\n\t        // Init mouse events\n\t        this._initEvents();\n\t\n\t        // In case some people write `window.onresize = chart.resize`\n\t        this.resize = zrUtil.bind(this.resize, this);\n\t\n\t        // Can't dispatch action during rendering procedure\n\t        this._pendingActions = [];\n\t        // Sort on demand\n\t        function prioritySortFunc(a, b) {\n\t            return a.prio - b.prio;\n\t        }\n\t        timsort(visualFuncs, prioritySortFunc);\n\t        timsort(dataProcessorFuncs, prioritySortFunc);\n\t\n\t        zr.animation.on('frame', this._onframe, this);\n\t    }\n\t\n\t    var echartsProto = ECharts.prototype;\n\t\n\t    echartsProto._onframe = function () {\n\t        // Lazy update\n\t        if (this[OPTION_UPDATED]) {\n\t            var silent = this[OPTION_UPDATED].silent;\n\t\n\t            this[IN_MAIN_PROCESS] = true;\n\t\n\t            updateMethods.prepareAndUpdate.call(this);\n\t\n\t            this[IN_MAIN_PROCESS] = false;\n\t\n\t            this[OPTION_UPDATED] = false;\n\t\n\t            flushPendingActions.call(this, silent);\n\t\n\t            triggerUpdatedEvent.call(this, silent);\n\t        }\n\t    };\n\t    /**\n\t     * @return {HTMLDomElement}\n\t     */\n\t    echartsProto.getDom = function () {\n\t        return this._dom;\n\t    };\n\t\n\t    /**\n\t     * @return {module:zrender~ZRender}\n\t     */\n\t    echartsProto.getZr = function () {\n\t        return this._zr;\n\t    };\n\t\n\t    /**\n\t     * Usage:\n\t     * chart.setOption(option, notMerge, lazyUpdate);\n\t     * chart.setOption(option, {\n\t     *     notMerge: ...,\n\t     *     lazyUpdate: ...,\n\t     *     silent: ...\n\t     * });\n\t     *\n\t     * @param {Object} option\n\t     * @param {Object|boolean} [opts] opts or notMerge.\n\t     * @param {boolean} [opts.notMerge=false]\n\t     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n\t     */\n\t    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n\t        if (__DEV__) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n\t        }\n\t\n\t        var silent;\n\t        if (zrUtil.isObject(notMerge)) {\n\t            lazyUpdate = notMerge.lazyUpdate;\n\t            silent = notMerge.silent;\n\t            notMerge = notMerge.notMerge;\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        if (!this._model || notMerge) {\n\t            var optionManager = new OptionManager(this._api);\n\t            var theme = this._theme;\n\t            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n\t            ecModel.init(null, null, theme, optionManager);\n\t        }\n\t\n\t        // FIXME\n\t        // ugly\n\t        this.__lastOnlyGraphic = !!(option && option.graphic);\n\t        zrUtil.each(option, function (o, mainType) {\n\t            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n\t        }, this);\n\t\n\t        this._model.setOption(option, optionPreprocessorFuncs);\n\t\n\t        if (lazyUpdate) {\n\t            this[OPTION_UPDATED] = {silent: silent};\n\t            this[IN_MAIN_PROCESS] = false;\n\t        }\n\t        else {\n\t            updateMethods.prepareAndUpdate.call(this);\n\t            // Ensure zr refresh sychronously, and then pixel in canvas can be\n\t            // fetched after `setOption`.\n\t            this._zr.flush();\n\t\n\t            this[OPTION_UPDATED] = false;\n\t            this[IN_MAIN_PROCESS] = false;\n\t\n\t            flushPendingActions.call(this, silent);\n\t            triggerUpdatedEvent.call(this, silent);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     */\n\t    echartsProto.setTheme = function () {\n\t        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n\t    };\n\t\n\t    /**\n\t     * @return {module:echarts/model/Global}\n\t     */\n\t    echartsProto.getModel = function () {\n\t        return this._model;\n\t    };\n\t\n\t    /**\n\t     * @return {Object}\n\t     */\n\t    echartsProto.getOption = function () {\n\t        return this._model && this._model.getOption();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getWidth = function () {\n\t        return this._zr.getWidth();\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    echartsProto.getHeight = function () {\n\t        return this._zr.getHeight();\n\t    };\n\t\n\t    /**\n\t     * Get canvas which has all thing rendered\n\t     * @param {Object} opts\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getRenderedCanvas = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        opts = opts || {};\n\t        opts.pixelRatio = opts.pixelRatio || 1;\n\t        opts.backgroundColor = opts.backgroundColor\n\t            || this._model.get('backgroundColor');\n\t        var zr = this._zr;\n\t        var list = zr.storage.getDisplayList();\n\t        // Stop animations\n\t        zrUtil.each(list, function (el) {\n\t            el.stopAnimation(true);\n\t        });\n\t        return zr.painter.getRenderedCanvas(opts);\n\t    };\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     * @param {string} [opts.excludeComponents]\n\t     */\n\t    echartsProto.getDataURL = function (opts) {\n\t        opts = opts || {};\n\t        var excludeComponents = opts.excludeComponents;\n\t        var ecModel = this._model;\n\t        var excludesComponentViews = [];\n\t        var self = this;\n\t\n\t        each(excludeComponents, function (componentType) {\n\t            ecModel.eachComponent({\n\t                mainType: componentType\n\t            }, function (component) {\n\t                var view = self._componentsMap[component.__viewId];\n\t                if (!view.group.ignore) {\n\t                    excludesComponentViews.push(view);\n\t                    view.group.ignore = true;\n\t                }\n\t            });\n\t        });\n\t\n\t        var url = this.getRenderedCanvas(opts).toDataURL(\n\t            'image/' + (opts && opts.type || 'png')\n\t        );\n\t\n\t        each(excludesComponentViews, function (view) {\n\t            view.group.ignore = false;\n\t        });\n\t        return url;\n\t    };\n\t\n\t\n\t    /**\n\t     * @return {string}\n\t     * @param {Object} opts\n\t     * @param {string} [opts.type='png']\n\t     * @param {string} [opts.pixelRatio=1]\n\t     * @param {string} [opts.backgroundColor]\n\t     */\n\t    echartsProto.getConnectedDataURL = function (opts) {\n\t        if (!env.canvasSupported) {\n\t            return;\n\t        }\n\t        var groupId = this.group;\n\t        var mathMin = Math.min;\n\t        var mathMax = Math.max;\n\t        var MAX_NUMBER = Infinity;\n\t        if (connectedGroups[groupId]) {\n\t            var left = MAX_NUMBER;\n\t            var top = MAX_NUMBER;\n\t            var right = -MAX_NUMBER;\n\t            var bottom = -MAX_NUMBER;\n\t            var canvasList = [];\n\t            var dpr = (opts && opts.pixelRatio) || 1;\n\t\n\t            zrUtil.each(instances, function (chart, id) {\n\t                if (chart.group === groupId) {\n\t                    var canvas = chart.getRenderedCanvas(\n\t                        zrUtil.clone(opts)\n\t                    );\n\t                    var boundingRect = chart.getDom().getBoundingClientRect();\n\t                    left = mathMin(boundingRect.left, left);\n\t                    top = mathMin(boundingRect.top, top);\n\t                    right = mathMax(boundingRect.right, right);\n\t                    bottom = mathMax(boundingRect.bottom, bottom);\n\t                    canvasList.push({\n\t                        dom: canvas,\n\t                        left: boundingRect.left,\n\t                        top: boundingRect.top\n\t                    });\n\t                }\n\t            });\n\t\n\t            left *= dpr;\n\t            top *= dpr;\n\t            right *= dpr;\n\t            bottom *= dpr;\n\t            var width = right - left;\n\t            var height = bottom - top;\n\t            var targetCanvas = zrUtil.createCanvas();\n\t            targetCanvas.width = width;\n\t            targetCanvas.height = height;\n\t            var zr = zrender.init(targetCanvas);\n\t\n\t            each(canvasList, function (item) {\n\t                var img = new graphic.Image({\n\t                    style: {\n\t                        x: item.left * dpr - left,\n\t                        y: item.top * dpr - top,\n\t                        image: item.dom\n\t                    }\n\t                });\n\t                zr.add(img);\n\t            });\n\t            zr.refreshImmediately();\n\t\n\t            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n\t        }\n\t        else {\n\t            return this.getDataURL(opts);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Convert from logical coordinate system to pixel coordinate system.\n\t     * See CoordinateSystem#convertToPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId, geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName,\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\t\n\t    /**\n\t     * Convert from pixel coordinate system to logical coordinate system.\n\t     * See CoordinateSystem#convertFromPixel.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {Array|number} result\n\t     */\n\t    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\t\n\t    function doConvertPixel(methodName, finder, value) {\n\t        var ecModel = this._model;\n\t        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        for (var i = 0; i < coordSysList.length; i++) {\n\t            var coordSys = coordSysList[i];\n\t            if (coordSys[methodName]\n\t                && (result = coordSys[methodName](ecModel, finder, value)) != null\n\t            ) {\n\t                return result;\n\t            }\n\t        }\n\t\n\t        if (__DEV__) {\n\t            console.warn(\n\t                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n\t            );\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Is the specified coordinate systems or components contain the given pixel point.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            geoIndex / geoId / geoName,\n\t     *            bmapIndex / bmapId / bmapName,\n\t     *            xAxisIndex / xAxisId / xAxisName,\n\t     *            yAxisIndex / yAxisId / yAxisName\n\t     *            gridIndex / gridId / gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     * @param {Array|number} value\n\t     * @return {boolean} result\n\t     */\n\t    echartsProto.containPixel = function (finder, value) {\n\t        var ecModel = this._model;\n\t        var result;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder);\n\t\n\t        zrUtil.each(finder, function (models, key) {\n\t            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n\t                var coordSys = model.coordinateSystem;\n\t                if (coordSys && coordSys.containPoint) {\n\t                    result |= !!coordSys.containPoint(value);\n\t                }\n\t                else if (key === 'seriesModels') {\n\t                    var view = this._chartsMap[model.__viewId];\n\t                    if (view && view.containPoint) {\n\t                        result |= view.containPoint(value, model);\n\t                    }\n\t                    else {\n\t                        if (__DEV__) {\n\t                            console.warn(key + ': ' + (view\n\t                                ? 'The found component do not support containPoint.'\n\t                                : 'No view mapping to the found component.'\n\t                            ));\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    if (__DEV__) {\n\t                        console.warn(key + ': containPoint is not supported');\n\t                    }\n\t                }\n\t            }, this);\n\t        }, this);\n\t\n\t        return !!result;\n\t    };\n\t\n\t    /**\n\t     * Get visual from series or data.\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'series', means {seriesIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex / seriesId / seriesName,\n\t     *            dataIndex / dataIndexInside\n\t     *        }\n\t     *        If dataIndex is not specified, series visual will be fetched,\n\t     *        but not data item visual.\n\t     *        If all of seriesIndex, seriesId, seriesName are not specified,\n\t     *        visual will be fetched from first series.\n\t     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n\t     */\n\t    echartsProto.getVisual = function (finder, visualType) {\n\t        var ecModel = this._model;\n\t\n\t        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\t\n\t        var seriesModel = finder.seriesModel;\n\t\n\t        if (__DEV__) {\n\t            if (!seriesModel) {\n\t                console.warn('There is no specified seires model');\n\t            }\n\t        }\n\t\n\t        var data = seriesModel.getData();\n\t\n\t        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n\t            ? finder.dataIndexInside\n\t            : finder.hasOwnProperty('dataIndex')\n\t            ? data.indexOfRawIndex(finder.dataIndex)\n\t            : null;\n\t\n\t        return dataIndexInside != null\n\t            ? data.getItemVisual(dataIndexInside, visualType)\n\t            : data.getVisual(visualType);\n\t    };\n\t\n\t\n\t    var updateMethods = {\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        update: function (payload) {\n\t            // console.time && console.time('update');\n\t\n\t            var ecModel = this._model;\n\t            var api = this._api;\n\t            var coordSysMgr = this._coordSysMgr;\n\t            var zr = this._zr;\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            // Fixme First time update ?\n\t            ecModel.restoreData();\n\t\n\t            // TODO\n\t            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n\t            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\t\n\t            // Create new coordinate system each update\n\t            // In LineView may save the old coordinate system and use it to get the orignal point\n\t            coordSysMgr.create(this._model, this._api);\n\t\n\t            processData.call(this, ecModel, api);\n\t\n\t            stackSeriesData.call(this, ecModel);\n\t\n\t            coordSysMgr.update(ecModel, api);\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            doRender.call(this, ecModel, payload);\n\t\n\t            // Set background\n\t            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\t\n\t            var painter = zr.painter;\n\t            // TODO all use clearColor ?\n\t            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n\t                zr.configLayer(0, {\n\t                    clearColor: backgroundColor\n\t                });\n\t            }\n\t            else {\n\t                // In IE8\n\t                if (!env.canvasSupported) {\n\t                    var colorArr = colorTool.parse(backgroundColor);\n\t                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n\t                    if (colorArr[3] === 0) {\n\t                        backgroundColor = 'transparent';\n\t                    }\n\t                }\n\t                if (backgroundColor.colorStops || backgroundColor.image) {\n\t                    // Gradient background\n\t                    // FIXME Fixed layer\n\t                    zr.configLayer(0, {\n\t                        clearColor: backgroundColor\n\t                    });\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\t\n\t                    this._dom.style.background = 'transparent';\n\t                }\n\t                else {\n\t                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n\t                        zr.configLayer(0, {\n\t                            clearColor: null\n\t                        });\n\t                    }\n\t                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\t\n\t                    this._dom.style.background = backgroundColor;\n\t                }\n\t            }\n\t\n\t            // console.time && console.timeEnd('update');\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateView: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateVisual: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                seriesModel.getData().clearAllVisual();\n\t            });\n\t\n\t            doVisualEncoding.call(this, ecModel, payload, true);\n\t\n\t            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        updateLayout: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            // update before setOption\n\t            if (!ecModel) {\n\t                return;\n\t            }\n\t\n\t            doLayout.call(this, ecModel, payload);\n\t\n\t            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n\t        },\n\t\n\t        /**\n\t         * @param {Object} payload\n\t         * @private\n\t         */\n\t        prepareAndUpdate: function (payload) {\n\t            var ecModel = this._model;\n\t\n\t            prepareView.call(this, 'component', ecModel);\n\t\n\t            prepareView.call(this, 'chart', ecModel);\n\t\n\t            // FIXME\n\t            // ugly\n\t            if (this.__lastOnlyGraphic) {\n\t                each(this._componentsViews, function (componentView) {\n\t                    var componentModel = componentView.__model;\n\t                    if (componentModel && componentModel.mainType === 'graphic') {\n\t                        componentView.render(componentModel, ecModel, this._api, payload);\n\t                        updateZ(componentModel, componentView);\n\t                    }\n\t                }, this);\n\t                this.__lastOnlyGraphic = false;\n\t            }\n\t            else {\n\t                updateMethods.update.call(this, payload);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function updateDirectly(ecIns, method, payload, mainType, subType) {\n\t        var ecModel = ecIns._model;\n\t        var query = {};\n\t        query[mainType + 'Id'] = payload[mainType + 'Id'];\n\t        query[mainType + 'Index'] = payload[mainType + 'Index'];\n\t        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\t\n\t        var condition = {mainType: mainType, query: query};\n\t        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\t\n\t        // If dispatchAction before setOption, do nothing.\n\t        ecModel && ecModel.eachComponent(condition, function (model, index) {\n\t            var view = ecIns[\n\t                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n\t            ][model.__viewId];\n\t            if (view && view.__alive) {\n\t                view[method](model, ecModel, ecIns._api, payload);\n\t            }\n\t        }, ecIns);\n\t    }\n\t\n\t    /**\n\t     * Resize the chart\n\t     * @param {Object} opts\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @param {boolean} [opts.silent=false]\n\t     */\n\t    echartsProto.resize = function (opts) {\n\t        if (__DEV__) {\n\t            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        this._zr.resize(opts);\n\t\n\t        var optionChanged = this._model && this._model.resetOption('media');\n\t        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\t\n\t        updateMethods[updateMethod].call(this);\n\t\n\t        // Resize loading effect\n\t        this._loadingFX && this._loadingFX.resize();\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        var silent = opts && opts.silent;\n\t\n\t        flushPendingActions.call(this, silent);\n\t\n\t        triggerUpdatedEvent.call(this, silent);\n\t    };\n\t\n\t    /**\n\t     * Show loading effect\n\t     * @param  {string} [name='default']\n\t     * @param  {Object} [cfg]\n\t     */\n\t    echartsProto.showLoading = function (name, cfg) {\n\t        if (zrUtil.isObject(name)) {\n\t            cfg = name;\n\t            name = '';\n\t        }\n\t        name = name || 'default';\n\t\n\t        this.hideLoading();\n\t        if (!loadingEffects[name]) {\n\t            if (__DEV__) {\n\t                console.warn('Loading effects ' + name + ' not exists.');\n\t            }\n\t            return;\n\t        }\n\t        var el = loadingEffects[name](this._api, cfg);\n\t        var zr = this._zr;\n\t        this._loadingFX = el;\n\t\n\t        zr.add(el);\n\t    };\n\t\n\t    /**\n\t     * Hide loading effect\n\t     */\n\t    echartsProto.hideLoading = function () {\n\t        this._loadingFX && this._zr.remove(this._loadingFX);\n\t        this._loadingFX = null;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} eventObj\n\t     * @return {Object}\n\t     */\n\t    echartsProto.makeActionFromEvent = function (eventObj) {\n\t        var payload = zrUtil.extend({}, eventObj);\n\t        payload.type = eventActionMap[eventObj.type];\n\t        return payload;\n\t    };\n\t\n\t    /**\n\t     * @pubilc\n\t     * @param {Object} payload\n\t     * @param {string} [payload.type] Action type\n\t     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n\t     * @param {boolean} [opt.silent=false] Whether trigger events.\n\t     * @param {boolean} [opt.flush=undefined]\n\t     *                  true: Flush immediately, and then pixel in canvas can be fetched\n\t     *                      immediately. Caution: it might affect performance.\n\t     *                  false: Not not flush.\n\t     *                  undefined: Auto decide whether perform flush.\n\t     */\n\t    echartsProto.dispatchAction = function (payload, opt) {\n\t        if (!zrUtil.isObject(opt)) {\n\t            opt = {silent: !!opt};\n\t        }\n\t\n\t        if (!actions[payload.type]) {\n\t            return;\n\t        }\n\t\n\t        // if (__DEV__) {\n\t        //     zrUtil.assert(\n\t        //         !this[IN_MAIN_PROCESS],\n\t        //         '`dispatchAction` should not be called during main process.'\n\t        //         + 'unless updateMathod is \"none\".'\n\t        //     );\n\t        // }\n\t\n\t        // May dispatchAction in rendering procedure\n\t        if (this[IN_MAIN_PROCESS]) {\n\t            this._pendingActions.push(payload);\n\t            return;\n\t        }\n\t\n\t        doDispatchAction.call(this, payload, opt.silent);\n\t\n\t        if (opt.flush) {\n\t            this._zr.flush(true);\n\t        }\n\t        else if (opt.flush !== false && env.browser.weChat) {\n\t            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n\t            // hang when sliding page (on touch event), which cause that zr does not\n\t            // refresh util user interaction finished, which is not expected.\n\t            // But `dispatchAction` may be called too frequently when pan on touch\n\t            // screen, which impacts performance if do not throttle them.\n\t            this._throttledZrFlush();\n\t        }\n\t\n\t        flushPendingActions.call(this, opt.silent);\n\t\n\t        triggerUpdatedEvent.call(this, opt.silent);\n\t    };\n\t\n\t    function doDispatchAction(payload, silent) {\n\t        var payloadType = payload.type;\n\t        var actionWrap = actions[payloadType];\n\t        var actionInfo = actionWrap.actionInfo;\n\t\n\t        var cptType = (actionInfo.update || 'update').split(':');\n\t        var updateMethod = cptType.pop();\n\t        cptType = cptType[0] && parseClassType(cptType[0]);\n\t\n\t        this[IN_MAIN_PROCESS] = true;\n\t\n\t        var payloads = [payload];\n\t        var batched = false;\n\t        // Batch action\n\t        if (payload.batch) {\n\t            batched = true;\n\t            payloads = zrUtil.map(payload.batch, function (item) {\n\t                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n\t                item.batch = null;\n\t                return item;\n\t            });\n\t        }\n\t\n\t        var eventObjBatch = [];\n\t        var eventObj;\n\t        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\t\n\t        for (var i = 0; i < payloads.length; i++) {\n\t            var batchItem = payloads[i];\n\t            // Action can specify the event by return it.\n\t            eventObj = actionWrap.action(batchItem, this._model);\n\t            // Emit event outside\n\t            eventObj = eventObj || zrUtil.extend({}, batchItem);\n\t            // Convert type to eventType\n\t            eventObj.type = actionInfo.event || eventObj.type;\n\t            eventObjBatch.push(eventObj);\n\t\n\t            // light update does not perform data process, layout and visual.\n\t            if (isHighDown) {\n\t                // method, payload, mainType, subType\n\t                updateDirectly(this, updateMethod, batchItem, 'series');\n\t            }\n\t            else if (cptType) {\n\t                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n\t            }\n\t        }\n\t\n\t        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n\t            // Still dirty\n\t            if (this[OPTION_UPDATED]) {\n\t                // FIXME Pass payload ?\n\t                updateMethods.prepareAndUpdate.call(this, payload);\n\t                this[OPTION_UPDATED] = false;\n\t            }\n\t            else {\n\t                updateMethods[updateMethod].call(this, payload);\n\t            }\n\t        }\n\t\n\t        // Follow the rule of action batch\n\t        if (batched) {\n\t            eventObj = {\n\t                type: actionInfo.event || payloadType,\n\t                batch: eventObjBatch\n\t            };\n\t        }\n\t        else {\n\t            eventObj = eventObjBatch[0];\n\t        }\n\t\n\t        this[IN_MAIN_PROCESS] = false;\n\t\n\t        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n\t    }\n\t\n\t    function flushPendingActions(silent) {\n\t        var pendingActions = this._pendingActions;\n\t        while (pendingActions.length) {\n\t            var payload = pendingActions.shift();\n\t            doDispatchAction.call(this, payload, silent);\n\t        }\n\t    }\n\t\n\t    function triggerUpdatedEvent(silent) {\n\t        !silent && this.trigger('updated');\n\t    }\n\t\n\t    /**\n\t     * Register event\n\t     * @method\n\t     */\n\t    echartsProto.on = createRegisterEventWithLowercaseName('on');\n\t    echartsProto.off = createRegisterEventWithLowercaseName('off');\n\t    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\t\n\t    /**\n\t     * @param {string} methodName\n\t     * @private\n\t     */\n\t    function invokeUpdateMethod(methodName, ecModel, payload) {\n\t        var api = this._api;\n\t\n\t        // Update all components\n\t        each(this._componentsViews, function (component) {\n\t            var componentModel = component.__model;\n\t            component[methodName](componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, component);\n\t        }, this);\n\t\n\t        // Upate all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chart = this._chartsMap[seriesModel.__viewId];\n\t            chart[methodName](seriesModel, ecModel, api, payload);\n\t\n\t            updateZ(seriesModel, chart);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chart);\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t    }\n\t\n\t    /**\n\t     * Prepare view instances of charts and components\n\t     * @param  {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function prepareView(type, ecModel) {\n\t        var isComponent = type === 'component';\n\t        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n\t        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n\t        var zr = this._zr;\n\t\n\t        for (var i = 0; i < viewList.length; i++) {\n\t            viewList[i].__alive = false;\n\t        }\n\t\n\t        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n\t            if (isComponent) {\n\t                if (componentType === 'series') {\n\t                    return;\n\t                }\n\t            }\n\t            else {\n\t                model = componentType;\n\t            }\n\t\n\t            // Consider: id same and type changed.\n\t            var viewId = model.id + '_' + model.type;\n\t            var view = viewMap[viewId];\n\t            if (!view) {\n\t                var classType = parseClassType(model.type);\n\t                var Clazz = isComponent\n\t                    ? ComponentView.getClass(classType.main, classType.sub)\n\t                    : ChartView.getClass(classType.sub);\n\t                if (Clazz) {\n\t                    view = new Clazz();\n\t                    view.init(ecModel, this._api);\n\t                    viewMap[viewId] = view;\n\t                    viewList.push(view);\n\t                    zr.add(view.group);\n\t                }\n\t                else {\n\t                    // Error\n\t                    return;\n\t                }\n\t            }\n\t\n\t            model.__viewId = viewId;\n\t            view.__alive = true;\n\t            view.__id = viewId;\n\t            view.__model = model;\n\t        }, this);\n\t\n\t        for (var i = 0; i < viewList.length;) {\n\t            var view = viewList[i];\n\t            if (!view.__alive) {\n\t                zr.remove(view.group);\n\t                view.dispose(ecModel, this._api);\n\t                viewList.splice(i, 1);\n\t                delete viewMap[view.__id];\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Processor data in each series\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function processData(ecModel, api) {\n\t        each(dataProcessorFuncs, function (process) {\n\t            process.func(ecModel, api);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function stackSeriesData(ecModel) {\n\t        var stackedDataMap = {};\n\t        ecModel.eachSeries(function (series) {\n\t            var stack = series.get('stack');\n\t            var data = series.getData();\n\t            if (stack && data.type === 'list') {\n\t                var previousStack = stackedDataMap[stack];\n\t                if (previousStack) {\n\t                    data.stackedOn = previousStack;\n\t                }\n\t                stackedDataMap[stack] = data;\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Layout before each chart render there series, special visual encoding stage\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @private\n\t     */\n\t    function doLayout(ecModel, payload) {\n\t        var api = this._api;\n\t        each(visualFuncs, function (visual) {\n\t            if (visual.isLayout) {\n\t                visual.func(ecModel, api, payload);\n\t            }\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Encode visual infomation from data after data processing\n\t     *\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {object} layout\n\t     * @param {boolean} [excludesLayout]\n\t     * @private\n\t     */\n\t    function doVisualEncoding(ecModel, payload, excludesLayout) {\n\t        var api = this._api;\n\t        ecModel.clearColorPalette();\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            seriesModel.clearColorPalette();\n\t        });\n\t        each(visualFuncs, function (visual) {\n\t            (!excludesLayout || !visual.isLayout)\n\t                && visual.func(ecModel, api, payload);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * Render each chart and component\n\t     * @private\n\t     */\n\t    function doRender(ecModel, payload) {\n\t        var api = this._api;\n\t        // Render all components\n\t        each(this._componentsViews, function (componentView) {\n\t            var componentModel = componentView.__model;\n\t            componentView.render(componentModel, ecModel, api, payload);\n\t\n\t            updateZ(componentModel, componentView);\n\t        }, this);\n\t\n\t        each(this._chartsViews, function (chart) {\n\t            chart.__alive = false;\n\t        }, this);\n\t\n\t        // Render all charts\n\t        ecModel.eachSeries(function (seriesModel, idx) {\n\t            var chartView = this._chartsMap[seriesModel.__viewId];\n\t            chartView.__alive = true;\n\t            chartView.render(seriesModel, ecModel, api, payload);\n\t\n\t            chartView.group.silent = !!seriesModel.get('silent');\n\t\n\t            updateZ(seriesModel, chartView);\n\t\n\t            updateProgressiveAndBlend(seriesModel, chartView);\n\t\n\t        }, this);\n\t\n\t        // If use hover layer\n\t        updateHoverLayerStatus(this._zr, ecModel);\n\t\n\t        // Remove groups of unrendered charts\n\t        each(this._chartsViews, function (chart) {\n\t            if (!chart.__alive) {\n\t                chart.remove(ecModel, api);\n\t            }\n\t        }, this);\n\t    }\n\t\n\t    var MOUSE_EVENT_NAMES = [\n\t        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n\t        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @private\n\t     */\n\t    echartsProto._initEvents = function () {\n\t        each(MOUSE_EVENT_NAMES, function (eveName) {\n\t            this._zr.on(eveName, function (e) {\n\t                var ecModel = this.getModel();\n\t                var el = e.target;\n\t                var params;\n\t\n\t                // no e.target when 'globalout'.\n\t                if (eveName === 'globalout') {\n\t                    params = {};\n\t                }\n\t                else if (el && el.dataIndex != null) {\n\t                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n\t                }\n\t                // If element has custom eventData of components\n\t                else if (el && el.eventData) {\n\t                    params = zrUtil.extend({}, el.eventData);\n\t                }\n\t\n\t                if (params) {\n\t                    params.event = e;\n\t                    params.type = eveName;\n\t                    this.trigger(eveName, params);\n\t                }\n\t\n\t            }, this);\n\t        }, this);\n\t\n\t        each(eventActionMap, function (actionType, eventType) {\n\t            this._messageCenter.on(eventType, function (event) {\n\t                this.trigger(eventType, event);\n\t            }, this);\n\t        }, this);\n\t    };\n\t\n\t    /**\n\t     * @return {boolean}\n\t     */\n\t    echartsProto.isDisposed = function () {\n\t        return this._disposed;\n\t    };\n\t\n\t    /**\n\t     * Clear\n\t     */\n\t    echartsProto.clear = function () {\n\t        this.setOption({ series: [] }, true);\n\t    };\n\t    /**\n\t     * Dispose instance\n\t     */\n\t    echartsProto.dispose = function () {\n\t        if (this._disposed) {\n\t            if (__DEV__) {\n\t                console.warn('Instance ' + this.id + ' has been disposed');\n\t            }\n\t            return;\n\t        }\n\t        this._disposed = true;\n\t\n\t        var api = this._api;\n\t        var ecModel = this._model;\n\t\n\t        each(this._componentsViews, function (component) {\n\t            component.dispose(ecModel, api);\n\t        });\n\t        each(this._chartsViews, function (chart) {\n\t            chart.dispose(ecModel, api);\n\t        });\n\t\n\t        // Dispose after all views disposed\n\t        this._zr.dispose();\n\t\n\t        delete instances[this.id];\n\t    };\n\t\n\t    zrUtil.mixin(ECharts, Eventful);\n\t\n\t    function updateHoverLayerStatus(zr, ecModel) {\n\t        var storage = zr.storage;\n\t        var elCount = 0;\n\t        storage.traverse(function (el) {\n\t            if (!el.isGroup) {\n\t                elCount++;\n\t            }\n\t        });\n\t        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n\t            storage.traverse(function (el) {\n\t                if (!el.isGroup) {\n\t                    el.useHoverLayer = true;\n\t                }\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Update chart progressive and blend.\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateProgressiveAndBlend(seriesModel, chartView) {\n\t        // Progressive configuration\n\t        var elCount = 0;\n\t        chartView.group.traverse(function (el) {\n\t            if (el.type !== 'group' && !el.ignore) {\n\t                elCount++;\n\t            }\n\t        });\n\t        var frameDrawNum = +seriesModel.get('progressive');\n\t        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n\t        if (needProgressive) {\n\t            chartView.group.traverse(function (el) {\n\t                // FIXME marker and other components\n\t                if (!el.isGroup) {\n\t                    el.progressive = needProgressive ?\n\t                        Math.floor(elCount++ / frameDrawNum) : -1;\n\t                    if (needProgressive) {\n\t                        el.stopAnimation(true);\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // Blend configration\n\t        var blendMode = seriesModel.get('blendMode') || null;\n\t        if (__DEV__) {\n\t            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n\t                console.warn('Only canvas support blendMode');\n\t            }\n\t        }\n\t        chartView.group.traverse(function (el) {\n\t            // FIXME marker and other components\n\t            if (!el.isGroup) {\n\t                el.setStyle('blend', blendMode);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n\t     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n\t     */\n\t    function updateZ(model, view) {\n\t        var z = model.get('z');\n\t        var zlevel = model.get('zlevel');\n\t        // Set z and zlevel\n\t        view.group.traverse(function (el) {\n\t            if (el.type !== 'group') {\n\t                z != null && (el.z = z);\n\t                zlevel != null && (el.zlevel = zlevel);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var actions = [];\n\t\n\t    /**\n\t     * Map eventType to actionType\n\t     * @type {Object}\n\t     */\n\t    var eventActionMap = {};\n\t\n\t    /**\n\t     * Data processor functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var dataProcessorFuncs = [];\n\t\n\t    /**\n\t     * @type {Array.<Function>}\n\t     * @inner\n\t     */\n\t    var optionPreprocessorFuncs = [];\n\t\n\t    /**\n\t     * Visual encoding functions of each stage\n\t     * @type {Array.<Object.<string, Function>>}\n\t     * @inner\n\t     */\n\t    var visualFuncs = [];\n\t    /**\n\t     * Theme storage\n\t     * @type {Object.<key, Object>}\n\t     */\n\t    var themeStorage = {};\n\t    /**\n\t     * Loading effects\n\t     */\n\t    var loadingEffects = {};\n\t\n\t\n\t    var instances = {};\n\t    var connectedGroups = {};\n\t\n\t    var idBase = new Date() - 0;\n\t    var groupIdBase = new Date() - 0;\n\t    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\t    /**\n\t     * @alias module:echarts\n\t     */\n\t    var echarts = {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        version: '3.4.0',\n\t        dependencies: {\n\t            zrender: '3.3.0'\n\t        }\n\t    };\n\t\n\t    function enableConnect(chart) {\n\t\n\t        var STATUS_PENDING = 0;\n\t        var STATUS_UPDATING = 1;\n\t        var STATUS_UPDATED = 2;\n\t        var STATUS_KEY = '__connectUpdateStatus';\n\t        function updateConnectedChartsStatus(charts, status) {\n\t            for (var i = 0; i < charts.length; i++) {\n\t                var otherChart = charts[i];\n\t                otherChart[STATUS_KEY] = status;\n\t            }\n\t        }\n\t        zrUtil.each(eventActionMap, function (actionType, eventType) {\n\t            chart._messageCenter.on(eventType, function (event) {\n\t                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n\t                    var action = chart.makeActionFromEvent(event);\n\t                    var otherCharts = [];\n\t\n\t                    zrUtil.each(instances, function (otherChart) {\n\t                        if (otherChart !== chart && otherChart.group === chart.group) {\n\t                            otherCharts.push(otherChart);\n\t                        }\n\t                    });\n\t\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n\t                    each(otherCharts, function (otherChart) {\n\t                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n\t                            otherChart.dispatchAction(action);\n\t                        }\n\t                    });\n\t                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n\t                }\n\t            });\n\t        });\n\t\n\t    }\n\t    /**\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} [theme]\n\t     * @param {Object} opts\n\t     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n\t     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n\t     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n\t     *                              Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n\t     *                               Can be 'auto' (the same as null/undefined)\n\t     */\n\t    echarts.init = function (dom, theme, opts) {\n\t        if (__DEV__) {\n\t            // Check version\n\t            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n\t                throw new Error(\n\t                    'ZRender ' + zrender.version\n\t                    + ' is too old for ECharts ' + echarts.version\n\t                    + '. Current version need ZRender '\n\t                    + echarts.dependencies.zrender + '+'\n\t                );\n\t            }\n\t            if (!dom) {\n\t                throw new Error('Initialize failed: invalid dom.');\n\t            }\n\t            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n\t                console.warn('Can\\'t get dom width or height');\n\t            }\n\t        }\n\t\n\t        var chart = new ECharts(dom, theme, opts);\n\t        chart.id = 'ec_' + idBase++;\n\t        instances[chart.id] = chart;\n\t\n\t        dom.setAttribute &&\n\t            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\t\n\t        enableConnect(chart);\n\t\n\t        return chart;\n\t    };\n\t\n\t    /**\n\t     * @return {string|Array.<module:echarts~ECharts>} groupId\n\t     */\n\t    echarts.connect = function (groupId) {\n\t        // Is array of charts\n\t        if (zrUtil.isArray(groupId)) {\n\t            var charts = groupId;\n\t            groupId = null;\n\t            // If any chart has group\n\t            zrUtil.each(charts, function (chart) {\n\t                if (chart.group != null) {\n\t                    groupId = chart.group;\n\t                }\n\t            });\n\t            groupId = groupId || ('g_' + groupIdBase++);\n\t            zrUtil.each(charts, function (chart) {\n\t                chart.group = groupId;\n\t            });\n\t        }\n\t        connectedGroups[groupId] = true;\n\t        return groupId;\n\t    };\n\t\n\t    /**\n\t     * @return {string} groupId\n\t     */\n\t    echarts.disConnect = function (groupId) {\n\t        connectedGroups[groupId] = false;\n\t    };\n\t\n\t    /**\n\t     * Dispose a chart instance\n\t     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n\t     */\n\t    echarts.dispose = function (chart) {\n\t        if (zrUtil.isDom(chart)) {\n\t            chart = echarts.getInstanceByDom(chart);\n\t        }\n\t        else if (typeof chart === 'string') {\n\t            chart = instances[chart];\n\t        }\n\t        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n\t            chart.dispose();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {HTMLDomElement} dom\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceByDom = function (dom) {\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n\t        return instances[key];\n\t    };\n\t    /**\n\t     * @param {string} key\n\t     * @return {echarts~ECharts}\n\t     */\n\t    echarts.getInstanceById = function (key) {\n\t        return instances[key];\n\t    };\n\t\n\t    /**\n\t     * Register theme\n\t     */\n\t    echarts.registerTheme = function (name, theme) {\n\t        themeStorage[name] = theme;\n\t    };\n\t\n\t    /**\n\t     * Register option preprocessor\n\t     * @param {Function} preprocessorFunc\n\t     */\n\t    echarts.registerPreprocessor = function (preprocessorFunc) {\n\t        optionPreprocessorFuncs.push(preprocessorFunc);\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} processorFunc\n\t     */\n\t    echarts.registerProcessor = function (priority, processorFunc) {\n\t        if (typeof priority === 'function') {\n\t            processorFunc = priority;\n\t            priority = PRIORITY_PROCESSOR_FILTER;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown processor priority');\n\t            }\n\t        }\n\t        dataProcessorFuncs.push({\n\t            prio: priority,\n\t            func: processorFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Usage:\n\t     * registerAction('someAction', 'someEvent', function () { ... });\n\t     * registerAction('someAction', function () { ... });\n\t     * registerAction(\n\t     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n\t     *     function () { ... }\n\t     * );\n\t     *\n\t     * @param {(string|Object)} actionInfo\n\t     * @param {string} actionInfo.type\n\t     * @param {string} [actionInfo.event]\n\t     * @param {string} [actionInfo.update]\n\t     * @param {string} [eventName]\n\t     * @param {Function} action\n\t     */\n\t    echarts.registerAction = function (actionInfo, eventName, action) {\n\t        if (typeof eventName === 'function') {\n\t            action = eventName;\n\t            eventName = '';\n\t        }\n\t        var actionType = zrUtil.isObject(actionInfo)\n\t            ? actionInfo.type\n\t            : ([actionInfo, actionInfo = {\n\t                event: eventName\n\t            }][0]);\n\t\n\t        // Event name is all lowercase\n\t        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n\t        eventName = actionInfo.event;\n\t\n\t        // Validate action type and event name.\n\t        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\t\n\t        if (!actions[actionType]) {\n\t            actions[actionType] = {action: action, actionInfo: actionInfo};\n\t        }\n\t        eventActionMap[eventName] = actionType;\n\t    };\n\t\n\t    /**\n\t     * @param {string} type\n\t     * @param {*} CoordinateSystem\n\t     */\n\t    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n\t        CoordinateSystemManager.register(type, CoordinateSystem);\n\t    };\n\t\n\t    /**\n\t     * Layout is a special stage of visual encoding\n\t     * Most visual encoding like color are common for different chart\n\t     * But each chart has it's own layout algorithm\n\t     *\n\t     * @param {number} [priority=1000]\n\t     * @param {Function} layoutFunc\n\t     */\n\t    echarts.registerLayout = function (priority, layoutFunc) {\n\t        if (typeof priority === 'function') {\n\t            layoutFunc = priority;\n\t            priority = PRIORITY_VISUAL_LAYOUT;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown layout priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: layoutFunc,\n\t            isLayout: true\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {number} [priority=3000]\n\t     * @param {Function} visualFunc\n\t     */\n\t    echarts.registerVisual = function (priority, visualFunc) {\n\t        if (typeof priority === 'function') {\n\t            visualFunc = priority;\n\t            priority = PRIORITY_VISUAL_CHART;\n\t        }\n\t        if (__DEV__) {\n\t            if (isNaN(priority)) {\n\t                throw new Error('Unkown visual priority');\n\t            }\n\t        }\n\t        visualFuncs.push({\n\t            prio: priority,\n\t            func: visualFunc\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @param {string} name\n\t     */\n\t    echarts.registerLoading = function (name, loadingFx) {\n\t        loadingEffects[name] = loadingFx;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentModel = function (opts/*, superClass*/) {\n\t        // var Clazz = ComponentModel;\n\t        // if (superClass) {\n\t        //     var classType = parseClassType(superClass);\n\t        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        // }\n\t        return ComponentModel.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendComponentView = function (opts/*, superClass*/) {\n\t        // var Clazz = ComponentView;\n\t        // if (superClass) {\n\t        //     var classType = parseClassType(superClass);\n\t        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n\t        // }\n\t        return ComponentView.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n\t        // var Clazz = SeriesModel;\n\t        // if (superClass) {\n\t        //     superClass = 'series.' + superClass.replace('series.', '');\n\t        //     var classType = parseClassType(superClass);\n\t        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n\t        // }\n\t        return SeriesModel.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * @param {Object} opts\n\t     * @param {string} [superClass]\n\t     */\n\t    echarts.extendChartView = function (opts/*, superClass*/) {\n\t        // var Clazz = ChartView;\n\t        // if (superClass) {\n\t        //     superClass = superClass.replace('series.', '');\n\t        //     var classType = parseClassType(superClass);\n\t        //     Clazz = ChartView.getClass(classType.main, true);\n\t        // }\n\t        return ChartView.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * ZRender need a canvas context to do measureText.\n\t     * But in node environment canvas may be created by node-canvas.\n\t     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n\t     *\n\t     * Be careful of using it in the browser.\n\t     *\n\t     * @param {Function} creator\n\t     * @example\n\t     *     var Canvas = require('canvas');\n\t     *     var echarts = require('echarts');\n\t     *     echarts.setCanvasCreator(function () {\n\t     *         // Small size is enough.\n\t     *         return new Canvas(32, 32);\n\t     *     });\n\t     */\n\t    echarts.setCanvasCreator = function (creator) {\n\t        zrUtil.createCanvas = creator;\n\t    };\n\t\n\t    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(200));\n\t    echarts.registerPreprocessor(__webpack_require__(190));\n\t    echarts.registerLoading('default', __webpack_require__(181));\n\t\n\t    // Default action\n\t    echarts.registerAction({\n\t        type: 'highlight',\n\t        event: 'highlight',\n\t        update: 'highlight'\n\t    }, zrUtil.noop);\n\t    echarts.registerAction({\n\t        type: 'downplay',\n\t        event: 'downplay',\n\t        update: 'downplay'\n\t    }, zrUtil.noop);\n\t\n\t\n\t    // --------\n\t    // Exports\n\t    // --------\n\t    //\n\t    echarts.List = __webpack_require__(56);\n\t    echarts.Model = __webpack_require__(12);\n\t\n\t    echarts.graphic = __webpack_require__(3);\n\t    echarts.number = __webpack_require__(4);\n\t    echarts.format = __webpack_require__(9);\n\t    echarts.throttle = throttle.throttle;\n\t    echarts.matrix = __webpack_require__(27);\n\t    echarts.vector = __webpack_require__(5);\n\t    echarts.color = __webpack_require__(29);\n\t\n\t    echarts.util = {};\n\t    each([\n\t            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n\t            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n\t            'extend', 'defaults', 'clone'\n\t        ],\n\t        function (name) {\n\t            echarts.util[name] = zrUtil[name];\n\t        }\n\t    );\n\t\n\t    // PRIORITY\n\t    echarts.PRIORITY = {\n\t        PROCESSOR: {\n\t            FILTER: PRIORITY_PROCESSOR_FILTER,\n\t            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n\t        },\n\t        VISUAL: {\n\t            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n\t            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n\t            CHART: PRIORITY_VISUAL_CHART,\n\t            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n\t            BRUSH: PRIORITY_VISUAL_BRUSH\n\t        }\n\t    };\n\t\n\t    module.exports = echarts;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var pathTool = __webpack_require__(238);\n\t    var round = Math.round;\n\t    var Path = __webpack_require__(6);\n\t    var colorTool = __webpack_require__(29);\n\t    var matrix = __webpack_require__(27);\n\t    var vector = __webpack_require__(5);\n\t\n\t    var graphic = {};\n\t\n\t    graphic.Group = __webpack_require__(37);\n\t\n\t    graphic.Image = __webpack_require__(93);\n\t\n\t    graphic.Text = __webpack_require__(221);\n\t\n\t    graphic.Circle = __webpack_require__(228);\n\t\n\t    graphic.Sector = __webpack_require__(234);\n\t\n\t    graphic.Ring = __webpack_require__(233);\n\t\n\t    graphic.Polygon = __webpack_require__(230);\n\t\n\t    graphic.Polyline = __webpack_require__(231);\n\t\n\t    graphic.Rect = __webpack_require__(232);\n\t\n\t    graphic.Line = __webpack_require__(229);\n\t\n\t    graphic.BezierCurve = __webpack_require__(227);\n\t\n\t    graphic.Arc = __webpack_require__(226);\n\t\n\t    graphic.CompoundPath = __webpack_require__(218);\n\t\n\t    graphic.LinearGradient = __webpack_require__(219);\n\t\n\t    graphic.RadialGradient = __webpack_require__(220);\n\t\n\t    graphic.BoundingRect = __webpack_require__(14);\n\t\n\t    /**\n\t     * Extend shape with parameters\n\t     */\n\t    graphic.extendShape = function (opts) {\n\t        return Path.extend(opts);\n\t    };\n\t\n\t    /**\n\t     * Extend path\n\t     */\n\t    graphic.extendPath = function (pathData, opts) {\n\t        return pathTool.extendFromString(pathData, opts);\n\t    };\n\t\n\t    /**\n\t     * Create a path element from path data string\n\t     * @param {string} pathData\n\t     * @param {Object} opts\n\t     * @param {module:zrender/core/BoundingRect} rect\n\t     * @param {string} [layout=cover] 'center' or 'cover'\n\t     */\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\n\t        var path = pathTool.createFromString(pathData, opts);\n\t        var boundingRect = path.getBoundingRect();\n\t        if (rect) {\n\t            var aspect = boundingRect.width / boundingRect.height;\n\t\n\t            if (layout === 'center') {\n\t                // Set rect to center, keep width / height ratio.\n\t                var width = rect.height * aspect;\n\t                var height;\n\t                if (width <= rect.width) {\n\t                    height = rect.height;\n\t                }\n\t                else {\n\t                    width = rect.width;\n\t                    height = width / aspect;\n\t                }\n\t                var cx = rect.x + rect.width / 2;\n\t                var cy = rect.y + rect.height / 2;\n\t\n\t                rect.x = cx - width / 2;\n\t                rect.y = cy - height / 2;\n\t                rect.width = width;\n\t                rect.height = height;\n\t            }\n\t\n\t            graphic.resizePath(path, rect);\n\t        }\n\t        return path;\n\t    };\n\t\n\t    graphic.mergePath = pathTool.mergePath,\n\t\n\t    /**\n\t     * Resize a path to fit the rect\n\t     * @param {module:zrender/graphic/Path} path\n\t     * @param {Object} rect\n\t     */\n\t    graphic.resizePath = function (path, rect) {\n\t        if (!path.applyTransform) {\n\t            return;\n\t        }\n\t\n\t        var pathRect = path.getBoundingRect();\n\t\n\t        var m = pathRect.calculateTransform(rect);\n\t\n\t        path.applyTransform(m);\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize line for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x1]\n\t     * @param {number} [param.shape.y1]\n\t     * @param {number} [param.shape.x2]\n\t     * @param {number} [param.shape.y2]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeLine = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n\t        }\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n\t        }\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize rect for canvas\n\t     *\n\t     * @param {Object} param\n\t     * @param {Object} [param.shape]\n\t     * @param {number} [param.shape.x]\n\t     * @param {number} [param.shape.y]\n\t     * @param {number} [param.shape.width]\n\t     * @param {number} [param.shape.height]\n\t     * @param {Object} [param.style]\n\t     * @param {number} [param.style.lineWidth]\n\t     * @return {Object} Modified param\n\t     */\n\t    graphic.subPixelOptimizeRect = function (param) {\n\t        var subPixelOptimize = graphic.subPixelOptimize;\n\t        var shape = param.shape;\n\t        var lineWidth = param.style.lineWidth;\n\t        var originX = shape.x;\n\t        var originY = shape.y;\n\t        var originWidth = shape.width;\n\t        var originHeight = shape.height;\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n\t        shape.width = Math.max(\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n\t            originWidth === 0 ? 0 : 1\n\t        );\n\t        shape.height = Math.max(\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n\t            originHeight === 0 ? 0 : 1\n\t        );\n\t        return param;\n\t    };\n\t\n\t    /**\n\t     * Sub pixel optimize for canvas\n\t     *\n\t     * @param {number} position Coordinate, such as x, y\n\t     * @param {number} lineWidth Should be nonnegative integer.\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\n\t     * @return {number} Optimized position.\n\t     */\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\n\t        // otherwise line will be fuzzy in canvas.\n\t        var doubledPosition = round(position * 2);\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\n\t            ? doubledPosition / 2\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n\t    };\n\t\n\t    function hasFillOrStroke(fillOrStroke) {\n\t        return fillOrStroke != null && fillOrStroke != 'none';\n\t    }\n\t\n\t    function liftColor(color) {\n\t        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function cacheElementStl(el) {\n\t        if (el.__hoverStlDirty) {\n\t            var stroke = el.style.stroke;\n\t            var fill = el.style.fill;\n\t\n\t            // Create hoverStyle on mouseover\n\t            var hoverStyle = el.__hoverStl;\n\t            hoverStyle.fill = hoverStyle.fill\n\t                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n\t            hoverStyle.stroke = hoverStyle.stroke\n\t                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\t\n\t            var normalStyle = {};\n\t            for (var name in hoverStyle) {\n\t                if (hoverStyle.hasOwnProperty(name)) {\n\t                    normalStyle[name] = el.style[name];\n\t                }\n\t            }\n\t\n\t            el.__normalStl = normalStyle;\n\t\n\t            el.__hoverStlDirty = false;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    function doSingleEnterHover(el) {\n\t        if (el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        cacheElementStl(el);\n\t\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n\t        }\n\t        else {\n\t            el.setStyle(el.__hoverStl);\n\t            el.z2 += 1;\n\t        }\n\t\n\t        el.__isHover = true;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doSingleLeaveHover(el) {\n\t        if (!el.__isHover) {\n\t            return;\n\t        }\n\t\n\t        var normalStl = el.__normalStl;\n\t        if (el.useHoverLayer) {\n\t            el.__zr && el.__zr.removeHover(el);\n\t        }\n\t        else {\n\t            normalStl && el.setStyle(normalStl);\n\t            el.z2 -= 1;\n\t        }\n\t\n\t        el.__isHover = false;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function doEnterHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleEnterHover(child);\n\t                }\n\t            })\n\t            : doSingleEnterHover(el);\n\t    }\n\t\n\t    function doLeaveHover(el) {\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    doSingleLeaveHover(child);\n\t                }\n\t            })\n\t            : doSingleLeaveHover(el);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function setElementHoverStl(el, hoverStl) {\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n\t        // Often used when item group has a label element and it's hoverStyle is different\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\n\t        el.__hoverStlDirty = true;\n\t\n\t        if (el.__isHover) {\n\t            cacheElementStl(el);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOver(e) {\n\t        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n\t            return;\n\t        }\n\t\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function onElementMouseOut(e) {\n\t        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n\t            return;\n\t        }\n\t\n\t        // Only if element is not in emphasis status\n\t        !this.__isEmphasis && doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function enterEmphasis() {\n\t        this.__isEmphasis = true;\n\t        doEnterHover(this);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function leaveEmphasis() {\n\t        this.__isEmphasis = false;\n\t        doLeaveHover(this);\n\t    }\n\t\n\t    /**\n\t     * Set hover style of element\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} [hoverStyle]\n\t     * @param {Object} [opt]\n\t     * @param {boolean} [opt.hoverSilentOnTouch=false]\n\t     *        In touch device, mouseover event will be trigger on touchstart event\n\t     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n\t     *        conviniently use hoverStyle when tap on touch screen without additional\n\t     *        code for compatibility.\n\t     *        But if the chart/component has select feature, which usually also use\n\t     *        hoverStyle, there might be conflict between 'select-highlight' and\n\t     *        'hover-highlight' especially when roam is enabled (see geo for example).\n\t     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n\t     *        on touch device.\n\t     */\n\t    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n\t        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\t\n\t        el.type === 'group'\n\t            ? el.traverse(function (child) {\n\t                if (child.type !== 'group') {\n\t                    setElementHoverStl(child, hoverStyle);\n\t                }\n\t            })\n\t            : setElementHoverStl(el, hoverStyle);\n\t\n\t        // Duplicated function will be auto-ignored, see Eventful.js.\n\t        el.on('mouseover', onElementMouseOver)\n\t          .on('mouseout', onElementMouseOut);\n\t\n\t        // Emphasis, normal can be triggered manually\n\t        el.on('emphasis', enterEmphasis)\n\t          .on('normal', leaveEmphasis);\n\t    };\n\t\n\t    /**\n\t     * Set text option in the style\n\t     * @param {Object} textStyle\n\t     * @param {module:echarts/model/Model} labelModel\n\t     * @param {string} color\n\t     */\n\t    graphic.setText = function (textStyle, labelModel, color) {\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\n\t        var labelOffset = labelModel.getShallow('offset');\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        zrUtil.extend(textStyle, {\n\t            textDistance: labelModel.getShallow('distance') || 5,\n\t            textFont: textStyleModel.getFont(),\n\t            textPosition: labelPosition,\n\t            textOffset: labelOffset,\n\t            textFill: textStyleModel.getTextColor() || labelColor\n\t        });\n\t    };\n\t\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n\t        if (typeof dataIndex === 'function') {\n\t            cb = dataIndex;\n\t            dataIndex = null;\n\t        }\n\t        // Do not check 'animation' property directly here. Consider this case:\n\t        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n\t        // but its parent model (`seriesModel`) does.\n\t        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\t\n\t        if (animationEnabled) {\n\t            var postfix = isUpdate ? 'Update' : '';\n\t            var duration = animatableModel.getShallow('animationDuration' + postfix);\n\t            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n\t            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n\t            if (typeof animationDelay === 'function') {\n\t                animationDelay = animationDelay(\n\t                    dataIndex,\n\t                    animatableModel.getAnimationDelayParams\n\t                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n\t                        : null\n\t                );\n\t            }\n\t            if (typeof duration === 'function') {\n\t                duration = duration(dataIndex);\n\t            }\n\t\n\t            duration > 0\n\t                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n\t                : (el.attr(props), cb && cb());\n\t        }\n\t        else {\n\t            el.attr(props);\n\t            cb && cb();\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Update graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} [cb]\n\t     * @example\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n\t     *     // Or\n\t     *     graphic.updateProps(el, {\n\t     *         position: [100, 100]\n\t     *     }, seriesModel, function () { console.log('Animation done!'); });\n\t     */\n\t    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Init graphic element properties with or without animation according to the configuration in series\n\t     * @param {module:zrender/Element} el\n\t     * @param {Object} props\n\t     * @param {module:echarts/model/Model} [animatableModel]\n\t     * @param {number} [dataIndex]\n\t     * @param {Function} cb\n\t     */\n\t    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n\t        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n\t    };\n\t\n\t    /**\n\t     * Get transform matrix of target (param target),\n\t     * in coordinate of its ancestor (param ancestor)\n\t     *\n\t     * @param {module:zrender/mixin/Transformable} target\n\t     * @param {module:zrender/mixin/Transformable} [ancestor]\n\t     */\n\t    graphic.getTransform = function (target, ancestor) {\n\t        var mat = matrix.identity([]);\n\t\n\t        while (target && target !== ancestor) {\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\n\t            target = target.parent;\n\t        }\n\t\n\t        return mat;\n\t    };\n\t\n\t    /**\n\t     * Apply transform to an vertex.\n\t     * @param {Array.<number>} vertex [x, y]\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {Array.<number>} [x, y]\n\t     */\n\t    graphic.applyTransform = function (vertex, transform, invert) {\n\t        if (invert) {\n\t            transform = matrix.invert([], transform);\n\t        }\n\t        return vector.applyTransform([], vertex, transform);\n\t    };\n\t\n\t    /**\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n\t     * @param {boolean=} invert Whether use invert matrix.\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n\t     */\n\t    graphic.transformDirection = function (direction, transform, invert) {\n\t\n\t        // Pick a base, ensure that transform result will not be (0, 0).\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\t\n\t        var vertex = [\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n\t        ];\n\t\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\n\t\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\n\t    };\n\t\n\t    /**\n\t     * Apply group transition animation from g1 to g2\n\t     */\n\t    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n\t        if (!g1 || !g2) {\n\t            return;\n\t        }\n\t\n\t        function getElMap(g) {\n\t            var elMap = {};\n\t            g.traverse(function (el) {\n\t                if (!el.isGroup && el.anid) {\n\t                    elMap[el.anid] = el;\n\t                }\n\t            });\n\t            return elMap;\n\t        }\n\t        function getAnimatableProps(el) {\n\t            var obj = {\n\t                position: vector.clone(el.position),\n\t                rotation: el.rotation\n\t            };\n\t            if (el.shape) {\n\t                obj.shape = zrUtil.extend({}, el.shape);\n\t            }\n\t            return obj;\n\t        }\n\t        var elMap1 = getElMap(g1);\n\t\n\t        g2.traverse(function (el) {\n\t            if (!el.isGroup && el.anid) {\n\t                var oldEl = elMap1[el.anid];\n\t                if (oldEl) {\n\t                    var newProp = getAnimatableProps(el);\n\t                    el.attr(getAnimatableProps(oldEl));\n\t                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n\t                }\n\t                // else {\n\t                //     if (el.previousProps) {\n\t                //         graphic.updateProps\n\t                //     }\n\t                // }\n\t            }\n\t        });\n\t    };\n\t\n\t    module.exports = graphic;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module echarts/util/number\n\t */\n\t\n\t\n\t\n\t    var number = {};\n\t\n\t    var RADIAN_EPSILON = 1e-4;\n\t\n\t    function _trim(str) {\n\t        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n\t    }\n\t\n\t    /**\n\t     * Linear mapping a value from domain to range\n\t     * @memberOf module:echarts/util/number\n\t     * @param  {(number|Array.<number>)} val\n\t     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n\t     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n\t     * @param  {boolean} clamp\n\t     * @return {(number|Array.<number>}\n\t     */\n\t    number.linearMap = function (val, domain, range, clamp) {\n\t        var subDomain = domain[1] - domain[0];\n\t        var subRange = range[1] - range[0];\n\t\n\t        if (subDomain === 0) {\n\t            return subRange === 0\n\t                ? range[0]\n\t                : (range[0] + range[1]) / 2;\n\t        }\n\t\n\t        // Avoid accuracy problem in edge, such as\n\t        // 146.39 - 62.83 === 83.55999999999999.\n\t        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n\t        // It is a little verbose for efficiency considering this method\n\t        // is a hotspot.\n\t        if (clamp) {\n\t            if (subDomain > 0) {\n\t                if (val <= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val >= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t            else {\n\t                if (val >= domain[0]) {\n\t                    return range[0];\n\t                }\n\t                else if (val <= domain[1]) {\n\t                    return range[1];\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (val === domain[0]) {\n\t                return range[0];\n\t            }\n\t            if (val === domain[1]) {\n\t                return range[1];\n\t            }\n\t        }\n\t\n\t        return (val - domain[0]) / subDomain * subRange + range[0];\n\t    };\n\t\n\t    /**\n\t     * Convert a percent string to absolute number.\n\t     * Returns NaN if percent is not a valid string or number\n\t     * @memberOf module:echarts/util/number\n\t     * @param {string|number} percent\n\t     * @param {number} all\n\t     * @return {number}\n\t     */\n\t    number.parsePercent = function(percent, all) {\n\t        switch (percent) {\n\t            case 'center':\n\t            case 'middle':\n\t                percent = '50%';\n\t                break;\n\t            case 'left':\n\t            case 'top':\n\t                percent = '0%';\n\t                break;\n\t            case 'right':\n\t            case 'bottom':\n\t                percent = '100%';\n\t                break;\n\t        }\n\t        if (typeof percent === 'string') {\n\t            if (_trim(percent).match(/%$/)) {\n\t                return parseFloat(percent) / 100 * all;\n\t            }\n\t\n\t            return parseFloat(percent);\n\t        }\n\t\n\t        return percent == null ? NaN : +percent;\n\t    };\n\t\n\t    /**\n\t     * Fix rounding error of float numbers\n\t     * @param {number} x\n\t     * @return {number}\n\t     */\n\t    number.round = function (x, precision) {\n\t        if (precision == null) {\n\t            precision = 10;\n\t        }\n\t        // Avoid range error\n\t        precision = Math.min(Math.max(0, precision), 20);\n\t        return +(+x).toFixed(precision);\n\t    };\n\t\n\t    number.asc = function (arr) {\n\t        arr.sort(function (a, b) {\n\t            return a - b;\n\t        });\n\t        return arr;\n\t    };\n\t\n\t    /**\n\t     * Get precision\n\t     * @param {number} val\n\t     */\n\t    number.getPrecision = function (val) {\n\t        val = +val;\n\t        if (isNaN(val)) {\n\t            return 0;\n\t        }\n\t        // It is much faster than methods converting number to string as follows\n\t        //      var tmp = val.toString();\n\t        //      return tmp.length - 1 - tmp.indexOf('.');\n\t        // especially when precision is low\n\t        var e = 1;\n\t        var count = 0;\n\t        while (Math.round(val * e) / e !== val) {\n\t            e *= 10;\n\t            count++;\n\t        }\n\t        return count;\n\t    };\n\t\n\t    number.getPrecisionSafe = function (val) {\n\t        var str = val.toString();\n\t        var dotIndex = str.indexOf('.');\n\t        if (dotIndex < 0) {\n\t            return 0;\n\t        }\n\t        return str.length - 1 - dotIndex;\n\t    };\n\t\n\t    /**\n\t     * Minimal dicernible data precisioin according to a single pixel.\n\t     * @param {Array.<number>} dataExtent\n\t     * @param {Array.<number>} pixelExtent\n\t     * @return {number} precision\n\t     */\n\t    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n\t        var log = Math.log;\n\t        var LN10 = Math.LN10;\n\t        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n\t        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n\t        // toFixed() digits argument must be between 0 and 20.\n\t        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n\t        return !isFinite(precision) ? 20 : precision;\n\t    };\n\t\n\t    // Number.MAX_SAFE_INTEGER, ie do not support.\n\t    number.MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t    /**\n\t     * To 0 - 2 * PI, considering negative radian.\n\t     * @param {number} radian\n\t     * @return {number}\n\t     */\n\t    number.remRadian = function (radian) {\n\t        var pi2 = Math.PI * 2;\n\t        return (radian % pi2 + pi2) % pi2;\n\t    };\n\t\n\t    /**\n\t     * @param {type} radian\n\t     * @return {boolean}\n\t     */\n\t    number.isRadianAroundZero = function (val) {\n\t        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Date|number} value\n\t     * @return {Date} date\n\t     */\n\t    number.parseDate = function (value) {\n\t        if (value instanceof Date) {\n\t            return value;\n\t        }\n\t        else if (typeof value === 'string') {\n\t            // Treat as ISO format. See issue #3623\n\t            var ret = new Date(value);\n\t            if (isNaN(+ret)) {\n\t                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n\t                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n\t            }\n\t            return ret;\n\t        }\n\t\n\t        return new Date(Math.round(value));\n\t    };\n\t\n\t    /**\n\t     * Quantity of a number. e.g. 0.1, 1, 10, 100\n\t     * @param  {number} val\n\t     * @return {number}\n\t     */\n\t    number.quantity = function (val) {\n\t        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n\t    };\n\t\n\t    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t    /**\n\t     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n\t     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n\t     * @param  {number} val\n\t     * @param  {boolean} round\n\t     * @return {number}\n\t     */\n\t    number.nice = function (val, round) {\n\t        var exp10 = number.quantity(val);\n\t        var f = val / exp10; // between 1 and 10\n\t        var nf;\n\t        if (round) {\n\t            if (f < 1.5) { nf = 1; }\n\t            else if (f < 2.5) { nf = 2; }\n\t            else if (f < 4) { nf = 3; }\n\t            else if (f < 7) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        else {\n\t            if (f < 1) { nf = 1; }\n\t            else if (f < 2) { nf = 2; }\n\t            else if (f < 3) { nf = 3; }\n\t            else if (f < 5) { nf = 5; }\n\t            else { nf = 10; }\n\t        }\n\t        return nf * exp10;\n\t    };\n\t\n\t    /**\n\t     * Order intervals asc, and split them when overlap.\n\t     * expect(numberUtil.reformIntervals([\n\t     *     {interval: [18, 62], close: [1, 1]},\n\t     *     {interval: [-Infinity, -70], close: [0, 0]},\n\t     *     {interval: [-70, -26], close: [1, 1]},\n\t     *     {interval: [-26, 18], close: [1, 1]},\n\t     *     {interval: [62, 150], close: [1, 1]},\n\t     *     {interval: [106, 150], close: [1, 1]},\n\t     *     {interval: [150, Infinity], close: [0, 0]}\n\t     * ])).toEqual([\n\t     *     {interval: [-Infinity, -70], close: [0, 0]},\n\t     *     {interval: [-70, -26], close: [1, 1]},\n\t     *     {interval: [-26, 18], close: [0, 1]},\n\t     *     {interval: [18, 62], close: [0, 1]},\n\t     *     {interval: [62, 150], close: [0, 1]},\n\t     *     {interval: [150, Infinity], close: [0, 0]}\n\t     * ]);\n\t     * @param {Array.<Object>} list, where `close` mean open or close\n\t     *        of the interval, and Infinity can be used.\n\t     * @return {Array.<Object>} The origin list, which has been reformed.\n\t     */\n\t    number.reformIntervals = function (list) {\n\t        list.sort(function (a, b) {\n\t            return littleThan(a, b, 0) ? -1 : 1;\n\t        });\n\t\n\t        var curr = -Infinity;\n\t        var currClose = 1;\n\t        for (var i = 0; i < list.length;) {\n\t            var interval = list[i].interval;\n\t            var close = list[i].close;\n\t\n\t            for (var lg = 0; lg < 2; lg++) {\n\t                if (interval[lg] <= curr) {\n\t                    interval[lg] = curr;\n\t                    close[lg] = !lg ? 1 - currClose : 1;\n\t                }\n\t                curr = interval[lg];\n\t                currClose = close[lg];\n\t            }\n\t\n\t            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n\t                list.splice(i, 1);\n\t            }\n\t            else {\n\t                i++;\n\t            }\n\t        }\n\t\n\t        return list;\n\t\n\t        function littleThan(a, b, lg) {\n\t            return a.interval[lg] < b.interval[lg]\n\t                || (\n\t                    a.interval[lg] === b.interval[lg]\n\t                    && (\n\t                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n\t                        || (!lg && littleThan(a, b, 1))\n\t                    )\n\t                );\n\t        }\n\t    };\n\t\n\t    /**\n\t     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t     * subtraction forces infinities to NaN\n\t     * @param {*} v\n\t     * @return {boolean}\n\t     */\n\t    number.isNumeric = function (v) {\n\t        return v - parseFloat(v) >= 0;\n\t    };\n\t\n\t    module.exports = number;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * \n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * \n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} \n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(60);\n\t    var zrUtil = __webpack_require__(1);\n\t    var PathProxy = __webpack_require__(38);\n\t    var pathContain = __webpack_require__(211);\n\t\n\t    var Pattern = __webpack_require__(94);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        if (key.hasOwnProperty(name)) {\n\t                            shape[name] = key[name];\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Path element, \n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME  extend position, rotation \n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(72)('wks')\n\t  , uid        = __webpack_require__(75)\n\t  , Symbol     = __webpack_require__(8).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var numberUtil = __webpack_require__(4);\n\t    var textContain = __webpack_require__(21);\n\t\n\t    var formatUtil = {};\n\t    /**\n\t     * ,\n\t     * @type {string|number} x\n\t     */\n\t    formatUtil.addCommas = function (x) {\n\t        if (isNaN(x)) {\n\t            return '-';\n\t        }\n\t        x = (x + '').split('.');\n\t        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n\t               + (x.length > 1 ? ('.' + x[1]) : '');\n\t    };\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @param {boolean} [upperCaseFirst=false]\n\t     * @return {string} str\n\t     */\n\t    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n\t        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n\t            return group1.toUpperCase();\n\t        });\n\t\n\t        if (upperCaseFirst && str) {\n\t            str = str.charAt(0).toUpperCase() + str.slice(1);\n\t        }\n\t\n\t        return str;\n\t    };\n\t\n\t    /**\n\t     * Normalize css liked array configuration\n\t     * e.g.\n\t     *  3 => [3, 3, 3, 3]\n\t     *  [4, 2] => [4, 2, 4, 2]\n\t     *  [4, 3, 2] => [4, 3, 2, 3]\n\t     * @param {number|Array.<number>} val\n\t     */\n\t    formatUtil.normalizeCssArray = function (val) {\n\t        var len = val.length;\n\t        if (typeof (val) === 'number') {\n\t            return [val, val, val, val];\n\t        }\n\t        else if (len === 2) {\n\t            // vertical | horizontal\n\t            return [val[0], val[1], val[0], val[1]];\n\t        }\n\t        else if (len === 3) {\n\t            // top | horizontal | bottom\n\t            return [val[0], val[1], val[2], val[1]];\n\t        }\n\t        return val;\n\t    };\n\t\n\t    var encodeHTML = formatUtil.encodeHTML = function (source) {\n\t        return String(source)\n\t            .replace(/&/g, '&amp;')\n\t            .replace(/</g, '&lt;')\n\t            .replace(/>/g, '&gt;')\n\t            .replace(/\"/g, '&quot;')\n\t            .replace(/'/g, '&#39;');\n\t    };\n\t\n\t    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\t\n\t    var wrapVar = function (varName, seriesIdx) {\n\t        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n\t    };\n\t\n\t    /**\n\t     * Template formatter\n\t     * @param {string} tpl\n\t     * @param {Array.<Object>|Object} paramsList\n\t     * @param {boolean} [encode=false]\n\t     * @return {string}\n\t     */\n\t    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n\t        if (!zrUtil.isArray(paramsList)) {\n\t            paramsList = [paramsList];\n\t        }\n\t        var seriesLen = paramsList.length;\n\t        if (!seriesLen) {\n\t            return '';\n\t        }\n\t\n\t        var $vars = paramsList[0].$vars || [];\n\t        for (var i = 0; i < $vars.length; i++) {\n\t            var alias = TPL_VAR_ALIAS[i];\n\t            var val = wrapVar(alias, 0);\n\t            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n\t        }\n\t        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n\t            for (var k = 0; k < $vars.length; k++) {\n\t                var val = paramsList[seriesIdx][$vars[k]];\n\t                tpl = tpl.replace(\n\t                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n\t                    encode ? encodeHTML(val) : val\n\t                );\n\t            }\n\t        }\n\t\n\t        return tpl;\n\t    };\n\t\n\t\n\t    /**\n\t     * @param {string} str\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    var s2d = function (str) {\n\t        return str < 10 ? ('0' + str) : str;\n\t    };\n\t\n\t    /**\n\t     * ISO Date format\n\t     * @param {string} tpl\n\t     * @param {number} value\n\t     * @inner\n\t     */\n\t    formatUtil.formatTime = function (tpl, value) {\n\t        if (tpl === 'week'\n\t            || tpl === 'month'\n\t            || tpl === 'quarter'\n\t            || tpl === 'half-year'\n\t            || tpl === 'year'\n\t        ) {\n\t            tpl = 'MM-dd\\nyyyy';\n\t        }\n\t\n\t        var date = numberUtil.parseDate(value);\n\t        var y = date.getFullYear();\n\t        var M = date.getMonth() + 1;\n\t        var d = date.getDate();\n\t        var h = date.getHours();\n\t        var m = date.getMinutes();\n\t        var s = date.getSeconds();\n\t\n\t        tpl = tpl.replace('MM', s2d(M))\n\t            .toLowerCase()\n\t            .replace('yyyy', y)\n\t            .replace('yy', y % 100)\n\t            .replace('dd', s2d(d))\n\t            .replace('d', d)\n\t            .replace('hh', s2d(h))\n\t            .replace('h', h)\n\t            .replace('mm', s2d(m))\n\t            .replace('m', m)\n\t            .replace('ss', s2d(s))\n\t            .replace('s', s);\n\t\n\t        return tpl;\n\t    };\n\t\n\t    /**\n\t     * Capital first\n\t     * @param {string} str\n\t     * @return {string}\n\t     */\n\t    formatUtil.capitalFirst = function (str) {\n\t        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n\t    };\n\t\n\t    formatUtil.truncateText = textContain.truncateText;\n\t\n\t    module.exports = formatUtil;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts\n\t *\n\t * @desc echartsCanvasJavascript\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        var weChat = (/micromessenger/i).test(ua);\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) {\n\t            browser.firefox = true;\n\t            browser.version = firefox[1];\n\t        }\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n\t        // not be set on win phone. So we do not consider Win Phone.\n\t        if (weChat) {\n\t            browser.weChat = true;\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // canvas\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n\t                // events currently. So we dont use that on other browsers unless tested sufficiently.\n\t                // Although IE 10 supports pointer event, it use old style and is different from the\n\t                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n\t                && (browser.edge || (browser.ie && browser.version >= 11))\n\t        };\n\t    }\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function normalizeComponent (\n\t  rawScriptExports,\n\t  compiledTemplate,\n\t  scopeId,\n\t  cssModules\n\t) {\n\t  var esModule\n\t  var scriptExports = rawScriptExports = rawScriptExports || {}\n\t\n\t  // ES6 modules interop\n\t  var type = typeof rawScriptExports.default\n\t  if (type === 'object' || type === 'function') {\n\t    esModule = rawScriptExports\n\t    scriptExports = rawScriptExports.default\n\t  }\n\t\n\t  // Vue.extend constructor export interop\n\t  var options = typeof scriptExports === 'function'\n\t    ? scriptExports.options\n\t    : scriptExports\n\t\n\t  // render functions\n\t  if (compiledTemplate) {\n\t    options.render = compiledTemplate.render\n\t    options.staticRenderFns = compiledTemplate.staticRenderFns\n\t  }\n\t\n\t  // scopedId\n\t  if (scopeId) {\n\t    options._scopeId = scopeId\n\t  }\n\t\n\t  // inject cssModules\n\t  if (cssModules) {\n\t    var computed = options.computed || (options.computed = {})\n\t    Object.keys(cssModules).forEach(function (key) {\n\t      var module = cssModules[key]\n\t      computed[key] = function () { return module }\n\t    })\n\t  }\n\t\n\t  return {\n\t    esModule: esModule,\n\t    exports: scriptExports,\n\t    options: options\n\t  }\n\t}\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/model/Model\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var clazzUtil = __webpack_require__(15);\n\t    var env = __webpack_require__(10);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Model\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} [parentModel]\n\t     * @param {module:echarts/model/Global} [ecModel]\n\t     */\n\t    function Model(option, parentModel, ecModel) {\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         * @readOnly\n\t         */\n\t        this.parentModel = parentModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        this.ecModel = ecModel;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        this.option = option;\n\t\n\t        // Simple optimization\n\t        // if (this.init) {\n\t        //     if (arguments.length <= 4) {\n\t        //         this.init(option, parentModel, ecModel, extraOpt);\n\t        //     }\n\t        //     else {\n\t        //         this.init.apply(this, arguments);\n\t        //     }\n\t        // }\n\t    }\n\t\n\t    Model.prototype = {\n\t\n\t        constructor: Model,\n\t\n\t        /**\n\t         * Model \n\t         * @param {Object} option\n\t         */\n\t        init: null,\n\t\n\t        /**\n\t         *  Option merge\n\t         */\n\t        mergeOption: function (option) {\n\t            zrUtil.merge(this.option, option, true);\n\t        },\n\t\n\t        /**\n\t         * @param {string|Array.<string>} path\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        get: function (path, ignoreParent) {\n\t            if (path == null) {\n\t                return this.option;\n\t            }\n\t\n\t            return doGet(\n\t                this.option,\n\t                this.parsePath(path),\n\t                !ignoreParent && getParent(this, path)\n\t            );\n\t        },\n\t\n\t        /**\n\t         * @param {string} key\n\t         * @param {boolean} [ignoreParent=false]\n\t         * @return {*}\n\t         */\n\t        getShallow: function (key, ignoreParent) {\n\t            var option = this.option;\n\t\n\t            var val = option == null ? option : option[key];\n\t            var parentModel = !ignoreParent && getParent(this, key);\n\t            if (val == null && parentModel) {\n\t                val = parentModel.getShallow(key);\n\t            }\n\t            return val;\n\t        },\n\t\n\t        /**\n\t         * @param {string|Array.<string>} path\n\t         * @param {module:echarts/model/Model} [parentModel]\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getModel: function (path, parentModel) {\n\t            var obj = path == null\n\t                ? this.option\n\t                : doGet(this.option, path = this.parsePath(path));\n\t\n\t            var thisParentModel;\n\t            parentModel = parentModel || (\n\t                (thisParentModel = getParent(this, path))\n\t                    && thisParentModel.getModel(path)\n\t            );\n\t\n\t            return new Model(obj, parentModel, this.ecModel);\n\t        },\n\t\n\t        /**\n\t         * If model has option\n\t         */\n\t        isEmpty: function () {\n\t            return this.option == null;\n\t        },\n\t\n\t        restoreData: function () {},\n\t\n\t        // Pending\n\t        clone: function () {\n\t            var Ctor = this.constructor;\n\t            return new Ctor(zrUtil.clone(this.option));\n\t        },\n\t\n\t        setReadOnly: function (properties) {\n\t            clazzUtil.setReadOnly(this, properties);\n\t        },\n\t\n\t        // If path is null/undefined, return null/undefined.\n\t        parsePath: function(path) {\n\t            if (typeof path === 'string') {\n\t                path = path.split('.');\n\t            }\n\t            return path;\n\t        },\n\t\n\t        /**\n\t         * @param {Function} getParentMethod\n\t         *        param {Array.<string>|string} path\n\t         *        return {module:echarts/model/Model}\n\t         */\n\t        customizeGetParent: function (getParentMethod) {\n\t            clazzUtil.set(this, 'getParent', getParentMethod);\n\t        },\n\t\n\t        isAnimationEnabled: function () {\n\t            if (!env.node) {\n\t                if (this.option.animation != null) {\n\t                    return !!this.option.animation;\n\t                }\n\t                else if (this.parentModel) {\n\t                    return this.parentModel.isAnimationEnabled();\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function doGet(obj, pathArr, parentModel) {\n\t        for (var i = 0; i < pathArr.length; i++) {\n\t            // Ignore empty\n\t            if (!pathArr[i]) {\n\t                continue;\n\t            }\n\t            // obj could be number/string/... (like 0)\n\t            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        if (obj == null && parentModel) {\n\t            obj = parentModel.get(pathArr);\n\t        }\n\t        return obj;\n\t    }\n\t\n\t    function getParent(model, path) {\n\t        var getParentMethod = clazzUtil.get(model, 'getParent');\n\t        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n\t    }\n\t\n\t    // Enable Model.extend.\n\t    clazzUtil.enableClassExtend(Model);\n\t\n\t    var mixin = zrUtil.mixin;\n\t    mixin(Model, __webpack_require__(188));\n\t    mixin(Model, __webpack_require__(185));\n\t    mixin(Model, __webpack_require__(189));\n\t    mixin(Model, __webpack_require__(187));\n\t\n\t    module.exports = Model;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var formatUtil = __webpack_require__(9);\n\t    var nubmerUtil = __webpack_require__(4);\n\t    var Model = __webpack_require__(12);\n\t    var zrUtil = __webpack_require__(1);\n\t    var each = zrUtil.each;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var modelUtil = {};\n\t\n\t    /**\n\t     * If value is not array, then translate it to array.\n\t     * @param  {*} value\n\t     * @return {Array} [value] or value\n\t     */\n\t    modelUtil.normalizeToArray = function (value) {\n\t        return value instanceof Array\n\t            ? value\n\t            : value == null\n\t            ? []\n\t            : [value];\n\t    };\n\t\n\t    /**\n\t     * Sync default option between normal and emphasis like `position` and `show`\n\t     * In case some one will write code like\n\t     *     label: {\n\t     *         normal: {\n\t     *             show: false,\n\t     *             position: 'outside',\n\t     *             textStyle: {\n\t     *                 fontSize: 18\n\t     *             }\n\t     *         },\n\t     *         emphasis: {\n\t     *             show: true\n\t     *         }\n\t     *     }\n\t     * @param {Object} opt\n\t     * @param {Array.<string>} subOpts\n\t     */\n\t     modelUtil.defaultEmphasis = function (opt, subOpts) {\n\t        if (opt) {\n\t            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n\t            var normalOpt = opt.normal = opt.normal || {};\n\t\n\t            // Default emphasis option from normal\n\t            each(subOpts, function (subOptName) {\n\t                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n\t                if (val != null) {\n\t                    emphasisOpt[subOptName] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method retieves value from data.\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     * @return {number|string|Date|Array.<number|string|Date>}\n\t     */\n\t    modelUtil.getDataItemValue = function (dataItem) {\n\t        // Performance sensitive.\n\t        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\t    };\n\t\n\t    /**\n\t     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n\t     * This helper method determine if dataItem has extra option besides value\n\t     * @param {string|number|Date|Array|Object} dataItem\n\t     */\n\t    modelUtil.isDataItemOption = function (dataItem) {\n\t        return isObject(dataItem)\n\t            && !(dataItem instanceof Array);\n\t            // // markLine data can be array\n\t            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n\t    };\n\t\n\t    /**\n\t     * This helper method convert value in data.\n\t     * @param {string|number|Date} value\n\t     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n\t     */\n\t    modelUtil.converDataValue = function (value, dimInfo) {\n\t        // Performance sensitive.\n\t        var dimType = dimInfo && dimInfo.type;\n\t        if (dimType === 'ordinal') {\n\t            return value;\n\t        }\n\t\n\t        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n\t            value = +nubmerUtil.parseDate(value);\n\t        }\n\t\n\t        // dimType defaults 'number'.\n\t        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n\t        // parse to NaN.\n\t        return (value == null || value === '')\n\t            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n\t    };\n\t\n\t    /**\n\t     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} opt\n\t     * @param {string} [opt.seriesIndex]\n\t     * @param {Object} [opt.name]\n\t     * @param {Object} [opt.mainType]\n\t     * @param {Object} [opt.subType]\n\t     */\n\t    modelUtil.createDataFormatModel = function (data, opt) {\n\t        var model = new Model();\n\t        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n\t        model.seriesIndex = opt.seriesIndex;\n\t        model.name = opt.name || '';\n\t        model.mainType = opt.mainType;\n\t        model.subType = opt.subType;\n\t\n\t        model.getData = function () {\n\t            return data;\n\t        };\n\t        return model;\n\t    };\n\t\n\t    // PENDING A little ugly\n\t    modelUtil.dataFormatMixin = {\n\t        /**\n\t         * Get params for formatter\n\t         * @param {number} dataIndex\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getDataParams: function (dataIndex, dataType) {\n\t            var data = this.getData(dataType);\n\t\n\t            var seriesIndex = this.seriesIndex;\n\t            var seriesName = this.name;\n\t\n\t            var rawValue = this.getRawValue(dataIndex, dataType);\n\t            var rawDataIndex = data.getRawIndex(dataIndex);\n\t            var name = data.getName(dataIndex, true);\n\t            var itemOpt = data.getRawDataItem(dataIndex);\n\t\n\t            return {\n\t                componentType: this.mainType,\n\t                componentSubType: this.subType,\n\t                seriesType: this.mainType === 'series' ? this.subType : null,\n\t                seriesIndex: seriesIndex,\n\t                seriesName: seriesName,\n\t                name: name,\n\t                dataIndex: rawDataIndex,\n\t                data: itemOpt,\n\t                dataType: dataType,\n\t                value: rawValue,\n\t                color: data.getItemVisual(dataIndex, 'color'),\n\t\n\t                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n\t                $vars: ['seriesName', 'name', 'value']\n\t            };\n\t        },\n\t\n\t        /**\n\t         * Format label\n\t         * @param {number} dataIndex\n\t         * @param {string} [status='normal'] 'normal' or 'emphasis'\n\t         * @param {string} [dataType]\n\t         * @param {number} [dimIndex]\n\t         * @return {string}\n\t         */\n\t        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n\t            status = status || 'normal';\n\t            var data = this.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var params = this.getDataParams(dataIndex, dataType);\n\t            if (dimIndex != null && (params.value instanceof Array)) {\n\t                params.value = params.value[dimIndex];\n\t            }\n\t\n\t            var formatter = itemModel.get(['label', status, 'formatter']);\n\t\n\t            if (typeof formatter === 'function') {\n\t                params.status = status;\n\t                return formatter(params);\n\t            }\n\t            else if (typeof formatter === 'string') {\n\t                return formatUtil.formatTpl(formatter, params);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get raw value in option\n\t         * @param {number} idx\n\t         * @param {string} [dataType]\n\t         * @return {Object}\n\t         */\n\t        getRawValue: function (idx, dataType) {\n\t            var data = this.getData(dataType);\n\t            var dataItem = data.getRawDataItem(idx);\n\t            if (dataItem != null) {\n\t                return (isObject(dataItem) && !(dataItem instanceof Array))\n\t                    ? dataItem.value : dataItem;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Should be implemented.\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         * @return {string} tooltip string\n\t         */\n\t        formatTooltip: zrUtil.noop\n\t    };\n\t\n\t    /**\n\t     * Mapping to exists for merge.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n\t     * @param {Object|Array.<Object>} newCptOptions\n\t     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          index of which is the same as exists.\n\t     */\n\t    modelUtil.mappingToExists = function (exists, newCptOptions) {\n\t        // Mapping by the order by original option (but not order of\n\t        // new option) in merge mode. Because we should ensure\n\t        // some specified index (like xAxisIndex) is consistent with\n\t        // original option, which is easy to understand, espatially in\n\t        // media query. And in most case, merge option is used to\n\t        // update partial option but not be expected to change order.\n\t        newCptOptions = (newCptOptions || []).slice();\n\t\n\t        var result = zrUtil.map(exists || [], function (obj, index) {\n\t            return {exist: obj};\n\t        });\n\t\n\t        // Mapping by id or name if specified.\n\t        each(newCptOptions, function (cptOption, index) {\n\t            if (!isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            // id has highest priority.\n\t            for (var i = 0; i < result.length; i++) {\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    && cptOption.id != null\n\t                    && result[i].exist.id === cptOption.id + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option // Consider name: two map to one.\n\t                    // Can not match when both ids exist but different.\n\t                    && (exist.id == null || cptOption.id == null)\n\t                    && cptOption.name != null\n\t                    && !modelUtil.isIdInner(cptOption)\n\t                    && !modelUtil.isIdInner(exist)\n\t                    && exist.name === cptOption.name + ''\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    newCptOptions[index] = null;\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        // Otherwise mapping by index.\n\t        each(newCptOptions, function (cptOption, index) {\n\t            if (!isObject(cptOption)) {\n\t                return;\n\t            }\n\t\n\t            var i = 0;\n\t            for (; i < result.length; i++) {\n\t                var exist = result[i].exist;\n\t                if (!result[i].option\n\t                    // Existing model that already has id should be able to\n\t                    // mapped to (because after mapping performed model may\n\t                    // be assigned with a id, whish should not affect next\n\t                    // mapping), except those has inner id.\n\t                    && !modelUtil.isIdInner(exist)\n\t                    // Caution:\n\t                    // Do not overwrite id. But name can be overwritten,\n\t                    // because axis use name as 'show label text'.\n\t                    // 'exist' always has id and name and we dont\n\t                    // need to check it.\n\t                    && cptOption.id == null\n\t                ) {\n\t                    result[i].option = cptOption;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (i >= result.length) {\n\t                result.push({option: cptOption});\n\t            }\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Make id and name for mapping result (result of mappingToExists)\n\t     * into `keyInfo` field.\n\t     *\n\t     * @public\n\t     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n\t     *                          which order is the same as exists.\n\t     * @return {Array.<Object>} The input.\n\t     */\n\t    modelUtil.makeIdAndName = function (mapResult) {\n\t        // We use this id to hash component models and view instances\n\t        // in echarts. id can be specified by user, or auto generated.\n\t\n\t        // The id generation rule ensures new view instance are able\n\t        // to mapped to old instance when setOption are called in\n\t        // no-merge mode. So we generate model id by name and plus\n\t        // type in view id.\n\t\n\t        // name can be duplicated among components, which is convenient\n\t        // to specify multi components (like series) by one name.\n\t\n\t        // Ensure that each id is distinct.\n\t        var idMap = {};\n\t\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            existCpt && (idMap[existCpt.id] = item);\n\t        });\n\t\n\t        each(mapResult, function (item, index) {\n\t            var opt = item.option;\n\t\n\t            zrUtil.assert(\n\t                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n\t                'id duplicates: ' + (opt && opt.id)\n\t            );\n\t\n\t            opt && opt.id != null && (idMap[opt.id] = item);\n\t            !item.keyInfo && (item.keyInfo = {});\n\t        });\n\t\n\t        // Make name and id.\n\t        each(mapResult, function (item, index) {\n\t            var existCpt = item.exist;\n\t            var opt = item.option;\n\t            var keyInfo = item.keyInfo;\n\t\n\t            if (!isObject(opt)) {\n\t                return;\n\t            }\n\t\n\t            // name can be overwitten. Consider case: axis.name = '20km'.\n\t            // But id generated by name will not be changed, which affect\n\t            // only in that case: setOption with 'not merge mode' and view\n\t            // instance will be recreated, which can be accepted.\n\t            keyInfo.name = opt.name != null\n\t                ? opt.name + ''\n\t                : existCpt\n\t                ? existCpt.name\n\t                : '\\0-';\n\t\n\t            if (existCpt) {\n\t                keyInfo.id = existCpt.id;\n\t            }\n\t            else if (opt.id != null) {\n\t                keyInfo.id = opt.id + '';\n\t            }\n\t            else {\n\t                // Consider this situatoin:\n\t                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n\t                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n\t                // Series with the same name between optionA and optionB\n\t                // should be mapped.\n\t                var idNum = 0;\n\t                do {\n\t                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n\t                }\n\t                while (idMap[keyInfo.id]);\n\t            }\n\t\n\t            idMap[keyInfo.id] = item;\n\t        });\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     * @param {Object} cptOption\n\t     * @return {boolean}\n\t     */\n\t    modelUtil.isIdInner = function (cptOption) {\n\t        return isObject(cptOption)\n\t            && cptOption.id\n\t            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n\t    };\n\t\n\t    /**\n\t     * A helper for removing duplicate items between batchA and batchB,\n\t     * and in themselves, and categorize by series.\n\t     *\n\t     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n\t     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n\t     */\n\t    modelUtil.compressBatches = function (batchA, batchB) {\n\t        var mapA = {};\n\t        var mapB = {};\n\t\n\t        makeMap(batchA || [], mapA);\n\t        makeMap(batchB || [], mapB, mapA);\n\t\n\t        return [mapToArray(mapA), mapToArray(mapB)];\n\t\n\t        function makeMap(sourceBatch, map, otherMap) {\n\t            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n\t                var seriesId = sourceBatch[i].seriesId;\n\t                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n\t                var otherDataIndices = otherMap && otherMap[seriesId];\n\t\n\t                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n\t                    var dataIndex = dataIndices[j];\n\t\n\t                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n\t                        otherDataIndices[dataIndex] = null;\n\t                    }\n\t                    else {\n\t                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        function mapToArray(map, isData) {\n\t            var result = [];\n\t            for (var i in map) {\n\t                if (map.hasOwnProperty(i) && map[i] != null) {\n\t                    if (isData) {\n\t                        result.push(+i);\n\t                    }\n\t                    else {\n\t                        var dataIndices = mapToArray(map[i], true);\n\t                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n\t                    }\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n\t     *                         each of which can be Array or primary type.\n\t     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n\t     */\n\t    modelUtil.queryDataIndex = function (data, payload) {\n\t        if (payload.dataIndexInside != null) {\n\t            return payload.dataIndexInside;\n\t        }\n\t        else if (payload.dataIndex != null) {\n\t            return zrUtil.isArray(payload.dataIndex)\n\t                ? zrUtil.map(payload.dataIndex, function (value) {\n\t                    return data.indexOfRawIndex(value);\n\t                })\n\t                : data.indexOfRawIndex(payload.dataIndex);\n\t        }\n\t        else if (payload.name != null) {\n\t            return zrUtil.isArray(payload.name)\n\t                ? zrUtil.map(payload.name, function (value) {\n\t                    return data.indexOfName(value);\n\t                })\n\t                : data.indexOfName(payload.name);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {string|Object} finder\n\t     *        If string, e.g., 'geo', means {geoIndex: 0}.\n\t     *        If Object, could contain some of these properties below:\n\t     *        {\n\t     *            seriesIndex, seriesId, seriesName,\n\t     *            geoIndex, geoId, goeName,\n\t     *            bmapIndex, bmapId, bmapName,\n\t     *            xAxisIndex, xAxisId, xAxisName,\n\t     *            yAxisIndex, yAxisId, yAxisName,\n\t     *            gridIndex, gridId, gridName,\n\t     *            ... (can be extended)\n\t     *        }\n\t     *        Each properties can be number|string|Array.<number>|Array.<string>\n\t     *        For example, a finder could be\n\t     *        {\n\t     *            seriesIndex: 3,\n\t     *            geoId: ['aa', 'cc'],\n\t     *            gridName: ['xx', 'rr']\n\t     *        }\n\t     * @param {Object} [opt]\n\t     * @param {string} [opt.defaultMainType]\n\t     * @return {Object} result like:\n\t     *        {\n\t     *            seriesModels: [seriesModel1, seriesModel2],\n\t     *            seriesModel: seriesModel1, // The first model\n\t     *            geoModels: [geoModel1, geoModel2],\n\t     *            geoModel: geoModel1, // The first model\n\t     *            ...\n\t     *        }\n\t     */\n\t    modelUtil.parseFinder = function (ecModel, finder, opt) {\n\t        if (zrUtil.isString(finder)) {\n\t            var obj = {};\n\t            obj[finder + 'Index'] = 0;\n\t            finder = obj;\n\t        }\n\t\n\t        var defaultMainType = opt && opt.defaultMainType;\n\t        if (defaultMainType\n\t            && !has(finder, defaultMainType + 'Index')\n\t            && !has(finder, defaultMainType + 'Id')\n\t            && !has(finder, defaultMainType + 'Name')\n\t        ) {\n\t            finder[defaultMainType + 'Index'] = 0;\n\t        }\n\t\n\t        var result = {};\n\t\n\t        each(finder, function (value, key) {\n\t            var value = finder[key];\n\t\n\t            // Exclude 'dataIndex' and other illgal keys.\n\t            if (key === 'dataIndex' || key === 'dataIndexInside') {\n\t                result[key] = value;\n\t                return;\n\t            }\n\t\n\t            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n\t            var mainType = parsedKey[1];\n\t            var queryType = parsedKey[2];\n\t\n\t            if (!mainType || !queryType) {\n\t                return;\n\t            }\n\t\n\t            var queryParam = {mainType: mainType};\n\t            queryParam[queryType.toLowerCase()] = value;\n\t            var models = ecModel.queryComponents(queryParam);\n\t            result[mainType + 'Models'] = models;\n\t            result[mainType + 'Model'] = models[0];\n\t        });\n\t\n\t        return result;\n\t    };\n\t\n\t    function has(obj, prop) {\n\t        return obj && obj.hasOwnProperty(prop);\n\t    }\n\t\n\t    module.exports = modelUtil;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(5);\n\t    var matrix = __webpack_require__(27);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t\n\t        if (width < 0) {\n\t            x = x + width;\n\t            width = -width;\n\t        }\n\t        if (height < 0) {\n\t            y = y + height;\n\t            height = -height;\n\t        }\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var lt = [];\n\t            var rb = [];\n\t            var lb = [];\n\t            var rt = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                lt[0] = lb[0] = this.x;\n\t                lt[1] = rt[1] = this.y;\n\t                rb[0] = rt[0] = this.x + this.width;\n\t                rb[1] = lb[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(lt, lt, m);\n\t                v2ApplyTransform(rb, rb, m);\n\t                v2ApplyTransform(lb, lb, m);\n\t                v2ApplyTransform(rt, rt, m);\n\t\n\t                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n\t                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n\t                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n\t                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n\t                this.width = maxX - this.x;\n\t                this.height = maxY - this.y;\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // \n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            if (!b) {\n\t                return false;\n\t            }\n\t\n\t            if (!(b instanceof BoundingRect)) {\n\t                // Normalize negative width/height.\n\t                b = BoundingRect.create(b);\n\t            }\n\t\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        },\n\t\n\t        plain: function () {\n\t            return {\n\t                x: this.x,\n\t                y: this.y,\n\t                width: this.width,\n\t                height: this.height\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {Object|module:zrender/core/BoundingRect} rect\n\t     * @param {number} rect.x\n\t     * @param {number} rect.y\n\t     * @param {number} rect.width\n\t     * @param {number} rect.height\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    BoundingRect.create = function (rect) {\n\t        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var clazz = {};\n\t\n\t    var TYPE_DELIMITER = '.';\n\t    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n\t    var MEMBER_PRIFIX = '\\0ec_\\0';\n\t\n\t    /**\n\t     * Hide private class member.\n\t     * The same behavior as `host[name] = value;` (can be right-value)\n\t     * @public\n\t     */\n\t    clazz.set = function (host, name, value) {\n\t        return (host[MEMBER_PRIFIX + name] = value);\n\t    };\n\t\n\t    /**\n\t     * Hide private class member.\n\t     * The same behavior as `host[name];`\n\t     * @public\n\t     */\n\t    clazz.get = function (host, name) {\n\t        return host[MEMBER_PRIFIX + name];\n\t    };\n\t\n\t    /**\n\t     * For hidden private class member.\n\t     * The same behavior as `host.hasOwnProperty(name);`\n\t     * @public\n\t     */\n\t    clazz.hasOwn = function (host, name) {\n\t        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     */\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\n\t        var ret = {main: '', sub: ''};\n\t        if (componentType) {\n\t            componentType = componentType.split(TYPE_DELIMITER);\n\t            ret.main = componentType[0] || '';\n\t            ret.sub = componentType[1] || '';\n\t        }\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     */\n\t    function checkClassType(componentType) {\n\t        zrUtil.assert(\n\t            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n\t            'componentType \"' + componentType + '\" illegal'\n\t        );\n\t    }\n\t\n\t    /**\n\t     * @public\n\t     */\n\t    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\t\n\t        RootClass.$constructor = RootClass;\n\t        RootClass.extend = function (proto) {\n\t\n\t            if (__DEV__) {\n\t                zrUtil.each(mandatoryMethods, function (method) {\n\t                    if (!proto[method]) {\n\t                        console.warn(\n\t                            'Method `' + method + '` should be implemented'\n\t                            + (proto.type ? ' in ' + proto.type : '') + '.'\n\t                        );\n\t                    }\n\t                });\n\t            }\n\t\n\t            var superClass = this;\n\t            var ExtendedClass = function () {\n\t                if (!proto.$constructor) {\n\t                    superClass.apply(this, arguments);\n\t                }\n\t                else {\n\t                    proto.$constructor.apply(this, arguments);\n\t                }\n\t            };\n\t\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\n\t\n\t            ExtendedClass.extend = this.extend;\n\t            ExtendedClass.superCall = superCall;\n\t            ExtendedClass.superApply = superApply;\n\t            zrUtil.inherits(ExtendedClass, this);\n\t            ExtendedClass.superClass = superClass;\n\t\n\t            return ExtendedClass;\n\t        };\n\t    };\n\t\n\t    // superCall should have class info, which can not be fetch from 'this'.\n\t    // Consider this case:\n\t    // class A has method f,\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\n\t    // class C inherits class B, do not overrides method f,\n\t    // then when method of class C is called, dead loop occured.\n\t    function superCall(context, methodName) {\n\t        var args = zrUtil.slice(arguments, 2);\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    function superApply(context, methodName, args) {\n\t        return this.superClass.prototype[methodName].apply(context, args);\n\t    }\n\t\n\t    /**\n\t     * @param {Object} entity\n\t     * @param {Object} options\n\t     * @param {boolean} [options.registerWhenExtend]\n\t     * @public\n\t     */\n\t    clazz.enableClassManagement = function (entity, options) {\n\t        options = options || {};\n\t\n\t        /**\n\t         * Component model classes\n\t         * key: componentType,\n\t         * value:\n\t         *     componentClass, when componentType is 'xxx'\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n\t         * @type {Object}\n\t         */\n\t        var storage = {};\n\t\n\t        entity.registerClass = function (Clazz, componentType) {\n\t            if (componentType) {\n\t                checkClassType(componentType);\n\t                componentType = parseClassType(componentType);\n\t\n\t                if (!componentType.sub) {\n\t                    if (__DEV__) {\n\t                        if (storage[componentType.main]) {\n\t                            console.warn(componentType.main + ' exists.');\n\t                        }\n\t                    }\n\t                    storage[componentType.main] = Clazz;\n\t                }\n\t                else if (componentType.sub !== IS_CONTAINER) {\n\t                    var container = makeContainer(componentType);\n\t                    container[componentType.sub] = Clazz;\n\t                }\n\t            }\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n\t            var Clazz = storage[componentMainType];\n\t\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\n\t                Clazz = subType ? Clazz[subType] : null;\n\t            }\n\t\n\t            if (throwWhenNotFound && !Clazz) {\n\t                throw new Error(\n\t                    !subType\n\t                        ? componentMainType + '.' + 'type should be specified.'\n\t                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n\t                );\n\t            }\n\t\n\t            return Clazz;\n\t        };\n\t\n\t        entity.getClassesByMainType = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t\n\t            var result = [];\n\t            var obj = storage[componentType.main];\n\t\n\t            if (obj && obj[IS_CONTAINER]) {\n\t                zrUtil.each(obj, function (o, type) {\n\t                    type !== IS_CONTAINER && result.push(o);\n\t                });\n\t            }\n\t            else {\n\t                result.push(obj);\n\t            }\n\t\n\t            return result;\n\t        };\n\t\n\t        entity.hasClass = function (componentType) {\n\t            // Just consider componentType.main.\n\t            componentType = parseClassType(componentType);\n\t            return !!storage[componentType.main];\n\t        };\n\t\n\t        /**\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n\t         */\n\t        entity.getAllClassMainTypes = function () {\n\t            var types = [];\n\t            zrUtil.each(storage, function (obj, type) {\n\t                types.push(type);\n\t            });\n\t            return types;\n\t        };\n\t\n\t        /**\n\t         * If a main type is container and has sub types\n\t         * @param  {string}  mainType\n\t         * @return {boolean}\n\t         */\n\t        entity.hasSubTypes = function (componentType) {\n\t            componentType = parseClassType(componentType);\n\t            var obj = storage[componentType.main];\n\t            return obj && obj[IS_CONTAINER];\n\t        };\n\t\n\t        entity.parseClassType = parseClassType;\n\t\n\t        function makeContainer(componentType) {\n\t            var container = storage[componentType.main];\n\t            if (!container || !container[IS_CONTAINER]) {\n\t                container = storage[componentType.main] = {};\n\t                container[IS_CONTAINER] = true;\n\t            }\n\t            return container;\n\t        }\n\t\n\t        if (options.registerWhenExtend) {\n\t            var originalExtend = entity.extend;\n\t            if (originalExtend) {\n\t                entity.extend = function (proto) {\n\t                    var ExtendedClass = originalExtend.call(this, proto);\n\t                    return entity.registerClass(ExtendedClass, proto.type);\n\t                };\n\t            }\n\t        }\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * @param {string|Array.<string>} properties\n\t     */\n\t    clazz.setReadOnly = function (obj, properties) {\n\t        // FIXME It seems broken in IE8 simulation of IE11\n\t        // if (!zrUtil.isArray(properties)) {\n\t        //     properties = properties != null ? [properties] : [];\n\t        // }\n\t        // zrUtil.each(properties, function (prop) {\n\t        //     var value = obj[prop];\n\t\n\t        //     Object.defineProperty\n\t        //         && Object.defineProperty(obj, prop, {\n\t        //             value: value, writable: false\n\t        //         });\n\t        //     zrUtil.isArray(obj[prop])\n\t        //         && Object.freeze\n\t        //         && Object.freeze(obj[prop]);\n\t        // });\n\t    };\n\t\n\t    module.exports = clazz;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Component model\n\t *\n\t * @module echarts/model/Component\n\t */\n\t\n\t\n\t    var Model = __webpack_require__(12);\n\t    var zrUtil = __webpack_require__(1);\n\t    var arrayPush = Array.prototype.push;\n\t    var componentUtil = __webpack_require__(58);\n\t    var clazzUtil = __webpack_require__(15);\n\t    var layout = __webpack_require__(20);\n\t\n\t    /**\n\t     * @alias module:echarts/model/Component\n\t     * @constructor\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {module:echarts/model/Model} ecModel\n\t     */\n\t    var ComponentModel = Model.extend({\n\t\n\t        type: 'component',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        id: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        mainType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {string}\n\t         */\n\t        subType: '',\n\t\n\t        /**\n\t         * @readOnly\n\t         * @type {number}\n\t         */\n\t        componentIndex: 0,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * @type {module:echarts/model/Global}\n\t         * @readOnly\n\t         */\n\t        ecModel: null,\n\t\n\t        /**\n\t         * key: componentType\n\t         * value:  Component model list, can not be null.\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @readOnly\n\t         */\n\t        dependentModels: [],\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        uid: null,\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        $constructor: function (option, parentModel, ecModel, extraOpt) {\n\t            Model.call(this, option, parentModel, ecModel, extraOpt);\n\t\n\t            this.uid = componentUtil.getUID('componentModel');\n\t        },\n\t\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t        },\n\t\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            var themeModel = ecModel.getTheme();\n\t            zrUtil.merge(option, themeModel.get(this.mainType));\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (option, extraOpt) {\n\t            zrUtil.merge(this.option, option, true);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, option, layoutMode);\n\t            }\n\t        },\n\t\n\t        // Hooker after init or mergeOption\n\t        optionUpdated: function (newCptOption, isInit) {},\n\t\n\t        getDefaultOption: function () {\n\t            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n\t                var optList = [];\n\t                var Class = this.constructor;\n\t                while (Class) {\n\t                    var opt = Class.prototype.defaultOption;\n\t                    opt && optList.push(opt);\n\t                    Class = Class.superClass;\n\t                }\n\t\n\t                var defaultOption = {};\n\t                for (var i = optList.length - 1; i >= 0; i--) {\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n\t                }\n\t                clazzUtil.set(this, '__defaultOption', defaultOption);\n\t            }\n\t            return clazzUtil.get(this, '__defaultOption');\n\t        },\n\t\n\t        getReferringComponents: function (mainType) {\n\t            return this.ecModel.queryComponents({\n\t                mainType: mainType,\n\t                index: this.get(mainType + 'Index', true),\n\t                id: this.get(mainType + 'Id', true)\n\t            });\n\t        }\n\t\n\t    });\n\t\n\t    // Reset ComponentModel.extend, add preConstruct.\n\t    // clazzUtil.enableClassExtend(\n\t    //     ComponentModel,\n\t    //     function (option, parentModel, ecModel, extraOpt) {\n\t    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n\t    //         zrUtil.extend(this, extraOpt);\n\t\n\t    //         this.uid = componentUtil.getUID('componentModel');\n\t\n\t    //         // this.setReadOnly([\n\t    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n\t    //         //     'dependentModels', 'componentIndex'\n\t    //         // ]);\n\t    //     }\n\t    // );\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(\n\t        ComponentModel, {registerWhenExtend: true}\n\t    );\n\t    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\t\n\t    // Add capability of ComponentModel.topologicalTravel.\n\t    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\t\n\t    function getDependencies(componentType) {\n\t        var deps = [];\n\t        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n\t            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n\t        });\n\t        // Ensure main type\n\t        return zrUtil.map(deps, function (type) {\n\t            return clazzUtil.parseClassType(type).main;\n\t        });\n\t    }\n\t\n\t    zrUtil.mixin(ComponentModel, __webpack_require__(186));\n\t\n\t    module.exports = ComponentModel;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(32);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(26)\n\t  , createDesc = __webpack_require__(45);\n\tmodule.exports = __webpack_require__(24) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Layout helpers for each component positioning\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var BoundingRect = __webpack_require__(14);\n\t    var numberUtil = __webpack_require__(4);\n\t    var formatUtil = __webpack_require__(9);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var each = zrUtil.each;\n\t\n\t    var layout = {};\n\t\n\t    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n\t        'left', 'right', 'top', 'bottom', 'width', 'height'\n\t    ];\n\t\n\t    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n\t        var x = 0;\n\t        var y = 0;\n\t        if (maxWidth == null) {\n\t            maxWidth = Infinity;\n\t        }\n\t        if (maxHeight == null) {\n\t            maxHeight = Infinity;\n\t        }\n\t        var currentLineMaxSize = 0;\n\t        group.eachChild(function (child, idx) {\n\t            var position = child.position;\n\t            var rect = child.getBoundingRect();\n\t            var nextChild = group.childAt(idx + 1);\n\t            var nextChildRect = nextChild && nextChild.getBoundingRect();\n\t            var nextX;\n\t            var nextY;\n\t            if (orient === 'horizontal') {\n\t                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n\t                nextX = x + moveX;\n\t                // Wrap when width exceeds maxWidth or meet a `newline` group\n\t                if (nextX > maxWidth || child.newline) {\n\t                    x = 0;\n\t                    nextX = moveX;\n\t                    y += currentLineMaxSize + gap;\n\t                    currentLineMaxSize = rect.height;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n\t                }\n\t            }\n\t            else {\n\t                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n\t                nextY = y + moveY;\n\t                // Wrap when width exceeds maxHeight or meet a `newline` group\n\t                if (nextY > maxHeight || child.newline) {\n\t                    x += currentLineMaxSize + gap;\n\t                    y = 0;\n\t                    nextY = moveY;\n\t                    currentLineMaxSize = rect.width;\n\t                }\n\t                else {\n\t                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n\t                }\n\t            }\n\t\n\t            if (child.newline) {\n\t                return;\n\t            }\n\t\n\t            position[0] = x;\n\t            position[1] = y;\n\t\n\t            orient === 'horizontal'\n\t                ? (x = nextX + gap)\n\t                : (y = nextY + gap);\n\t        });\n\t    }\n\t\n\t    /**\n\t     * VBox or HBox layouting\n\t     * @param {string} orient\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.box = boxLayout;\n\t\n\t    /**\n\t     * VBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\t\n\t    /**\n\t     * HBox layouting\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {number} gap\n\t     * @param {number} [width=Infinity]\n\t     * @param {number} [height=Infinity]\n\t     */\n\t    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\t\n\t    /**\n\t     * If x or x2 is not specified or 'center' 'left' 'right',\n\t     * the width would be as long as possible.\n\t     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n\t     * the height would be as long as possible.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.x]\n\t     * @param {number|string} [positionInfo.y]\n\t     * @param {number|string} [positionInfo.x2]\n\t     * @param {number|string} [positionInfo.y2]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @return {Object} {width, height}\n\t     */\n\t    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var x = parsePercent(positionInfo.x, containerWidth);\n\t        var y = parsePercent(positionInfo.y, containerHeight);\n\t        var x2 = parsePercent(positionInfo.x2, containerWidth);\n\t        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\t\n\t        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n\t        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n\t        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n\t        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\t\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        return {\n\t            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n\t            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Parse position info.\n\t     *\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {number|string} [positionInfo.width]\n\t     * @param {number|string} [positionInfo.height]\n\t     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n\t     * @param {Object} containerRect\n\t     * @param {string|number} [margin]\n\t     *\n\t     * @return {module:zrender/core/BoundingRect}\n\t     */\n\t    layout.getLayoutRect = function (\n\t        positionInfo, containerRect, margin\n\t    ) {\n\t        margin = formatUtil.normalizeCssArray(margin || 0);\n\t\n\t        var containerWidth = containerRect.width;\n\t        var containerHeight = containerRect.height;\n\t\n\t        var left = parsePercent(positionInfo.left, containerWidth);\n\t        var top = parsePercent(positionInfo.top, containerHeight);\n\t        var right = parsePercent(positionInfo.right, containerWidth);\n\t        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n\t        var width = parsePercent(positionInfo.width, containerWidth);\n\t        var height = parsePercent(positionInfo.height, containerHeight);\n\t\n\t        var verticalMargin = margin[2] + margin[0];\n\t        var horizontalMargin = margin[1] + margin[3];\n\t        var aspect = positionInfo.aspect;\n\t\n\t        // If width is not specified, calculate width from left and right\n\t        if (isNaN(width)) {\n\t            width = containerWidth - right - horizontalMargin - left;\n\t        }\n\t        if (isNaN(height)) {\n\t            height = containerHeight - bottom - verticalMargin - top;\n\t        }\n\t\n\t        // If width and height are not given\n\t        // 1. Graph should not exceeds the container\n\t        // 2. Aspect must be keeped\n\t        // 3. Graph should take the space as more as possible\n\t        if (isNaN(width) && isNaN(height)) {\n\t            if (aspect > containerWidth / containerHeight) {\n\t                width = containerWidth * 0.8;\n\t            }\n\t            else {\n\t                height = containerHeight * 0.8;\n\t            }\n\t        }\n\t\n\t        if (aspect != null) {\n\t            // Calculate width or height with given aspect\n\t            if (isNaN(width)) {\n\t                width = aspect * height;\n\t            }\n\t            if (isNaN(height)) {\n\t                height = width / aspect;\n\t            }\n\t        }\n\t\n\t        // If left is not specified, calculate left from right and width\n\t        if (isNaN(left)) {\n\t            left = containerWidth - right - width - horizontalMargin;\n\t        }\n\t        if (isNaN(top)) {\n\t            top = containerHeight - bottom - height - verticalMargin;\n\t        }\n\t\n\t        // Align left and top\n\t        switch (positionInfo.left || positionInfo.right) {\n\t            case 'center':\n\t                left = containerWidth / 2 - width / 2 - margin[3];\n\t                break;\n\t            case 'right':\n\t                left = containerWidth - width - horizontalMargin;\n\t                break;\n\t        }\n\t        switch (positionInfo.top || positionInfo.bottom) {\n\t            case 'middle':\n\t            case 'center':\n\t                top = containerHeight / 2 - height / 2 - margin[0];\n\t                break;\n\t            case 'bottom':\n\t                top = containerHeight - height - verticalMargin;\n\t                break;\n\t        }\n\t        // If something is wrong and left, top, width, height are calculated as NaN\n\t        left = left || 0;\n\t        top = top || 0;\n\t        if (isNaN(width)) {\n\t            // Width may be NaN if only one value is given except width\n\t            width = containerWidth - left - (right || 0);\n\t        }\n\t        if (isNaN(height)) {\n\t            // Height may be NaN if only one value is given except height\n\t            height = containerHeight - top - (bottom || 0);\n\t        }\n\t\n\t        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n\t        rect.margin = margin;\n\t        return rect;\n\t    };\n\t\n\t\n\t    /**\n\t     * Position a zr element in viewport\n\t     *  Group position is specified by either\n\t     *  {left, top}, {right, bottom}\n\t     *  If all properties exists, right and bottom will be igonred.\n\t     *\n\t     * Logic:\n\t     *     1. Scale (against origin point in parent coord)\n\t     *     2. Rotate (against origin point in parent coord)\n\t     *     3. Traslate (with el.position by this method)\n\t     * So this method only fixes the last step 'Traslate', which does not affect\n\t     * scaling and rotating.\n\t     *\n\t     * If be called repeatly with the same input el, the same result will be gotten.\n\t     *\n\t     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n\t     * @param {Object} positionInfo\n\t     * @param {number|string} [positionInfo.left]\n\t     * @param {number|string} [positionInfo.top]\n\t     * @param {number|string} [positionInfo.right]\n\t     * @param {number|string} [positionInfo.bottom]\n\t     * @param {Object} containerRect\n\t     * @param {string|number} margin\n\t     * @param {Object} [opt]\n\t     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n\t     * @param {Array.<number>} [opt.boundingMode='all']\n\t     *        Specify how to calculate boundingRect when locating.\n\t     *        'all': Position the boundingRect that is transformed and uioned\n\t     *               both itself and its descendants.\n\t     *               This mode simplies confine the elements in the bounding\n\t     *               of their container (e.g., using 'right: 0').\n\t     *        'raw': Position the boundingRect that is not transformed and only itself.\n\t     *               This mode is useful when you want a element can overflow its\n\t     *               container. (Consider a rotated circle needs to be located in a corner.)\n\t     *               In this mode positionInfo.width/height can only be number.\n\t     */\n\t    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n\t        var h = !opt || !opt.hv || opt.hv[0];\n\t        var v = !opt || !opt.hv || opt.hv[1];\n\t        var boundingMode = opt && opt.boundingMode || 'all';\n\t\n\t        if (!h && !v) {\n\t            return;\n\t        }\n\t\n\t        var rect;\n\t        if (boundingMode === 'raw') {\n\t            rect = el.type === 'group'\n\t                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n\t                : el.getBoundingRect();\n\t        }\n\t        else {\n\t            rect = el.getBoundingRect();\n\t            if (el.needLocalTransform()) {\n\t                var transform = el.getLocalTransform();\n\t                // Notice: raw rect may be inner object of el,\n\t                // which should not be modified.\n\t                rect = rect.clone();\n\t                rect.applyTransform(transform);\n\t            }\n\t        }\n\t\n\t        positionInfo = layout.getLayoutRect(\n\t            zrUtil.defaults(\n\t                {width: rect.width, height: rect.height},\n\t                positionInfo\n\t            ),\n\t            containerRect,\n\t            margin\n\t        );\n\t\n\t        // Because 'tranlate' is the last step in transform\n\t        // (see zrender/core/Transformable#getLocalTransfrom),\n\t        // we can just only modify el.position to get final result.\n\t        var elPos = el.position;\n\t        var dx = h ? positionInfo.x - rect.x : 0;\n\t        var dy = v ? positionInfo.y - rect.y : 0;\n\t\n\t        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n\t    };\n\t\n\t    /**\n\t     * Consider Case:\n\t     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n\t     * through setOption or media query, using normal zrUtil.merge will cause\n\t     * {right: 0} does not take effect.\n\t     *\n\t     * @example\n\t     * ComponentModel.extend({\n\t     *     init: function () {\n\t     *         ...\n\t     *         var inputPositionParams = layout.getLayoutParams(option);\n\t     *         this.mergeOption(inputPositionParams);\n\t     *     },\n\t     *     mergeOption: function (newOption) {\n\t     *         newOption && zrUtil.merge(thisOption, newOption, true);\n\t     *         layout.mergeLayoutParam(thisOption, newOption);\n\t     *     }\n\t     * });\n\t     *\n\t     * @param {Object} targetOption\n\t     * @param {Object} newOption\n\t     * @param {Object|string} [opt]\n\t     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n\t     */\n\t    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n\t        !zrUtil.isObject(opt) && (opt = {});\n\t        var hNames = ['width', 'left', 'right']; // Order by priority.\n\t        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n\t        var hResult = merge(hNames);\n\t        var vResult = merge(vNames);\n\t\n\t        copy(hNames, targetOption, hResult);\n\t        copy(vNames, targetOption, vResult);\n\t\n\t        function merge(names) {\n\t            var newParams = {};\n\t            var newValueCount = 0;\n\t            var merged = {};\n\t            var mergedValueCount = 0;\n\t            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\t\n\t            each(names, function (name) {\n\t                merged[name] = targetOption[name];\n\t            });\n\t            each(names, function (name) {\n\t                // Consider case: newOption.width is null, which is\n\t                // set by user for removing width setting.\n\t                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n\t                hasValue(newParams, name) && newValueCount++;\n\t                hasValue(merged, name) && mergedValueCount++;\n\t            });\n\t\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // or targetOption: {right: ...} and newOption: {width: ...},\n\t            // There is no conflict when merged only has params count\n\t            // little than enoughParamNumber.\n\t            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n\t                return merged;\n\t            }\n\t            // Case: newOption: {width: ..., right: ...},\n\t            // Than we can make sure user only want those two, and ignore\n\t            // all origin params in targetOption.\n\t            else if (newValueCount >= enoughParamNumber) {\n\t                return newParams;\n\t            }\n\t            else {\n\t                // Chose another param from targetOption by priority.\n\t                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n\t                for (var i = 0; i < names.length; i++) {\n\t                    var name = names[i];\n\t                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n\t                        newParams[name] = targetOption[name];\n\t                        break;\n\t                    }\n\t                }\n\t                return newParams;\n\t            }\n\t        }\n\t\n\t        function hasProp(obj, name) {\n\t            return obj.hasOwnProperty(name);\n\t        }\n\t\n\t        function hasValue(obj, name) {\n\t            return obj[name] != null && obj[name] !== 'auto';\n\t        }\n\t\n\t        function copy(names, target, source) {\n\t            each(names, function (name) {\n\t                target[name] = source[name];\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.getLayoutParams = function (source) {\n\t        return layout.copyLayoutParams({}, source);\n\t    };\n\t\n\t    /**\n\t     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n\t     * @param {Object} source\n\t     * @return {Object} Result contains those props.\n\t     */\n\t    layout.copyLayoutParams = function (target, source) {\n\t        source && target && each(LOCATION_PARAMS, function (name) {\n\t            source.hasOwnProperty(name) && (target[name] = source[name]);\n\t        });\n\t        return target;\n\t    };\n\t\n\t    module.exports = layout;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(1);\n\t    var BoundingRect = __webpack_require__(14);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText  Canvas \n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME \n\t        var lineHeight = getTextWidth('', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(5);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // \n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} \n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] \n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} \n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * \n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * \n\t     * \n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out \n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        //  t \n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(41);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(65)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(18)\n\t  , IE8_DOM_DEFINE = __webpack_require__(106)\n\t  , toPrimitive    = __webpack_require__(123)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(24) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * \n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * \n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t/**\n\t * \n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * trigger\n\t         *\n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} handler \n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {string} event \n\t         * @param {Function} [handler] \n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} type \n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * context, context\n\t         * @param {string} type \n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    //  onxxxx \n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrag\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 33 */,\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO Parse shadow style\n\t// TODO Only shallow path support\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    module.exports = function (properties) {\n\t        // Normalize\n\t        for (var i = 0; i < properties.length; i++) {\n\t            if (!properties[i][1]) {\n\t               properties[i][1] = properties[i][0];\n\t            }\n\t        }\n\t        return function (excludes) {\n\t            var style = {};\n\t            for (var i = 0; i < properties.length; i++) {\n\t                var propName = properties[i][1];\n\t                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n\t                    continue;\n\t                }\n\t                var val = this.getShallow(propName);\n\t                if (val != null) {\n\t                    style[properties[i][0]] = val;\n\t                }\n\t            }\n\t            return style;\n\t        };\n\t    };\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * // Scale class management\n\t * @module echarts/scale/Scale\n\t */\n\t\n\t\n\t    var clazzUtil = __webpack_require__(15);\n\t\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [Infinity, -Infinity];\n\t\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);\n\t        // not setExtent because in log axis it may transformed to power\n\t        // this.setExtent(extent[0], extent[1]);\n\t    };\n\t\n\t    /**\n\t     * Set extent from data\n\t     * @param {module:echarts/data/List} data\n\t     * @param {string} dim\n\t     */\n\t    scaleProto.unionExtentFromData = function (data, dim) {\n\t        this.unionExtent(data.getDataExtent(dim, true));\n\t    };\n\t\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, {\n\t        registerWhenExtend: true\n\t    });\n\t\n\t    module.exports = Scale;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debugcatchBrushExceptiontrue\n\t         * 0 : debug\n\t         * 1 : \n\t         * 2 : \n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina \n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * GroupGroup\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Element = __webpack_require__(87);\n\t    var BoundingRect = __webpack_require__(14);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            if (opts.hasOwnProperty(key)) {\n\t                this[key] = opts[key];\n\t            }\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         *  index \n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *  nextSibling \n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                // TODO\n\t                // The boundingRect cacluated by transforming original\n\t                // rect may be bigger than the actual bundingRect when rotation\n\t                // is used. (Consider a circle rotated aginst its center, where\n\t                // the actual boundingRect should be the same as that not be\n\t                // rotated.) But we can not find better approach to calculate\n\t                // actual boundingRect yet, considering performance.\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path `buildPath``ctx`, pathpathCommands\n\t *  isInsidePath boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(22);\n\t    var vec2 = __webpack_require__(5);\n\t    var bbox = __webpack_require__(216);\n\t    var BoundingRect = __webpack_require__(14);\n\t    var dpr = __webpack_require__(36).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * Path\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi  _dashedXXXXTo \n\t            // xi, yi , x0, y0  closePath \n\t            //  beginPath  lineTo x0, y0 \n\t            //  lineTo dashed line  IE10- \n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._yi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context  rebuildPath  fill\n\t         * stroke \n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         *  Path \n\t         * \n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                //  Float32Array\n\t                // \n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         *  Float32Array \n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo  subpath, \n\t                        //  closePath \n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc \n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc \n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    //  L, C, Q\n\t                    //  previous point  point\n\t                    //\n\t                    //  Arc \n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            //  arc \n\t                            // \n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/core/event\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(28);\n\t    var env = __webpack_require__(10);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    // `calculate` is optional, default false\n\t    function clientToLocal(el, e, out, calculate) {\n\t        out = out || {};\n\t\n\t        // According to the W3C Working Draft, offsetX and offsetY should be relative\n\t        // to the padding edge of the target element. The only browser using this convention\n\t        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n\t        // not support the properties.\n\t        // (see http://www.jacklmoore.com/notes/mouse-position/)\n\t        // In zr painter.dom, padding edge equals to border edge.\n\t\n\t        // FIXME\n\t        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n\t        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n\t        // is too complex. So css-transfrom dont support in this case temporarily.\n\t        if (calculate || !env.canvasSupported) {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n\t        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n\t        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n\t        // zoom-factor, overflow / opacity layers, transforms ...)\n\t        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n\t        // <https://bugs.jquery.com/ticket/8523#comment:14>\n\t        // BTW3, In ff, offsetX/offsetY is always 0.\n\t        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n\t            out.zrX = e.layerX;\n\t            out.zrY = e.layerY;\n\t        }\n\t        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n\t        else if (e.offsetX != null) {\n\t            out.zrX = e.offsetX;\n\t            out.zrY = e.offsetY;\n\t        }\n\t        // For some other device, e.g., IOS safari.\n\t        else {\n\t            defaultGetZrXY(el, e, out);\n\t        }\n\t\n\t        return out;\n\t    }\n\t\n\t    function defaultGetZrXY(el, e, out) {\n\t        // This well-known method below does not support css transform.\n\t        var box = getBoundingClientRect(el);\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t    }\n\t\n\t    /**\n\t     * domtouch.\n\t     * `calculate` is optional, default false.\n\t     */\n\t    function normalizeEvent(el, e, calculate) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e, calculate);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e, calculate);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * preventDefault and stopPropagation.\n\t     * Notice: do not do that in zrender. Upper application\n\t     * do that if necessary.\n\t     *\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // \n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 40 */,\n/* 41 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(32)\n\t  , document = __webpack_require__(8).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(8)\n\t  , core      = __webpack_require__(16)\n\t  , ctx       = __webpack_require__(23)\n\t  , hide      = __webpack_require__(19)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(26).f\n\t  , has = __webpack_require__(31)\n\t  , TAG = __webpack_require__(7)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(72)('keys')\n\t  , uid    = __webpack_require__(75);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(108)\n\t  , defined = __webpack_require__(42);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(48)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(98), __esModule: true };\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(99), __esModule: true };\n\n/***/ },\n/* 53 */,\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * Interface of Coordinate System Class\n\t     *\n\t     * create:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *     @return {Object} coordinate system instance\n\t     *\n\t     * update:\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {module:echarts/ExtensionAPI} api\n\t     *\n\t     * convertToPixel:\n\t     * convertFromPixel:\n\t     *     These two methods is also responsible for determine whether this\n\t     *     coodinate system is applicable to the given `finder`.\n\t     *     Each coordinate system will be tried, util one returns none\n\t     *     null/undefined value.\n\t     *     @param {module:echarts/model/Global} ecModel\n\t     *     @param {Object} finder\n\t     *     @param {Array|number} value\n\t     *     @return {Array|number} convert result.\n\t     *\n\t     * containPoint:\n\t     *     @param {Array.<number>} point In pixel coordinate system.\n\t     *     @return {boolean}\n\t     */\n\t\n\t    var coordinateSystemCreators = {};\n\t\n\t    function CoordinateSystemManager() {\n\t\n\t        this._coordinateSystems = [];\n\t    }\n\t\n\t    CoordinateSystemManager.prototype = {\n\t\n\t        constructor: CoordinateSystemManager,\n\t\n\t        create: function (ecModel, api) {\n\t            var coordinateSystems = [];\n\t            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n\t                var list = creater.create(ecModel, api);\n\t                coordinateSystems = coordinateSystems.concat(list || []);\n\t            });\n\t\n\t            this._coordinateSystems = coordinateSystems;\n\t        },\n\t\n\t        update: function (ecModel, api) {\n\t            zrUtil.each(this._coordinateSystems, function (coordSys) {\n\t                // FIXME MUST have\n\t                coordSys.update && coordSys.update(ecModel, api);\n\t            });\n\t        },\n\t\n\t        getCoordinateSystems: function () {\n\t            return this._coordinateSystems.slice();\n\t        }\n\t    };\n\t\n\t    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n\t        coordinateSystemCreators[type] = coordinateSystemCreator;\n\t    };\n\t\n\t    CoordinateSystemManager.get = function (type) {\n\t        return coordinateSystemCreators[type];\n\t    };\n\t\n\t    module.exports = CoordinateSystemManager;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var OrdinalScale = __webpack_require__(194);\n\t    var IntervalScale = __webpack_require__(57);\n\t    __webpack_require__(195);\n\t    __webpack_require__(193);\n\t    var Scale = __webpack_require__(35);\n\t\n\t    var numberUtil = __webpack_require__(4);\n\t    var zrUtil = __webpack_require__(1);\n\t    var textContain = __webpack_require__(21);\n\t    var axisHelper = {};\n\t\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     * Item of returned array can only be number (including Infinity and NaN).\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var scaleType = scale.type;\n\t\n\t        var min = model.getMin();\n\t        var max = model.getMax();\n\t        var fixMin = min != null;\n\t        var fixMax = max != null;\n\t        var originalExtent = scale.getExtent();\n\t\n\t        var axisDataLen;\n\t        var boundaryGap;\n\t        var span;\n\t        if (scaleType === 'ordinal') {\n\t            axisDataLen = (model.get('data') || []).length;\n\t        }\n\t        else {\n\t            boundaryGap = model.get('boundaryGap');\n\t            if (!zrUtil.isArray(boundaryGap)) {\n\t                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n\t            }\n\t            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t            span = originalExtent[1] - originalExtent[0];\n\t        }\n\t\n\t        if (min == null) {\n\t            min = scaleType === 'ordinal'\n\t                ? (axisDataLen ? 0 : NaN)\n\t                : originalExtent[0] - boundaryGap[0] * span;\n\t        }\n\t        if (max == null) {\n\t            max = scaleType === 'ordinal'\n\t                ? (axisDataLen ? axisDataLen - 1 : NaN)\n\t                : originalExtent[1] + boundaryGap[1] * span;\n\t        }\n\t\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t\n\t        (min == null || !isFinite(min)) && (min = NaN);\n\t        (max == null || !isFinite(max)) && (max = NaN);\n\t\n\t        axis.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\t\n\t        // Evaluate if axis needs cross zero\n\t        if (model.getNeedCrossZero()) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t\n\t        return [min, max];\n\t    };\n\t\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = model.getMin() != null;\n\t        var fixMax = model.getMax() != null;\n\t        var splitNumber = model.get('splitNumber');\n\t\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            var origin = (extent[1] + extent[0]) / 2;\n\t            scale.setExtent(\n\t                intervalScale * (extent[0] - origin) + origin,\n\t                intervalScale * (extent[1] - origin) + origin\n\t            );\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function(model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t                // Buildin scale\n\t                case 'category':\n\t                    return new OrdinalScale(\n\t                        model.getCategories(), [Infinity, -Infinity]\n\t                    );\n\t                case 'value':\n\t                    return new IntervalScale();\n\t                // Extended scale, like time and log\n\t                default:\n\t                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // axislabelhorizontalvertical.\n\t\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(\n\t                labels[i], font, 'center', 'top'\n\t            );\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }\n\t            // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            }\n\t            else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = (function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val != null ? val : '');\n\t                };\n\t            })(labelFormatter);\n\t            // Consider empty array\n\t            return zrUtil.map(labels, labelFormatter);\n\t        }\n\t        else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(\n\t                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n\t                    idx\n\t                );\n\t            }, this);\n\t        }\n\t        else {\n\t            return labels;\n\t        }\n\t    };\n\t\n\t    module.exports = axisHelper;\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * List for data storage\n\t * @module echarts/data/List\n\t */\n\t\n\t\n\t    var UNDEFINED = 'undefined';\n\t    var globalObj = typeof window === 'undefined' ? global : window;\n\t    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n\t        ? Array : globalObj.Float64Array;\n\t    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n\t        ? Array : globalObj.Int32Array;\n\t\n\t    var dataCtors = {\n\t        'float': Float64Array,\n\t        'int': Int32Array,\n\t        // Ordinal data type can be string or int\n\t        'ordinal': Array,\n\t        'number': Array,\n\t        'time': Array\n\t    };\n\t\n\t    var Model = __webpack_require__(12);\n\t    var DataDiffer = __webpack_require__(179);\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(13);\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var TRANSFERABLE_PROPERTIES = [\n\t        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n\t    ];\n\t\n\t    var transferProperties = function (a, b) {\n\t        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n\t            if (b.hasOwnProperty(propName)) {\n\t                a[propName] = b[propName];\n\t            }\n\t        });\n\t\n\t        a.__wrappedMethods = b.__wrappedMethods;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/data/List\n\t     *\n\t     * @param {Array.<string>} dimensions\n\t     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n\t     * @param {module:echarts/model/Model} hostModel\n\t     */\n\t    var List = function (dimensions, hostModel) {\n\t\n\t        dimensions = dimensions || ['x', 'y'];\n\t\n\t        var dimensionInfos = {};\n\t        var dimensionNames = [];\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimensionName;\n\t            var dimensionInfo = {};\n\t            if (typeof dimensions[i] === 'string') {\n\t                dimensionName = dimensions[i];\n\t                dimensionInfo = {\n\t                    name: dimensionName,\n\t                    stackable: false,\n\t                    // Type can be 'float', 'int', 'number'\n\t                    // Default is number, Precision of float may not enough\n\t                    type: 'number'\n\t                };\n\t            }\n\t            else {\n\t                dimensionInfo = dimensions[i];\n\t                dimensionName = dimensionInfo.name;\n\t                dimensionInfo.type = dimensionInfo.type || 'number';\n\t            }\n\t            dimensionNames.push(dimensionName);\n\t            dimensionInfos[dimensionName] = dimensionInfo;\n\t        }\n\t        /**\n\t         * @readOnly\n\t         * @type {Array.<string>}\n\t         */\n\t        this.dimensions = dimensionNames;\n\t\n\t        /**\n\t         * Infomation of each data dimension, like data type.\n\t         * @type {Object}\n\t         */\n\t        this._dimensionInfos = dimensionInfos;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.hostModel = hostModel;\n\t\n\t        /**\n\t         * @type {module:echarts/model/Model}\n\t         */\n\t        this.dataType;\n\t\n\t        /**\n\t         * Indices stores the indices of data subset after filtered.\n\t         * This data subset will be used in chart.\n\t         * @type {Array.<number>}\n\t         * @readOnly\n\t         */\n\t        this.indices = [];\n\t\n\t        /**\n\t         * Data storage\n\t         * @type {Object.<key, TypedArray|Array>}\n\t         * @private\n\t         */\n\t        this._storage = {};\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._nameList = [];\n\t        /**\n\t         * @type {Array.<string>}\n\t         */\n\t        this._idList = [];\n\t        /**\n\t         * Models of data option is stored sparse for optimizing memory cost\n\t         * @type {Array.<module:echarts/model/Model>}\n\t         * @private\n\t         */\n\t        this._optionModels = [];\n\t\n\t        /**\n\t         * @param {module:echarts/data/List}\n\t         */\n\t        this.stackedOn = null;\n\t\n\t        /**\n\t         * Global visual properties after visual coding\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._visual = {};\n\t\n\t        /**\n\t         * Globel layout properties.\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._layout = {};\n\t\n\t        /**\n\t         * Item visual properties after visual coding\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemVisuals = [];\n\t\n\t        /**\n\t         * Item layout properties after layout\n\t         * @type {Array.<Object>}\n\t         * @private\n\t         */\n\t        this._itemLayouts = [];\n\t\n\t        /**\n\t         * Graphic elemnents\n\t         * @type {Array.<module:zrender/Element>}\n\t         * @private\n\t         */\n\t        this._graphicEls = [];\n\t\n\t        /**\n\t         * @type {Array.<Array|Object>}\n\t         * @private\n\t         */\n\t        this._rawData;\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @private\n\t         */\n\t        this._extent;\n\t    };\n\t\n\t    var listProto = List.prototype;\n\t\n\t    listProto.type = 'list';\n\t    /**\n\t     * If each data item has it's own option\n\t     * @type {boolean}\n\t     */\n\t    listProto.hasItemOption = true;\n\t\n\t    /**\n\t     * Get dimension name\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     * @return {string} Concrete dim name.\n\t     */\n\t    listProto.getDimension = function (dim) {\n\t        if (!isNaN(dim)) {\n\t            dim = this.dimensions[dim] || dim;\n\t        }\n\t        return dim;\n\t    };\n\t    /**\n\t     * Get type and stackable info of particular dimension\n\t     * @param {string|number} dim\n\t     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n\t     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n\t     */\n\t    listProto.getDimensionInfo = function (dim) {\n\t        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n\t    };\n\t\n\t    /**\n\t     * Initialize from data\n\t     * @param {Array.<Object|number|Array>} data\n\t     * @param {Array.<string>} [nameList]\n\t     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n\t     */\n\t    listProto.initData = function (data, nameList, dimValueGetter) {\n\t        data = data || [];\n\t\n\t        if (__DEV__) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        this._rawData = data;\n\t\n\t        // Clear\n\t        var storage = this._storage = {};\n\t        var indices = this.indices = [];\n\t\n\t        var dimensions = this.dimensions;\n\t        var size = data.length;\n\t        var dimensionInfoMap = this._dimensionInfos;\n\t\n\t        var idList = [];\n\t        var nameRepeatCount = {};\n\t\n\t        nameList = nameList || [];\n\t\n\t        // Init storage\n\t        for (var i = 0; i < dimensions.length; i++) {\n\t            var dimInfo = dimensionInfoMap[dimensions[i]];\n\t            var DataCtor = dataCtors[dimInfo.type];\n\t            storage[dimensions[i]] = new DataCtor(size);\n\t        }\n\t\n\t        var self = this;\n\t        if (!dimValueGetter) {\n\t            self.hasItemOption = false;\n\t        }\n\t        // Default dim value getter\n\t        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n\t            var value = modelUtil.getDataItemValue(dataItem);\n\t            // If any dataItem is like { value: 10 }\n\t            if (modelUtil.isDataItemOption(dataItem)) {\n\t                self.hasItemOption = true;\n\t            }\n\t            return modelUtil.converDataValue(\n\t                (value instanceof Array)\n\t                    ? value[dimIndex]\n\t                    // If value is a single number or something else not array.\n\t                    : value,\n\t                dimensionInfoMap[dimName]\n\t            );\n\t        };\n\t\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            var dataItem = data[idx];\n\t            // Each data item is value\n\t            // [1, 2]\n\t            // 2\n\t            // Bar chart, line chart which uses category axis\n\t            // only gives the 'y' value. 'x' value is the indices of cateogry\n\t            // Use a tempValue to normalize the value to be a (x, y) value\n\t\n\t            // Store the data by dimensions\n\t            for (var k = 0; k < dimensions.length; k++) {\n\t                var dim = dimensions[k];\n\t                var dimStorage = storage[dim];\n\t                // PENDING NULL is empty or zero\n\t                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n\t            }\n\t\n\t            indices.push(idx);\n\t        }\n\t\n\t        // Use the name in option and create id\n\t        for (var i = 0; i < data.length; i++) {\n\t            if (!nameList[i]) {\n\t                if (data[i] && data[i].name != null) {\n\t                    nameList[i] = data[i].name;\n\t                }\n\t            }\n\t            var name = nameList[i] || '';\n\t            // Try using the id in option\n\t            var id = data[i] && data[i].id;\n\t\n\t            if (!id && name) {\n\t                // Use name as id and add counter to avoid same name\n\t                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n\t                id = name;\n\t                if (nameRepeatCount[name] > 0) {\n\t                    id += '__ec__' + nameRepeatCount[name];\n\t                }\n\t                nameRepeatCount[name]++;\n\t            }\n\t            id && (idList[i] = id);\n\t        }\n\t\n\t        this._nameList = nameList;\n\t        this._idList = idList;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    listProto.count = function () {\n\t        return this.indices.length;\n\t    };\n\t\n\t    /**\n\t     * Get value. Return NaN if idx is out of range.\n\t     * @param {string} dim Dim must be concrete name.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.get = function (dim, idx, stack) {\n\t        var storage = this._storage;\n\t        var dataIndex = this.indices[idx];\n\t\n\t        // If value not exists\n\t        if (dataIndex == null) {\n\t            return NaN;\n\t        }\n\t\n\t        var value = storage[dim] && storage[dim][dataIndex];\n\t        // FIXME ordinal data type is not stackable\n\t        if (stack) {\n\t            var dimensionInfo = this._dimensionInfos[dim];\n\t            if (dimensionInfo && dimensionInfo.stackable) {\n\t                var stackedOn = this.stackedOn;\n\t                while (stackedOn) {\n\t                    // Get no stacked data of stacked on\n\t                    var stackedValue = stackedOn.get(dim, idx);\n\t                    // Considering positive stack, negative stack and empty data\n\t                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n\t                        || (value <= 0 && stackedValue < 0) // Negative stack\n\t                    ) {\n\t                        value += stackedValue;\n\t                    }\n\t                    stackedOn = stackedOn.stackedOn;\n\t                }\n\t            }\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /**\n\t     * Get value for multi dimensions.\n\t     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n\t     * @param {number} idx\n\t     * @param {boolean} stack\n\t     * @return {number}\n\t     */\n\t    listProto.getValues = function (dimensions, idx, stack) {\n\t        var values = [];\n\t\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            stack = idx;\n\t            idx = dimensions;\n\t            dimensions = this.dimensions;\n\t        }\n\t\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            values.push(this.get(dimensions[i], idx, stack));\n\t        }\n\t\n\t        return values;\n\t    };\n\t\n\t    /**\n\t     * If value is NaN. Inlcuding '-'\n\t     * @param {string} dim\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.hasValue = function (idx) {\n\t        var dimensions = this.dimensions;\n\t        var dimensionInfos = this._dimensionInfos;\n\t        for (var i = 0, len = dimensions.length; i < len; i++) {\n\t            if (\n\t                // Ordinal type can be string or number\n\t                dimensionInfos[dimensions[i]].type !== 'ordinal'\n\t                && isNaN(this.get(dimensions[i], idx))\n\t            ) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Get extent of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     * @param {Function} filter\n\t     */\n\t    listProto.getDataExtent = function (dim, stack, filter) {\n\t        dim = this.getDimension(dim);\n\t        var dimData = this._storage[dim];\n\t        var dimInfo = this.getDimensionInfo(dim);\n\t        stack = (dimInfo && dimInfo.stackable) && stack;\n\t        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n\t        var value;\n\t        if (dimExtent) {\n\t            return dimExtent;\n\t        }\n\t        // var dimInfo = this._dimensionInfos[dim];\n\t        if (dimData) {\n\t            var min = Infinity;\n\t            var max = -Infinity;\n\t            // var isOrdinal = dimInfo.type === 'ordinal';\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                value = this.get(dim, i, stack);\n\t                // FIXME\n\t                // if (isOrdinal && typeof value === 'string') {\n\t                //     value = zrUtil.indexOf(dimData, value);\n\t                // }\n\t                if (!filter || filter(value, dim, i)) {\n\t                    value < min && (min = value);\n\t                    value > max && (max = value);\n\t                }\n\t            }\n\t            return (this._extent[dim + !!stack] = [min, max]);\n\t        }\n\t        else {\n\t            return [Infinity, -Infinity];\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Get sum of data in one dimension\n\t     * @param {string} dim\n\t     * @param {boolean} stack\n\t     */\n\t    listProto.getSum = function (dim, stack) {\n\t        var dimData = this._storage[dim];\n\t        var sum = 0;\n\t        if (dimData) {\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var value = this.get(dim, i, stack);\n\t                if (!isNaN(value)) {\n\t                    sum += value;\n\t                }\n\t            }\n\t        }\n\t        return sum;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given value\n\t     * @param {number} idx\n\t     * @param {number} value\n\t     * @return {number}\n\t     */\n\t    // FIXME Precision of float value\n\t    listProto.indexOf = function (dim, value) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t        var indices = this.indices;\n\t\n\t        if (dimData) {\n\t            for (var i = 0, len = indices.length; i < len; i++) {\n\t                var rawIndex = indices[i];\n\t                if (dimData[rawIndex] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given name\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfName = function (name) {\n\t        var indices = this.indices;\n\t        var nameList = this._nameList;\n\t\n\t        for (var i = 0, len = indices.length; i < len; i++) {\n\t            var rawIndex = indices[i];\n\t            if (nameList[rawIndex] === name) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index with given raw data index\n\t     * @param {number} idx\n\t     * @param {number} name\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfRawIndex = function (rawIndex) {\n\t        // Indices are ascending\n\t        var indices = this.indices;\n\t\n\t        // If rawIndex === dataIndex\n\t        var rawDataIndex = indices[rawIndex];\n\t        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n\t            return rawIndex;\n\t        }\n\t\n\t        var left = 0;\n\t        var right = indices.length - 1;\n\t        while (left <= right) {\n\t            var mid = (left + right) / 2 | 0;\n\t            if (indices[mid] < rawIndex) {\n\t                left = mid + 1;\n\t            }\n\t            else if (indices[mid] > rawIndex) {\n\t                right = mid - 1;\n\t            }\n\t            else {\n\t                return mid;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    /**\n\t     * Retreive the index of nearest value\n\t     * @param {string} dim\n\t     * @param {number} value\n\t     * @param {boolean} stack If given value is after stacked\n\t     * @param {number} [maxDistance=Infinity]\n\t     * @return {number}\n\t     */\n\t    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n\t        var storage = this._storage;\n\t        var dimData = storage[dim];\n\t\n\t        if (maxDistance == null) {\n\t            maxDistance = Infinity;\n\t        }\n\t\n\t        var nearestIdx = -1;\n\t        if (dimData) {\n\t            var minDist = Number.MAX_VALUE;\n\t            for (var i = 0, len = this.count(); i < len; i++) {\n\t                var diff = value - this.get(dim, i, stack);\n\t                var dist = Math.abs(diff);\n\t                if (\n\t                    diff <= maxDistance\n\t                    && (dist < minDist\n\t                        // For the case of two data are same on xAxis, which has sequence data.\n\t                        // Show the nearest index\n\t                        // https://github.com/ecomfe/echarts/issues/2869\n\t                        || (dist === minDist && diff > 0)\n\t                    )\n\t                ) {\n\t                    minDist = dist;\n\t                    nearestIdx = i;\n\t                }\n\t            }\n\t        }\n\t        return nearestIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data index\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawIndex = function (idx) {\n\t        var rawIdx = this.indices[idx];\n\t        return rawIdx == null ? -1 : rawIdx;\n\t    };\n\t\n\t    /**\n\t     * Get raw data item\n\t     * @param {number} idx\n\t     * @return {number}\n\t     */\n\t    listProto.getRawDataItem = function (idx) {\n\t        return this._rawData[this.getRawIndex(idx)];\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getName = function (idx) {\n\t        return this._nameList[this.indices[idx]] || '';\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @param {boolean} [notDefaultIdx=false]\n\t     * @return {string}\n\t     */\n\t    listProto.getId = function (idx) {\n\t        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n\t    };\n\t\n\t\n\t    function normalizeDimensions(dimensions) {\n\t        if (!zrUtil.isArray(dimensions)) {\n\t            dimensions = [dimensions];\n\t        }\n\t        return dimensions;\n\t    }\n\t\n\t    /**\n\t     * Data iteration\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     *\n\t     * @example\n\t     *  list.each('x', function (x, idx) {});\n\t     *  list.each(['x', 'y'], function (x, y, idx) {});\n\t     *  list.each(function (idx) {})\n\t     */\n\t    listProto.each = function (dims, cb, stack, context) {\n\t        if (typeof dims === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dims;\n\t            dims = [];\n\t        }\n\t\n\t        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\t\n\t        var value = [];\n\t        var dimSize = dims.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            // Simple optimization\n\t            switch (dimSize) {\n\t                case 0:\n\t                    cb.call(context, i);\n\t                    break;\n\t                case 1:\n\t                    cb.call(context, this.get(dims[0], i, stack), i);\n\t                    break;\n\t                case 2:\n\t                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n\t                    break;\n\t                default:\n\t                    for (var k = 0; k < dimSize; k++) {\n\t                        value[k] = this.get(dims[k], i, stack);\n\t                    }\n\t                    // Index\n\t                    value[k] = i;\n\t                    cb.apply(context, value);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Data filter\n\t     * @param {string|Array.<string>}\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     */\n\t    listProto.filterSelf = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var newIndices = [];\n\t        var value = [];\n\t        var dimSize = dimensions.length;\n\t        var indices = this.indices;\n\t\n\t        context = context || this;\n\t\n\t        for (var i = 0; i < indices.length; i++) {\n\t            var keep;\n\t            // Simple optimization\n\t            if (dimSize === 1) {\n\t                keep = cb.call(\n\t                    context, this.get(dimensions[0], i, stack), i\n\t                );\n\t            }\n\t            else {\n\t                for (var k = 0; k < dimSize; k++) {\n\t                    value[k] = this.get(dimensions[k], i, stack);\n\t                }\n\t                value[k] = i;\n\t                keep = cb.apply(context, value);\n\t            }\n\t            if (keep) {\n\t                newIndices.push(indices[i]);\n\t            }\n\t        }\n\t\n\t        this.indices = newIndices;\n\t\n\t        // Reset data extent\n\t        this._extent = {};\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Data mapping to a plain array\n\t     * @param {string|Array.<string>} [dimensions]\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.mapArray = function (dimensions, cb, stack, context) {\n\t        if (typeof dimensions === 'function') {\n\t            context = stack;\n\t            stack = cb;\n\t            cb = dimensions;\n\t            dimensions = [];\n\t        }\n\t\n\t        var result = [];\n\t        this.each(dimensions, function () {\n\t            result.push(cb && cb.apply(this, arguments));\n\t        }, stack, context);\n\t        return result;\n\t    };\n\t\n\t    function cloneListForMapAndSample(original, excludeDimensions) {\n\t        var allDimensions = original.dimensions;\n\t        var list = new List(\n\t            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n\t            original.hostModel\n\t        );\n\t        // FIXME If needs stackedOn, value may already been stacked\n\t        transferProperties(list, original);\n\t\n\t        var storage = list._storage = {};\n\t        var originalStorage = original._storage;\n\t        // Init storage\n\t        for (var i = 0; i < allDimensions.length; i++) {\n\t            var dim = allDimensions[i];\n\t            var dimStore = originalStorage[dim];\n\t            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n\t                storage[dim] = new dimStore.constructor(\n\t                    originalStorage[dim].length\n\t                );\n\t            }\n\t            else {\n\t                // Direct reference for other dimensions\n\t                storage[dim] = originalStorage[dim];\n\t            }\n\t        }\n\t        return list;\n\t    }\n\t\n\t    /**\n\t     * Data mapping to a new List with given dimensions\n\t     * @param {string|Array.<string>} dimensions\n\t     * @param {Function} cb\n\t     * @param {boolean} [stack=false]\n\t     * @param {*} [context=this]\n\t     * @return {Array}\n\t     */\n\t    listProto.map = function (dimensions, cb, stack, context) {\n\t        dimensions = zrUtil.map(\n\t            normalizeDimensions(dimensions), this.getDimension, this\n\t        );\n\t\n\t        var list = cloneListForMapAndSample(this, dimensions);\n\t        // Following properties are all immutable.\n\t        // So we can reference to the same value\n\t        var indices = list.indices = this.indices;\n\t\n\t        var storage = list._storage;\n\t\n\t        var tmpRetValue = [];\n\t        this.each(dimensions, function () {\n\t            var idx = arguments[arguments.length - 1];\n\t            var retValue = cb && cb.apply(this, arguments);\n\t            if (retValue != null) {\n\t                // a number\n\t                if (typeof retValue === 'number') {\n\t                    tmpRetValue[0] = retValue;\n\t                    retValue = tmpRetValue;\n\t                }\n\t                for (var i = 0; i < retValue.length; i++) {\n\t                    var dim = dimensions[i];\n\t                    var dimStore = storage[dim];\n\t                    var rawIdx = indices[idx];\n\t                    if (dimStore) {\n\t                        dimStore[rawIdx] = retValue[i];\n\t                    }\n\t                }\n\t            }\n\t        }, stack, context);\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Large data down sampling on given dimension\n\t     * @param {string} dimension\n\t     * @param {number} rate\n\t     * @param {Function} sampleValue\n\t     * @param {Function} sampleIndex Sample index for name and id\n\t     */\n\t    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n\t        var list = cloneListForMapAndSample(this, [dimension]);\n\t        var storage = this._storage;\n\t        var targetStorage = list._storage;\n\t\n\t        var originalIndices = this.indices;\n\t        var indices = list.indices = [];\n\t\n\t        var frameValues = [];\n\t        var frameIndices = [];\n\t        var frameSize = Math.floor(1 / rate);\n\t\n\t        var dimStore = targetStorage[dimension];\n\t        var len = this.count();\n\t        // Copy data from original data\n\t        for (var i = 0; i < storage[dimension].length; i++) {\n\t            targetStorage[dimension][i] = storage[dimension][i];\n\t        }\n\t        for (var i = 0; i < len; i += frameSize) {\n\t            // Last frame\n\t            if (frameSize > len - i) {\n\t                frameSize = len - i;\n\t                frameValues.length = frameSize;\n\t            }\n\t            for (var k = 0; k < frameSize; k++) {\n\t                var idx = originalIndices[i + k];\n\t                frameValues[k] = dimStore[idx];\n\t                frameIndices[k] = idx;\n\t            }\n\t            var value = sampleValue(frameValues);\n\t            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n\t            // Only write value on the filtered data\n\t            dimStore[idx] = value;\n\t            indices.push(idx);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Get model of one data item.\n\t     *\n\t     * @param {number} idx\n\t     */\n\t    // FIXME Model proxy ?\n\t    listProto.getItemModel = function (idx) {\n\t        var hostModel = this.hostModel;\n\t        idx = this.indices[idx];\n\t        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n\t    };\n\t\n\t    /**\n\t     * Create a data differ\n\t     * @param {module:echarts/data/List} otherList\n\t     * @return {module:echarts/data/DataDiffer}\n\t     */\n\t    listProto.diff = function (otherList) {\n\t        var idList = this._idList;\n\t        var otherIdList = otherList && otherList._idList;\n\t        var val;\n\t        // Use prefix to avoid index to be the same as otherIdList[idx],\n\t        // which will cause weird udpate animation.\n\t        var prefix = 'e\\0\\0';\n\t\n\t        return new DataDiffer(\n\t            otherList ? otherList.indices : [],\n\t            this.indices,\n\t            function (idx) {\n\t                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n\t            },\n\t            function (idx) {\n\t                return (val = idList[idx]) != null ? val : prefix + idx;\n\t            }\n\t        );\n\t    };\n\t    /**\n\t     * Get visual property.\n\t     * @param {string} key\n\t     */\n\t    listProto.getVisual = function (key) {\n\t        var visual = this._visual;\n\t        return visual && visual[key];\n\t    };\n\t\n\t    /**\n\t     * Set visual property\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setVisual('color', color);\n\t     *  setVisual({\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setVisual = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setVisual(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._visual = this._visual || {};\n\t        this._visual[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Set layout property.\n\t     * @param {string} key\n\t     * @param {*} [val]\n\t     */\n\t    listProto.setLayout = function (key, val) {\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    this.setLayout(name, key[name]);\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        this._layout[key] = val;\n\t    };\n\t\n\t    /**\n\t     * Get layout property.\n\t     * @param  {string} key.\n\t     * @return {*}\n\t     */\n\t    listProto.getLayout = function (key) {\n\t        return this._layout[key];\n\t    };\n\t\n\t    /**\n\t     * Get layout of single data item\n\t     * @param {number} idx\n\t     */\n\t    listProto.getItemLayout = function (idx) {\n\t        return this._itemLayouts[idx];\n\t    };\n\t\n\t    /**\n\t     * Set layout of single data item\n\t     * @param {number} idx\n\t     * @param {Object} layout\n\t     * @param {boolean=} [merge=false]\n\t     */\n\t    listProto.setItemLayout = function (idx, layout, merge) {\n\t        this._itemLayouts[idx] = merge\n\t            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n\t            : layout;\n\t    };\n\t\n\t    /**\n\t     * Clear all layout of single data item\n\t     */\n\t    listProto.clearItemLayouts = function () {\n\t        this._itemLayouts.length = 0;\n\t    };\n\t\n\t    /**\n\t     * Get visual property of single data item\n\t     * @param {number} idx\n\t     * @param {string} key\n\t     * @param {boolean} ignoreParent\n\t     */\n\t    listProto.getItemVisual = function (idx, key, ignoreParent) {\n\t        var itemVisual = this._itemVisuals[idx];\n\t        var val = itemVisual && itemVisual[key];\n\t        if (val == null && !ignoreParent) {\n\t            // Use global visual property\n\t            return this.getVisual(key);\n\t        }\n\t        return val;\n\t    };\n\t\n\t    /**\n\t     * Set visual property of single data item\n\t     *\n\t     * @param {number} idx\n\t     * @param {string|Object} key\n\t     * @param {*} [value]\n\t     *\n\t     * @example\n\t     *  setItemVisual(0, 'color', color);\n\t     *  setItemVisual(0, {\n\t     *      'color': color\n\t     *  });\n\t     */\n\t    listProto.setItemVisual = function (idx, key, value) {\n\t        var itemVisual = this._itemVisuals[idx] || {};\n\t        this._itemVisuals[idx] = itemVisual;\n\t\n\t        if (isObject(key)) {\n\t            for (var name in key) {\n\t                if (key.hasOwnProperty(name)) {\n\t                    itemVisual[name] = key[name];\n\t                }\n\t            }\n\t            return;\n\t        }\n\t        itemVisual[key] = value;\n\t    };\n\t\n\t    /**\n\t     * Clear itemVisuals and list visual.\n\t     */\n\t    listProto.clearAllVisual = function () {\n\t        this._visual = {};\n\t        this._itemVisuals = [];\n\t    };\n\t\n\t    var setItemDataAndSeriesIndex = function (child) {\n\t        child.seriesIndex = this.seriesIndex;\n\t        child.dataIndex = this.dataIndex;\n\t        child.dataType = this.dataType;\n\t    };\n\t    /**\n\t     * Set graphic element relative to data. It can be set as null\n\t     * @param {number} idx\n\t     * @param {module:zrender/Element} [el]\n\t     */\n\t    listProto.setItemGraphicEl = function (idx, el) {\n\t        var hostModel = this.hostModel;\n\t\n\t        if (el) {\n\t            // Add data index and series index for indexing the data by element\n\t            // Useful in tooltip\n\t            el.dataIndex = idx;\n\t            el.dataType = this.dataType;\n\t            el.seriesIndex = hostModel && hostModel.seriesIndex;\n\t            if (el.type === 'group') {\n\t                el.traverse(setItemDataAndSeriesIndex, el);\n\t            }\n\t        }\n\t\n\t        this._graphicEls[idx] = el;\n\t    };\n\t\n\t    /**\n\t     * @param {number} idx\n\t     * @return {module:zrender/Element}\n\t     */\n\t    listProto.getItemGraphicEl = function (idx) {\n\t        return this._graphicEls[idx];\n\t    };\n\t\n\t    /**\n\t     * @param {Function} cb\n\t     * @param {*} context\n\t     */\n\t    listProto.eachItemGraphicEl = function (cb, context) {\n\t        zrUtil.each(this._graphicEls, function (el, idx) {\n\t            if (el) {\n\t                cb && cb.call(context, el, idx);\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Shallow clone a new list except visual and layout properties, and graph elements.\n\t     * New list only change the indices.\n\t     */\n\t    listProto.cloneShallow = function () {\n\t        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n\t        var list = new List(dimensionInfoList, this.hostModel);\n\t\n\t        // FIXME\n\t        list._storage = this._storage;\n\t\n\t        transferProperties(list, this);\n\t\n\t\n\t        // Clone will not change the data extent and indices\n\t        list.indices = this.indices.slice();\n\t\n\t        if (this._extent) {\n\t            list._extent = zrUtil.extend({}, this._extent);\n\t        }\n\t\n\t        return list;\n\t    };\n\t\n\t    /**\n\t     * Wrap some method to add more feature\n\t     * @param {string} methodName\n\t     * @param {Function} injectFunction\n\t     */\n\t    listProto.wrapMethod = function (methodName, injectFunction) {\n\t        var originalMethod = this[methodName];\n\t        if (typeof originalMethod !== 'function') {\n\t            return;\n\t        }\n\t        this.__wrappedMethods = this.__wrappedMethods || [];\n\t        this.__wrappedMethods.push(methodName);\n\t        this[methodName] = function () {\n\t            var res = originalMethod.apply(this, arguments);\n\t            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n\t        };\n\t    };\n\t\n\t    // Methods that create a new list based on this list should be listed here.\n\t    // Notice that those method should `RETURN` the new list.\n\t    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n\t    // Methods that change indices of this list should be listed here.\n\t    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\t\n\t    module.exports = List;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/scale/Interval\n\t */\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(4);\n\t    var formatUtil = __webpack_require__(9);\n\t    var Scale = __webpack_require__(35);\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t\n\t        type: 'interval',\n\t\n\t        _interval: 0,\n\t\n\t        setExtent: function (start, end) {\n\t            var thisExtent = this._extent;\n\t            //start,end may be a Number like '25',so...\n\t            if (!isNaN(start)) {\n\t                thisExtent[0] = parseFloat(start);\n\t            }\n\t            if (!isNaN(end)) {\n\t                thisExtent[1] = parseFloat(end);\n\t            }\n\t        },\n\t\n\t        unionExtent: function (other) {\n\t            var extent = this._extent;\n\t            other[0] < extent[0] && (extent[0] = other[0]);\n\t            other[1] > extent[1] && (extent[1] = other[1]);\n\t\n\t            // unionExtent may called by it's sub classes\n\t            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t        },\n\t        /**\n\t         * Get interval\n\t         */\n\t        getInterval: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            return this._interval;\n\t        },\n\t\n\t        /**\n\t         * Set interval\n\t         */\n\t        setInterval: function (interval) {\n\t            this._interval = interval;\n\t            // Dropped auto calculated niceExtent and use user setted extent\n\t            // We assume user wan't to set both interval, min, max to get a better result\n\t            this._niceExtent = this._extent.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            var interval = this._interval;\n\t            var extent = this._extent;\n\t            var ticks = [];\n\t\n\t            // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t            var safeLimit = 10000;\n\t\n\t            if (interval) {\n\t                var niceExtent = this._niceExtent;\n\t                var precision = getPrecisionSafe(interval) + 2;\n\t\n\t                if (extent[0] < niceExtent[0]) {\n\t                    ticks.push(extent[0]);\n\t                }\n\t                var tick = niceExtent[0];\n\t\n\t                while (tick <= niceExtent[1]) {\n\t                    ticks.push(tick);\n\t                    // Avoid rounding error\n\t                    tick = roundingErrorFix(tick + interval, precision);\n\t                    if (ticks.length > safeLimit) {\n\t                        return [];\n\t                    }\n\t                }\n\t                // Consider this case: the last item of ticks is smaller\n\t                // than niceExtent[1] and niceExtent[1] === extent[1].\n\t                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n\t                    ticks.push(extent[1]);\n\t                }\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<string>}\n\t         */\n\t        getTicksLabels: function () {\n\t            var labels = [];\n\t            var ticks = this.getTicks();\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                labels.push(this.getLabel(ticks[i]));\n\t            }\n\t            return labels;\n\t        },\n\t\n\t        /**\n\t         * @param {number} n\n\t         * @return {number}\n\t         */\n\t        getLabel: function (data) {\n\t            return formatUtil.addCommas(data);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         *\n\t         * @param {number} [splitNumber = 5] Desired number of ticks\n\t         */\n\t        niceTicks: function (splitNumber) {\n\t            splitNumber = splitNumber || 5;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (!isFinite(span)) {\n\t                return;\n\t            }\n\t            // User may set axis min 0 and data are all negative\n\t            // FIXME If it needs to reverse ?\n\t            if (span < 0) {\n\t                span = -span;\n\t                extent.reverse();\n\t            }\n\t\n\t            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t            // var niceSpan = numberUtil.nice(span, false);\n\t            var step = roundingErrorFix(\n\t                numberUtil.nice(span / splitNumber, true),\n\t                Math.max(\n\t                    getPrecisionSafe(extent[0]),\n\t                    getPrecisionSafe(extent[1])\n\t                // extent may be [0, 1], and step should have 1 more digits.\n\t                // To make it safe we add 2 more digits\n\t                ) + 2\n\t            );\n\t\n\t            var precision = getPrecisionSafe(step) + 2;\n\t            // Niced extent inside original extent\n\t            var niceExtent = [\n\t                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t            ];\n\t\n\t            this._interval = step;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [splitNumber = 5] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                if (extent[0] !== 0) {\n\t                    // Expand extent\n\t                    var expandSize = extent[0];\n\t                    // In the fowllowing case\n\t                    //      Axis has been fixed max 100\n\t                    //      Plus data are all 100 and axis extent are [100, 100].\n\t                    // Extend to the both side will cause expanded max is larger than fixed max.\n\t                    // So only expand to the smaller side.\n\t                    if (!fixMax) {\n\t                        extent[1] += expandSize / 2;\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                    else {\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    extent[1] = 1;\n\t                }\n\t            }\n\t            var span = extent[1] - extent[0];\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (!isFinite(span)) {\n\t                extent[0] = 0;\n\t                extent[1] = 1;\n\t            }\n\t\n\t            this.niceTicks(splitNumber);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t\n\t    module.exports = IntervalScale;\n\t\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var clazz = __webpack_require__(15);\n\t\n\t    var parseClassType = clazz.parseClassType;\n\t\n\t    var base = 0;\n\t\n\t    var componentUtil = {};\n\t\n\t    var DELIMITER = '_';\n\t\n\t    /**\n\t     * @public\n\t     * @param {string} type\n\t     * @return {string}\n\t     */\n\t    componentUtil.getUID = function (type) {\n\t        // Considering the case of crossing js context,\n\t        // use Math.random to make id as unique as possible.\n\t        return [(type || ''), base++, Math.random()].join(DELIMITER);\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    componentUtil.enableSubTypeDefaulter = function (entity) {\n\t\n\t        var subTypeDefaulters = {};\n\t\n\t        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n\t            componentType = parseClassType(componentType);\n\t            subTypeDefaulters[componentType.main] = defaulter;\n\t        };\n\t\n\t        entity.determineSubType = function (componentType, option) {\n\t            var type = option.type;\n\t            if (!type) {\n\t                var componentTypeMain = parseClassType(componentType).main;\n\t                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n\t                    type = subTypeDefaulters[componentTypeMain](option);\n\t                }\n\t            }\n\t            return type;\n\t        };\n\t\n\t        return entity;\n\t    };\n\t\n\t    /**\n\t     * Topological travel on Activity Network (Activity On Vertices).\n\t     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n\t     *\n\t     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n\t     *\n\t     * If there is circle dependencey, Error will be thrown.\n\t     *\n\t     */\n\t    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\t\n\t        /**\n\t         * @public\n\t         * @param {Array.<string>} targetNameList Target Component type list.\n\t         *                                           Can be ['aa', 'bb', 'aa.xx']\n\t         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n\t         * @param {Function} callback Params: componentType, dependencies.\n\t         * @param {Object} context Scope of callback.\n\t         */\n\t        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n\t            if (!targetNameList.length) {\n\t                return;\n\t            }\n\t\n\t            var result = makeDepndencyGraph(fullNameList);\n\t            var graph = result.graph;\n\t            var stack = result.noEntryList;\n\t\n\t            var targetNameSet = {};\n\t            zrUtil.each(targetNameList, function (name) {\n\t                targetNameSet[name] = true;\n\t            });\n\t\n\t            while (stack.length) {\n\t                var currComponentType = stack.pop();\n\t                var currVertex = graph[currComponentType];\n\t                var isInTargetNameSet = !!targetNameSet[currComponentType];\n\t                if (isInTargetNameSet) {\n\t                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n\t                    delete targetNameSet[currComponentType];\n\t                }\n\t                zrUtil.each(\n\t                    currVertex.successor,\n\t                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n\t                );\n\t            }\n\t\n\t            zrUtil.each(targetNameSet, function () {\n\t                throw new Error('Circle dependency may exists');\n\t            });\n\t\n\t            function removeEdge(succComponentType) {\n\t                graph[succComponentType].entryCount--;\n\t                if (graph[succComponentType].entryCount === 0) {\n\t                    stack.push(succComponentType);\n\t                }\n\t            }\n\t\n\t            // Consider this case: legend depends on series, and we call\n\t            // chart.setOption({series: [...]}), where only series is in option.\n\t            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n\t            // not be called, but only sereis.mergeOption is called. Thus legend\n\t            // have no chance to update its local record about series (like which\n\t            // name of series is available in legend).\n\t            function removeEdgeAndAdd(succComponentType) {\n\t                targetNameSet[succComponentType] = true;\n\t                removeEdge(succComponentType);\n\t            }\n\t        };\n\t\n\t        /**\n\t         * DepndencyGraph: {Object}\n\t         * key: conponentType,\n\t         * value: {\n\t         *     successor: [conponentTypes...],\n\t         *     originalDeps: [conponentTypes...],\n\t         *     entryCount: {number}\n\t         * }\n\t         */\n\t        function makeDepndencyGraph(fullNameList) {\n\t            var graph = {};\n\t            var noEntryList = [];\n\t\n\t            zrUtil.each(fullNameList, function (name) {\n\t\n\t                var thisItem = createDependencyGraphItem(graph, name);\n\t                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\t\n\t                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n\t                thisItem.entryCount = availableDeps.length;\n\t                if (thisItem.entryCount === 0) {\n\t                    noEntryList.push(name);\n\t                }\n\t\n\t                zrUtil.each(availableDeps, function (dependentName) {\n\t                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n\t                        thisItem.predecessor.push(dependentName);\n\t                    }\n\t                    var thatItem = createDependencyGraphItem(graph, dependentName);\n\t                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n\t                        thatItem.successor.push(name);\n\t                    }\n\t                });\n\t            });\n\t\n\t            return {graph: graph, noEntryList: noEntryList};\n\t        }\n\t\n\t        function createDependencyGraphItem(graph, name) {\n\t            if (!graph[name]) {\n\t                graph[name] = {predecessor: [], successor: []};\n\t            }\n\t            return graph[name];\n\t        }\n\t\n\t        function getAvailableDependencies(originalDeps, fullNameList) {\n\t            var availableDeps = [];\n\t            zrUtil.each(originalDeps, function (dep) {\n\t                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n\t            });\n\t            return availableDeps;\n\t        }\n\t    };\n\t\n\t    module.exports = componentUtil;\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Style = __webpack_require__(95);\n\t\n\t    var Element = __webpack_require__(87);\n\t    var RectText = __webpack_require__(225);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable Painter \n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * zlevelcanvas\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * \n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * \n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * \n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         *  x, y \n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         *  x, y \n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * \n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * \n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO,  bind \n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*!\n\t * Vue.js v2.1.10\n\t * (c) 2014-2017 Evan You\n\t * Released under the MIT License.\n\t */\n\t'use strict';\n\t\n\t/*  */\n\t\n\t/**\n\t * Convert a value to a string that is actually rendered.\n\t */\n\tfunction _toString (val) {\n\t  return val == null\n\t    ? ''\n\t    : typeof val === 'object'\n\t      ? JSON.stringify(val, null, 2)\n\t      : String(val)\n\t}\n\t\n\t/**\n\t * Convert a input value to a number for persistence.\n\t * If the conversion fails, return original string.\n\t */\n\tfunction toNumber (val) {\n\t  var n = parseFloat(val);\n\t  return isNaN(n) ? val : n\n\t}\n\t\n\t/**\n\t * Make a map and return a function for checking if a key\n\t * is in that map.\n\t */\n\tfunction makeMap (\n\t  str,\n\t  expectsLowerCase\n\t) {\n\t  var map = Object.create(null);\n\t  var list = str.split(',');\n\t  for (var i = 0; i < list.length; i++) {\n\t    map[list[i]] = true;\n\t  }\n\t  return expectsLowerCase\n\t    ? function (val) { return map[val.toLowerCase()]; }\n\t    : function (val) { return map[val]; }\n\t}\n\t\n\t/**\n\t * Check if a tag is a built-in tag.\n\t */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\t\n\t/**\n\t * Remove an item from an array\n\t */\n\tfunction remove$1 (arr, item) {\n\t  if (arr.length) {\n\t    var index = arr.indexOf(item);\n\t    if (index > -1) {\n\t      return arr.splice(index, 1)\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether the object has the property.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn (obj, key) {\n\t  return hasOwnProperty.call(obj, key)\n\t}\n\t\n\t/**\n\t * Check if value is primitive\n\t */\n\tfunction isPrimitive (value) {\n\t  return typeof value === 'string' || typeof value === 'number'\n\t}\n\t\n\t/**\n\t * Create a cached version of a pure function.\n\t */\n\tfunction cached (fn) {\n\t  var cache = Object.create(null);\n\t  return (function cachedFn (str) {\n\t    var hit = cache[str];\n\t    return hit || (cache[str] = fn(str))\n\t  })\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delimited string.\n\t */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n\t});\n\t\n\t/**\n\t * Capitalize a string.\n\t */\n\tvar capitalize = cached(function (str) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1)\n\t});\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t  return str\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .toLowerCase()\n\t});\n\t\n\t/**\n\t * Simple bind, faster than native\n\t */\n\tfunction bind$1 (fn, ctx) {\n\t  function boundFn (a) {\n\t    var l = arguments.length;\n\t    return l\n\t      ? l > 1\n\t        ? fn.apply(ctx, arguments)\n\t        : fn.call(ctx, a)\n\t      : fn.call(ctx)\n\t  }\n\t  // record original fn length\n\t  boundFn._length = fn.length;\n\t  return boundFn\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t */\n\tfunction toArray (list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t */\n\tfunction extend (to, _from) {\n\t  for (var key in _from) {\n\t    to[key] = _from[key];\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t */\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t */\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\tfunction isPlainObject (obj) {\n\t  return toString.call(obj) === OBJECT_STRING\n\t}\n\t\n\t/**\n\t * Merge an Array of Objects into a single Object.\n\t */\n\tfunction toObject (arr) {\n\t  var res = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (arr[i]) {\n\t      extend(res, arr[i]);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/**\n\t * Perform no operation.\n\t */\n\tfunction noop () {}\n\t\n\t/**\n\t * Always return false.\n\t */\n\tvar no = function () { return false; };\n\t\n\t/**\n\t * Return same value\n\t */\n\tvar identity = function (_) { return _; };\n\t\n\t/**\n\t * Generate a static keys string from compiler modules.\n\t */\n\tfunction genStaticKeys (modules) {\n\t  return modules.reduce(function (keys, m) {\n\t    return keys.concat(m.staticKeys || [])\n\t  }, []).join(',')\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t */\n\tfunction looseEqual (a, b) {\n\t  var isObjectA = isObject(a);\n\t  var isObjectB = isObject(b);\n\t  if (isObjectA && isObjectB) {\n\t    return JSON.stringify(a) === JSON.stringify(b)\n\t  } else if (!isObjectA && !isObjectB) {\n\t    return String(a) === String(b)\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction looseIndexOf (arr, val) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (looseEqual(arr[i], val)) { return i }\n\t  }\n\t  return -1\n\t}\n\t\n\t/*  */\n\t\n\tvar config = {\n\t  /**\n\t   * Option merge strategies (used in core/util/options)\n\t   */\n\t  optionMergeStrategies: Object.create(null),\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to enable devtools\n\t   */\n\t  devtools: (\"production\") !== 'production',\n\t\n\t  /**\n\t   * Error handler for watcher errors\n\t   */\n\t  errorHandler: null,\n\t\n\t  /**\n\t   * Ignore certain custom elements\n\t   */\n\t  ignoredElements: [],\n\t\n\t  /**\n\t   * Custom user key aliases for v-on\n\t   */\n\t  keyCodes: Object.create(null),\n\t\n\t  /**\n\t   * Check if a tag is reserved so that it cannot be registered as a\n\t   * component. This is platform-dependent and may be overwritten.\n\t   */\n\t  isReservedTag: no,\n\t\n\t  /**\n\t   * Check if a tag is an unknown element.\n\t   * Platform-dependent.\n\t   */\n\t  isUnknownElement: no,\n\t\n\t  /**\n\t   * Get the namespace of an element\n\t   */\n\t  getTagNamespace: noop,\n\t\n\t  /**\n\t   * Parse the real tag name for the specific platform.\n\t   */\n\t  parsePlatformTagName: identity,\n\t\n\t  /**\n\t   * Check if an attribute must be bound using property, e.g. value\n\t   * Platform-dependent.\n\t   */\n\t  mustUseProp: no,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   */\n\t  _assetTypes: [\n\t    'component',\n\t    'directive',\n\t    'filter'\n\t  ],\n\t\n\t  /**\n\t   * List of lifecycle hooks.\n\t   */\n\t  _lifecycleHooks: [\n\t    'beforeCreate',\n\t    'created',\n\t    'beforeMount',\n\t    'mounted',\n\t    'beforeUpdate',\n\t    'updated',\n\t    'beforeDestroy',\n\t    'destroyed',\n\t    'activated',\n\t    'deactivated'\n\t  ],\n\t\n\t  /**\n\t   * Max circular updates allowed in a scheduler flush cycle.\n\t   */\n\t  _maxUpdateCount: 100\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t */\n\tfunction isReserved (str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F\n\t}\n\t\n\t/**\n\t * Define a property.\n\t */\n\tfunction def (obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Parse simple path.\n\t */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath (path) {\n\t  if (bailRE.test(path)) {\n\t    return\n\t  } else {\n\t    var segments = path.split('.');\n\t    return function (obj) {\n\t      for (var i = 0; i < segments.length; i++) {\n\t        if (!obj) { return }\n\t        obj = obj[segments[i]];\n\t      }\n\t      return obj\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t/* globals MutationObserver */\n\t\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\t\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\t\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function () {\n\t  if (_isServer === undefined) {\n\t    /* istanbul ignore if */\n\t    if (!inBrowser && typeof global !== 'undefined') {\n\t      // detect presence of vue-server-renderer and avoid\n\t      // Webpack shimming the process\n\t      _isServer = global['process'].env.VUE_ENV === 'server';\n\t    } else {\n\t      _isServer = false;\n\t    }\n\t  }\n\t  return _isServer\n\t};\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t/* istanbul ignore next */\n\tfunction isNative (Ctor) {\n\t  return /native code/.test(Ctor.toString())\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously.\n\t */\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t\n\t  function nextTickHandler () {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks.length = 0;\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  // the nextTick behavior leverages the microtask queue, which can be accessed\n\t  // via either native Promise.then or MutationObserver.\n\t  // MutationObserver has wider support, however it is seriously bugged in\n\t  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t  // completely stops working after triggering a few times... so, if native\n\t  // Promise is available, we will use it:\n\t  /* istanbul ignore if */\n\t  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t    var p = Promise.resolve();\n\t    var logError = function (err) { console.error(err); };\n\t    timerFunc = function () {\n\t      p.then(nextTickHandler).catch(logError);\n\t      // in problematic UIWebViews, Promise.then doesn't completely break, but\n\t      // it can get stuck in a weird state where callbacks are pushed into the\n\t      // microtask queue but the queue isn't being flushed, until the browser\n\t      // needs to do some other work, e.g. handle a timer. Therefore we can\n\t      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\t      if (isIOS) { setTimeout(noop); }\n\t    };\n\t  } else if (typeof MutationObserver !== 'undefined' && (\n\t    isNative(MutationObserver) ||\n\t    // PhantomJS and iOS 7.x\n\t    MutationObserver.toString() === '[object MutationObserverConstructor]'\n\t  )) {\n\t    // use MutationObserver where native Promise is not available,\n\t    // e.g. PhantomJS IE11, iOS7, Android 4.4\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(String(counter));\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = String(counter);\n\t    };\n\t  } else {\n\t    // fallback to setTimeout\n\t    /* istanbul ignore next */\n\t    timerFunc = function () {\n\t      setTimeout(nextTickHandler, 0);\n\t    };\n\t  }\n\t\n\t  return function queueNextTick (cb, ctx) {\n\t    var _resolve;\n\t    callbacks.push(function () {\n\t      if (cb) { cb.call(ctx); }\n\t      if (_resolve) { _resolve(ctx); }\n\t    });\n\t    if (!pending) {\n\t      pending = true;\n\t      timerFunc();\n\t    }\n\t    if (!cb && typeof Promise !== 'undefined') {\n\t      return new Promise(function (resolve) {\n\t        _resolve = resolve;\n\t      })\n\t    }\n\t  }\n\t})();\n\t\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = (function () {\n\t    function Set () {\n\t      this.set = Object.create(null);\n\t    }\n\t    Set.prototype.has = function has (key) {\n\t      return this.set[key] === true\n\t    };\n\t    Set.prototype.add = function add (key) {\n\t      this.set[key] = true;\n\t    };\n\t    Set.prototype.clear = function clear () {\n\t      this.set = Object.create(null);\n\t    };\n\t\n\t    return Set;\n\t  }());\n\t}\n\t\n\tvar warn = noop;\n\tvar formatComponentName;\n\t\n\tif (false) {\n\t  var hasConsole = typeof console !== 'undefined';\n\t\n\t  warn = function (msg, vm) {\n\t    if (hasConsole && (!config.silent)) {\n\t      console.error(\"[Vue warn]: \" + msg + \" \" + (\n\t        vm ? formatLocation(formatComponentName(vm)) : ''\n\t      ));\n\t    }\n\t  };\n\t\n\t  formatComponentName = function (vm) {\n\t    if (vm.$root === vm) {\n\t      return 'root instance'\n\t    }\n\t    var name = vm._isVue\n\t      ? vm.$options.name || vm.$options._componentTag\n\t      : vm.name;\n\t    return (\n\t      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n\t      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n\t    )\n\t  };\n\t\n\t  var formatLocation = function (str) {\n\t    if (str === 'anonymous component') {\n\t      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n\t    }\n\t    return (\"\\n(found in \" + str + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t */\n\tvar Dep = function Dep () {\n\t  this.id = uid$1++;\n\t  this.subs = [];\n\t};\n\t\n\tDep.prototype.addSub = function addSub (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\tDep.prototype.removeSub = function removeSub (sub) {\n\t  remove$1(this.subs, sub);\n\t};\n\t\n\tDep.prototype.depend = function depend () {\n\t  if (Dep.target) {\n\t    Dep.target.addDep(this);\n\t  }\n\t};\n\t\n\tDep.prototype.notify = function notify () {\n\t  // stablize the subscriber list first\n\t  var subs = this.subs.slice();\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\t\n\tfunction pushTarget (_target) {\n\t  if (Dep.target) { targetStack.push(Dep.target); }\n\t  Dep.target = _target;\n\t}\n\t\n\tfunction popTarget () {\n\t  Dep.target = targetStack.pop();\n\t}\n\t\n\t/*\n\t * not type checking this file because flow doesn't play well with\n\t * dynamically accessing methods on Array prototype\n\t */\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);[\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t]\n\t.forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator () {\n\t    var arguments$1 = arguments;\n\t\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments$1[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break\n\t      case 'unshift':\n\t        inserted = args;\n\t        break\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break\n\t    }\n\t    if (inserted) { ob.observeArray(inserted); }\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result\n\t  });\n\t});\n\t\n\t/*  */\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However when passing down props,\n\t * we don't want to force conversion because the value may be a nested value\n\t * under a frozen data structure. Converting it would defeat the optimization.\n\t */\n\tvar observerState = {\n\t  shouldConvert: true,\n\t  isSettingProps: false\n\t};\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t */\n\tvar Observer = function Observer (value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  this.vmCount = 0;\n\t  def(value, '__ob__', this);\n\t  if (Array.isArray(value)) {\n\t    var augment = hasProto\n\t      ? protoAugment\n\t      : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t};\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t */\n\tObserver.prototype.walk = function walk (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t */\n\tObserver.prototype.observeArray = function observeArray (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t */\n\tfunction protoAugment (target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t */\n\t/* istanbul ignore next */\n\tfunction copyAugment (target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t */\n\tfunction observe (value, asRootData) {\n\t  if (!isObject(value)) {\n\t    return\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (\n\t    observerState.shouldConvert &&\n\t    !isServerRendering() &&\n\t    (Array.isArray(value) || isPlainObject(value)) &&\n\t    Object.isExtensible(value) &&\n\t    !value._isVue\n\t  ) {\n\t    ob = new Observer(value);\n\t  }\n\t  if (asRootData && ob) {\n\t    ob.vmCount++;\n\t  }\n\t  return ob\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t */\n\tfunction defineReactive$$1 (\n\t  obj,\n\t  key,\n\t  val,\n\t  customSetter\n\t) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter () {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (Array.isArray(value)) {\n\t          dependArray(value);\n\t        }\n\t      }\n\t      return value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      /* eslint-disable no-self-compare */\n\t      if (newVal === value || (newVal !== newVal && value !== value)) {\n\t        return\n\t      }\n\t      /* eslint-enable no-self-compare */\n\t      if (false) {\n\t        customSetter();\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Set a property on an object. Adds the new property and\n\t * triggers change notification if the property doesn't\n\t * already exist.\n\t */\n\tfunction set$1 (obj, key, val) {\n\t  if (Array.isArray(obj)) {\n\t    obj.length = Math.max(obj.length, key);\n\t    obj.splice(key, 1, val);\n\t    return val\n\t  }\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n\t      'at runtime - declare it upfront in the data option.'\n\t    );\n\t    return\n\t  }\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  defineReactive$$1(ob.value, key, val);\n\t  ob.dep.notify();\n\t  return val\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t */\n\tfunction del (obj, key) {\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Avoid deleting properties on a Vue instance or its root $data ' +\n\t      '- just set it to null.'\n\t    );\n\t    return\n\t  }\n\t  if (!hasOwn(obj, key)) {\n\t    return\n\t  }\n\t  delete obj[key];\n\t  if (!ob) {\n\t    return\n\t  }\n\t  ob.dep.notify();\n\t}\n\t\n\t/**\n\t * Collect dependencies on array elements when the array is touched, since\n\t * we cannot intercept array element access like property getters.\n\t */\n\tfunction dependArray (value) {\n\t  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n\t    e = value[i];\n\t    e && e.__ob__ && e.__ob__.dep.depend();\n\t    if (Array.isArray(e)) {\n\t      dependArray(e);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t */\n\tvar strats = config.optionMergeStrategies;\n\t\n\t/**\n\t * Options with restrictions\n\t */\n\tif (false) {\n\t  strats.el = strats.propsData = function (parent, child, vm, key) {\n\t    if (!vm) {\n\t      warn(\n\t        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n\t        'creation with the `new` keyword.'\n\t      );\n\t    }\n\t    return defaultStrat(parent, child)\n\t  };\n\t}\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\tfunction mergeData (to, from) {\n\t  if (!from) { return to }\n\t  var key, toVal, fromVal;\n\t  var keys = Object.keys(from);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    key = keys[i];\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set$1(to, key, fromVal);\n\t    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\tstrats.data = function (\n\t  parentVal,\n\t  childVal,\n\t  vm\n\t) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      (\"production\") !== 'production' && warn(\n\t        'The \"data\" option should be a function ' +\n\t        'that returns a per-instance value in component ' +\n\t        'definitions.',\n\t        vm\n\t      );\n\t      return parentVal\n\t    }\n\t    if (!parentVal) {\n\t      return childVal\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn () {\n\t      return mergeData(\n\t        childVal.call(this),\n\t        parentVal.call(this)\n\t      )\n\t    }\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn () {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function'\n\t        ? childVal.call(vm)\n\t        : childVal;\n\t      var defaultData = typeof parentVal === 'function'\n\t        ? parentVal.call(vm)\n\t        : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData)\n\t      } else {\n\t        return defaultData\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\tfunction mergeHook (\n\t  parentVal,\n\t  childVal\n\t) {\n\t  return childVal\n\t    ? parentVal\n\t      ? parentVal.concat(childVal)\n\t      : Array.isArray(childVal)\n\t        ? childVal\n\t        : [childVal]\n\t    : parentVal\n\t}\n\t\n\tconfig._lifecycleHooks.forEach(function (hook) {\n\t  strats[hook] = mergeHook;\n\t});\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\tfunction mergeAssets (parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal\n\t    ? extend(res, childVal)\n\t    : res\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Watchers.\n\t *\n\t * Watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\tstrats.watch = function (parentVal, childVal) {\n\t  /* istanbul ignore if */\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !Array.isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent\n\t      ? parent.concat(child)\n\t      : [child];\n\t  }\n\t  return ret\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\tstrats.props =\n\tstrats.methods =\n\tstrats.computed = function (parentVal, childVal) {\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\tvar defaultStrat = function (parentVal, childVal) {\n\t  return childVal === undefined\n\t    ? parentVal\n\t    : childVal\n\t};\n\t\n\t/**\n\t * Validate component names\n\t */\n\tfunction checkComponents (options) {\n\t  for (var key in options.components) {\n\t    var lower = key.toLowerCase();\n\t    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t      warn(\n\t        'Do not use built-in or reserved HTML elements as component ' +\n\t        'id: ' + key\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t */\n\tfunction normalizeProps (options) {\n\t  var props = options.props;\n\t  if (!props) { return }\n\t  var res = {};\n\t  var i, val, name;\n\t  if (Array.isArray(props)) {\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        name = camelize(val);\n\t        res[name] = { type: null };\n\t      } else if (false) {\n\t        warn('props must be strings when using array syntax.');\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    for (var key in props) {\n\t      val = props[key];\n\t      name = camelize(key);\n\t      res[name] = isPlainObject(val)\n\t        ? val\n\t        : { type: val };\n\t    }\n\t  }\n\t  options.props = res;\n\t}\n\t\n\t/**\n\t * Normalize raw function directives into object format.\n\t */\n\tfunction normalizeDirectives (options) {\n\t  var dirs = options.directives;\n\t  if (dirs) {\n\t    for (var key in dirs) {\n\t      var def = dirs[key];\n\t      if (typeof def === 'function') {\n\t        dirs[key] = { bind: def, update: def };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t */\n\tfunction mergeOptions (\n\t  parent,\n\t  child,\n\t  vm\n\t) {\n\t  if (false) {\n\t    checkComponents(child);\n\t  }\n\t  normalizeProps(child);\n\t  normalizeDirectives(child);\n\t  var extendsFrom = child.extends;\n\t  if (extendsFrom) {\n\t    parent = typeof extendsFrom === 'function'\n\t      ? mergeOptions(parent, extendsFrom.options, vm)\n\t      : mergeOptions(parent, extendsFrom, vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      if (mixin.prototype instanceof Vue$3) {\n\t        mixin = mixin.options;\n\t      }\n\t      parent = mergeOptions(parent, mixin, vm);\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField (key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t */\n\tfunction resolveAsset (\n\t  options,\n\t  type,\n\t  id,\n\t  warnMissing\n\t) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return\n\t  }\n\t  var assets = options[type];\n\t  // check local registration variations first\n\t  if (hasOwn(assets, id)) { return assets[id] }\n\t  var camelizedId = camelize(id);\n\t  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n\t  var PascalCaseId = capitalize(camelizedId);\n\t  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n\t  // fallback to prototype chain\n\t  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t  if (false) {\n\t    warn(\n\t      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n\t      options\n\t    );\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction validateProp (\n\t  key,\n\t  propOptions,\n\t  propsData,\n\t  vm\n\t) {\n\t  var prop = propOptions[key];\n\t  var absent = !hasOwn(propsData, key);\n\t  var value = propsData[key];\n\t  // handle boolean props\n\t  if (isType(Boolean, prop.type)) {\n\t    if (absent && !hasOwn(prop, 'default')) {\n\t      value = false;\n\t    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t      value = true;\n\t    }\n\t  }\n\t  // check default value\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop, key);\n\t    // since the default value is a fresh copy,\n\t    // make sure to observe it.\n\t    var prevShouldConvert = observerState.shouldConvert;\n\t    observerState.shouldConvert = true;\n\t    observe(value);\n\t    observerState.shouldConvert = prevShouldConvert;\n\t  }\n\t  if (false) {\n\t    assertProp(prop, key, value, vm, absent);\n\t  }\n\t  return value\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t */\n\tfunction getPropDefaultValue (vm, prop, key) {\n\t  // no default, return undefined\n\t  if (!hasOwn(prop, 'default')) {\n\t    return undefined\n\t  }\n\t  var def = prop.default;\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    (\"production\") !== 'production' && warn(\n\t      'Invalid default value for prop \"' + key + '\": ' +\n\t      'Props with type Object/Array must use a factory function ' +\n\t      'to return the default value.',\n\t      vm\n\t    );\n\t  }\n\t  // the raw prop value was also undefined from previous render,\n\t  // return previous default value to avoid unnecessary watcher trigger\n\t  if (vm && vm.$options.propsData &&\n\t    vm.$options.propsData[key] === undefined &&\n\t    vm[key] !== undefined) {\n\t    return vm[key]\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && prop.type !== Function\n\t    ? def.call(vm)\n\t    : def\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t */\n\tfunction assertProp (\n\t  prop,\n\t  name,\n\t  value,\n\t  vm,\n\t  absent\n\t) {\n\t  if (prop.required && absent) {\n\t    warn(\n\t      'Missing required prop: \"' + name + '\"',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  if (value == null && !prop.required) {\n\t    return\n\t  }\n\t  var type = prop.type;\n\t  var valid = !type || type === true;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!Array.isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType || '');\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    warn(\n\t      'Invalid prop: type check failed for prop \"' + name + '\".' +\n\t      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n\t      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var validator = prop.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      warn(\n\t        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t */\n\tfunction assertType (value, type) {\n\t  var valid;\n\t  var expectedType = getType(type);\n\t  if (expectedType === 'String') {\n\t    valid = typeof value === (expectedType = 'string');\n\t  } else if (expectedType === 'Number') {\n\t    valid = typeof value === (expectedType = 'number');\n\t  } else if (expectedType === 'Boolean') {\n\t    valid = typeof value === (expectedType = 'boolean');\n\t  } else if (expectedType === 'Function') {\n\t    valid = typeof value === (expectedType = 'function');\n\t  } else if (expectedType === 'Object') {\n\t    valid = isPlainObject(value);\n\t  } else if (expectedType === 'Array') {\n\t    valid = Array.isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  }\n\t}\n\t\n\t/**\n\t * Use function string name to check built-in types,\n\t * because a simple equality check will fail when running\n\t * across different vms / iframes.\n\t */\n\tfunction getType (fn) {\n\t  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t  return match && match[1]\n\t}\n\t\n\tfunction isType (type, fn) {\n\t  if (!Array.isArray(fn)) {\n\t    return getType(fn) === getType(type)\n\t  }\n\t  for (var i = 0, len = fn.length; i < len; i++) {\n\t    if (getType(fn[i]) === getType(type)) {\n\t      return true\n\t    }\n\t  }\n\t  /* istanbul ignore next */\n\t  return false\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive$$1,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\tmakeMap: makeMap,\n\t\tisBuiltInTag: isBuiltInTag,\n\t\tremove: remove$1,\n\t\thasOwn: hasOwn,\n\t\tisPrimitive: isPrimitive,\n\t\tcached: cached,\n\t\tcamelize: camelize,\n\t\tcapitalize: capitalize,\n\t\thyphenate: hyphenate,\n\t\tbind: bind$1,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\ttoObject: toObject,\n\t\tnoop: noop,\n\t\tno: no,\n\t\tidentity: identity,\n\t\tgenStaticKeys: genStaticKeys,\n\t\tlooseEqual: looseEqual,\n\t\tlooseIndexOf: looseIndexOf,\n\t\tisReserved: isReserved,\n\t\tdef: def,\n\t\tparsePath: parsePath,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tUA: UA,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisEdge: isEdge,\n\t\tisAndroid: isAndroid,\n\t\tisIOS: isIOS,\n\t\tisServerRendering: isServerRendering,\n\t\tdevtools: devtools,\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tget warn () { return warn; },\n\t\tget formatComponentName () { return formatComponentName; },\n\t\tvalidateProp: validateProp\n\t});\n\t\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\t\n\tvar initProxy;\n\t\n\tif (false) {\n\t  var allowedGlobals = makeMap(\n\t    'Infinity,undefined,NaN,isFinite,isNaN,' +\n\t    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n\t    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n\t    'require' // for Webpack/Browserify\n\t  );\n\t\n\t  var warnNonPresent = function (target, key) {\n\t    warn(\n\t      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n\t      \"referenced during render. Make sure to declare reactive data \" +\n\t      \"properties in the data option.\",\n\t      target\n\t    );\n\t  };\n\t\n\t  var hasProxy =\n\t    typeof Proxy !== 'undefined' &&\n\t    Proxy.toString().match(/native code/);\n\t\n\t  if (hasProxy) {\n\t    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n\t    config.keyCodes = new Proxy(config.keyCodes, {\n\t      set: function set (target, key, value) {\n\t        if (isBuiltInModifier(key)) {\n\t          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n\t          return false\n\t        } else {\n\t          target[key] = value;\n\t          return true\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  var hasHandler = {\n\t    has: function has (target, key) {\n\t      var has = key in target;\n\t      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t      if (!has && !isAllowed) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return has || !isAllowed\n\t    }\n\t  };\n\t\n\t  var getHandler = {\n\t    get: function get (target, key) {\n\t      if (typeof key === 'string' && !(key in target)) {\n\t        warnNonPresent(target, key);\n\t      }\n\t      return target[key]\n\t    }\n\t  };\n\t\n\t  initProxy = function initProxy (vm) {\n\t    if (hasProxy) {\n\t      // determine which proxy handler to use\n\t      var options = vm.$options;\n\t      var handlers = options.render && options.render._withStripped\n\t        ? getHandler\n\t        : hasHandler;\n\t      vm._renderProxy = new Proxy(vm, handlers);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar VNode = function VNode (\n\t  tag,\n\t  data,\n\t  children,\n\t  text,\n\t  elm,\n\t  context,\n\t  componentOptions\n\t) {\n\t  this.tag = tag;\n\t  this.data = data;\n\t  this.children = children;\n\t  this.text = text;\n\t  this.elm = elm;\n\t  this.ns = undefined;\n\t  this.context = context;\n\t  this.functionalContext = undefined;\n\t  this.key = data && data.key;\n\t  this.componentOptions = componentOptions;\n\t  this.componentInstance = undefined;\n\t  this.parent = undefined;\n\t  this.raw = false;\n\t  this.isStatic = false;\n\t  this.isRootInsert = true;\n\t  this.isComment = false;\n\t  this.isCloned = false;\n\t  this.isOnce = false;\n\t};\n\t\n\tvar prototypeAccessors = { child: {} };\n\t\n\t// DEPRECATED: alias for componentInstance for backwards compat.\n\t/* istanbul ignore next */\n\tprototypeAccessors.child.get = function () {\n\t  return this.componentInstance\n\t};\n\t\n\tObject.defineProperties( VNode.prototype, prototypeAccessors );\n\t\n\tvar createEmptyVNode = function () {\n\t  var node = new VNode();\n\t  node.text = '';\n\t  node.isComment = true;\n\t  return node\n\t};\n\t\n\tfunction createTextVNode (val) {\n\t  return new VNode(undefined, undefined, undefined, String(val))\n\t}\n\t\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode (vnode) {\n\t  var cloned = new VNode(\n\t    vnode.tag,\n\t    vnode.data,\n\t    vnode.children,\n\t    vnode.text,\n\t    vnode.elm,\n\t    vnode.context,\n\t    vnode.componentOptions\n\t  );\n\t  cloned.ns = vnode.ns;\n\t  cloned.isStatic = vnode.isStatic;\n\t  cloned.key = vnode.key;\n\t  cloned.isCloned = true;\n\t  return cloned\n\t}\n\t\n\tfunction cloneVNodes (vnodes) {\n\t  var res = new Array(vnodes.length);\n\t  for (var i = 0; i < vnodes.length; i++) {\n\t    res[i] = cloneVNode(vnodes[i]);\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\n\tvar hooksToMerge = Object.keys(hooks);\n\t\n\tfunction createComponent (\n\t  Ctor,\n\t  data,\n\t  context,\n\t  children,\n\t  tag\n\t) {\n\t  if (!Ctor) {\n\t    return\n\t  }\n\t\n\t  var baseCtor = context.$options._base;\n\t  if (isObject(Ctor)) {\n\t    Ctor = baseCtor.extend(Ctor);\n\t  }\n\t\n\t  if (typeof Ctor !== 'function') {\n\t    if (false) {\n\t      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n\t    }\n\t    return\n\t  }\n\t\n\t  // async component\n\t  if (!Ctor.cid) {\n\t    if (Ctor.resolved) {\n\t      Ctor = Ctor.resolved;\n\t    } else {\n\t      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n\t        // it's ok to queue this on every render because\n\t        // $forceUpdate is buffered by the scheduler.\n\t        context.$forceUpdate();\n\t      });\n\t      if (!Ctor) {\n\t        // return nothing if this is indeed an async component\n\t        // wait for the callback to trigger parent update.\n\t        return\n\t      }\n\t    }\n\t  }\n\t\n\t  // resolve constructor options in case global mixins are applied after\n\t  // component constructor creation\n\t  resolveConstructorOptions(Ctor);\n\t\n\t  data = data || {};\n\t\n\t  // extract props\n\t  var propsData = extractProps(data, Ctor);\n\t\n\t  // functional component\n\t  if (Ctor.options.functional) {\n\t    return createFunctionalComponent(Ctor, propsData, data, context, children)\n\t  }\n\t\n\t  // extract listeners, since these needs to be treated as\n\t  // child component listeners instead of DOM listeners\n\t  var listeners = data.on;\n\t  // replace with listeners with .native modifier\n\t  data.on = data.nativeOn;\n\t\n\t  if (Ctor.options.abstract) {\n\t    // abstract components do not keep anything\n\t    // other than props & listeners\n\t    data = {};\n\t  }\n\t\n\t  // merge component management hooks onto the placeholder node\n\t  mergeHooks(data);\n\t\n\t  // return a placeholder vnode\n\t  var name = Ctor.options.name || tag;\n\t  var vnode = new VNode(\n\t    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n\t    data, undefined, undefined, undefined, context,\n\t    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n\t  );\n\t  return vnode\n\t}\n\t\n\tfunction createFunctionalComponent (\n\t  Ctor,\n\t  propsData,\n\t  data,\n\t  context,\n\t  children\n\t) {\n\t  var props = {};\n\t  var propOptions = Ctor.options.props;\n\t  if (propOptions) {\n\t    for (var key in propOptions) {\n\t      props[key] = validateProp(key, propOptions, propsData);\n\t    }\n\t  }\n\t  // ensure the createElement function in functional components\n\t  // gets a unique context - this is necessary for correct named slot check\n\t  var _context = Object.create(context);\n\t  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n\t  var vnode = Ctor.options.render.call(null, h, {\n\t    props: props,\n\t    data: data,\n\t    parent: context,\n\t    children: children,\n\t    slots: function () { return resolveSlots(children, context); }\n\t  });\n\t  if (vnode instanceof VNode) {\n\t    vnode.functionalContext = context;\n\t    if (data.slot) {\n\t      (vnode.data || (vnode.data = {})).slot = data.slot;\n\t    }\n\t  }\n\t  return vnode\n\t}\n\t\n\tfunction createComponentInstanceForVnode (\n\t  vnode, // we know it's MountedComponentVNode but flow doesn't\n\t  parent, // activeInstance in lifecycle state\n\t  parentElm,\n\t  refElm\n\t) {\n\t  var vnodeComponentOptions = vnode.componentOptions;\n\t  var options = {\n\t    _isComponent: true,\n\t    parent: parent,\n\t    propsData: vnodeComponentOptions.propsData,\n\t    _componentTag: vnodeComponentOptions.tag,\n\t    _parentVnode: vnode,\n\t    _parentListeners: vnodeComponentOptions.listeners,\n\t    _renderChildren: vnodeComponentOptions.children,\n\t    _parentElm: parentElm || null,\n\t    _refElm: refElm || null\n\t  };\n\t  // check inline-template render functions\n\t  var inlineTemplate = vnode.data.inlineTemplate;\n\t  if (inlineTemplate) {\n\t    options.render = inlineTemplate.render;\n\t    options.staticRenderFns = inlineTemplate.staticRenderFns;\n\t  }\n\t  return new vnodeComponentOptions.Ctor(options)\n\t}\n\t\n\tfunction init (\n\t  vnode,\n\t  hydrating,\n\t  parentElm,\n\t  refElm\n\t) {\n\t  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n\t    var child = vnode.componentInstance = createComponentInstanceForVnode(\n\t      vnode,\n\t      activeInstance,\n\t      parentElm,\n\t      refElm\n\t    );\n\t    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t  } else if (vnode.data.keepAlive) {\n\t    // kept-alive components, treat as a patch\n\t    var mountedNode = vnode; // work around flow\n\t    prepatch(mountedNode, mountedNode);\n\t  }\n\t}\n\t\n\tfunction prepatch (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  var options = vnode.componentOptions;\n\t  var child = vnode.componentInstance = oldVnode.componentInstance;\n\t  child._updateFromParent(\n\t    options.propsData, // updated props\n\t    options.listeners, // updated listeners\n\t    vnode, // new parent vnode\n\t    options.children // new children\n\t  );\n\t}\n\t\n\tfunction insert (vnode) {\n\t  if (!vnode.componentInstance._isMounted) {\n\t    vnode.componentInstance._isMounted = true;\n\t    callHook(vnode.componentInstance, 'mounted');\n\t  }\n\t  if (vnode.data.keepAlive) {\n\t    vnode.componentInstance._inactive = false;\n\t    callHook(vnode.componentInstance, 'activated');\n\t  }\n\t}\n\t\n\tfunction destroy$1 (vnode) {\n\t  if (!vnode.componentInstance._isDestroyed) {\n\t    if (!vnode.data.keepAlive) {\n\t      vnode.componentInstance.$destroy();\n\t    } else {\n\t      vnode.componentInstance._inactive = true;\n\t      callHook(vnode.componentInstance, 'deactivated');\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponent (\n\t  factory,\n\t  baseCtor,\n\t  cb\n\t) {\n\t  if (factory.requested) {\n\t    // pool callbacks\n\t    factory.pendingCallbacks.push(cb);\n\t  } else {\n\t    factory.requested = true;\n\t    var cbs = factory.pendingCallbacks = [cb];\n\t    var sync = true;\n\t\n\t    var resolve = function (res) {\n\t      if (isObject(res)) {\n\t        res = baseCtor.extend(res);\n\t      }\n\t      // cache resolved\n\t      factory.resolved = res;\n\t      // invoke callbacks only if this is not a synchronous resolve\n\t      // (async resolves are shimmed as synchronous during SSR)\n\t      if (!sync) {\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          cbs[i](res);\n\t        }\n\t      }\n\t    };\n\t\n\t    var reject = function (reason) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed to resolve async component: \" + (String(factory)) +\n\t        (reason ? (\"\\nReason: \" + reason) : '')\n\t      );\n\t    };\n\t\n\t    var res = factory(resolve, reject);\n\t\n\t    // handle promise\n\t    if (res && typeof res.then === 'function' && !factory.resolved) {\n\t      res.then(resolve, reject);\n\t    }\n\t\n\t    sync = false;\n\t    // return in case resolved synchronously\n\t    return factory.resolved\n\t  }\n\t}\n\t\n\tfunction extractProps (data, Ctor) {\n\t  // we are only extracting raw values here.\n\t  // validation and default values are handled in the child\n\t  // component itself.\n\t  var propOptions = Ctor.options.props;\n\t  if (!propOptions) {\n\t    return\n\t  }\n\t  var res = {};\n\t  var attrs = data.attrs;\n\t  var props = data.props;\n\t  var domProps = data.domProps;\n\t  if (attrs || props || domProps) {\n\t    for (var key in propOptions) {\n\t      var altKey = hyphenate(key);\n\t      checkProp(res, props, key, altKey, true) ||\n\t      checkProp(res, attrs, key, altKey) ||\n\t      checkProp(res, domProps, key, altKey);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkProp (\n\t  res,\n\t  hash,\n\t  key,\n\t  altKey,\n\t  preserve\n\t) {\n\t  if (hash) {\n\t    if (hasOwn(hash, key)) {\n\t      res[key] = hash[key];\n\t      if (!preserve) {\n\t        delete hash[key];\n\t      }\n\t      return true\n\t    } else if (hasOwn(hash, altKey)) {\n\t      res[key] = hash[altKey];\n\t      if (!preserve) {\n\t        delete hash[altKey];\n\t      }\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mergeHooks (data) {\n\t  if (!data.hook) {\n\t    data.hook = {};\n\t  }\n\t  for (var i = 0; i < hooksToMerge.length; i++) {\n\t    var key = hooksToMerge[i];\n\t    var fromParent = data.hook[key];\n\t    var ours = hooks[key];\n\t    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t  }\n\t}\n\t\n\tfunction mergeHook$1 (one, two) {\n\t  return function (a, b, c, d) {\n\t    one(a, b, c, d);\n\t    two(a, b, c, d);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction mergeVNodeHook (def, hookKey, hook, key) {\n\t  key = key + hookKey;\n\t  var injectedHash = def.__injected || (def.__injected = {});\n\t  if (!injectedHash[key]) {\n\t    injectedHash[key] = true;\n\t    var oldHook = def[hookKey];\n\t    if (oldHook) {\n\t      def[hookKey] = function () {\n\t        oldHook.apply(this, arguments);\n\t        hook.apply(this, arguments);\n\t      };\n\t    } else {\n\t      def[hookKey] = hook;\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar normalizeEvent = cached(function (name) {\n\t  var once = name.charAt(0) === '~'; // Prefixed last, checked first\n\t  name = once ? name.slice(1) : name;\n\t  var capture = name.charAt(0) === '!';\n\t  name = capture ? name.slice(1) : name;\n\t  return {\n\t    name: name,\n\t    once: once,\n\t    capture: capture\n\t  }\n\t});\n\t\n\tfunction createEventHandle (fn) {\n\t  var handle = {\n\t    fn: fn,\n\t    invoker: function () {\n\t      var arguments$1 = arguments;\n\t\n\t      var fn = handle.fn;\n\t      if (Array.isArray(fn)) {\n\t        for (var i = 0; i < fn.length; i++) {\n\t          fn[i].apply(null, arguments$1);\n\t        }\n\t      } else {\n\t        fn.apply(null, arguments);\n\t      }\n\t    }\n\t  };\n\t  return handle\n\t}\n\t\n\tfunction updateListeners (\n\t  on,\n\t  oldOn,\n\t  add,\n\t  remove$$1,\n\t  vm\n\t) {\n\t  var name, cur, old, event;\n\t  for (name in on) {\n\t    cur = on[name];\n\t    old = oldOn[name];\n\t    event = normalizeEvent(name);\n\t    if (!cur) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n\t        vm\n\t      );\n\t    } else if (!old) {\n\t      if (!cur.invoker) {\n\t        cur = on[name] = createEventHandle(cur);\n\t      }\n\t      add(event.name, cur.invoker, event.once, event.capture);\n\t    } else if (cur !== old) {\n\t      old.fn = cur;\n\t      on[name] = old;\n\t    }\n\t  }\n\t  for (name in oldOn) {\n\t    if (!on[name]) {\n\t      event = normalizeEvent(name);\n\t      remove$$1(event.name, oldOn[name].invoker, event.capture);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\t\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// nomralization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren (children) {\n\t  for (var i = 0; i < children.length; i++) {\n\t    if (Array.isArray(children[i])) {\n\t      return Array.prototype.concat.apply([], children)\n\t    }\n\t  }\n\t  return children\n\t}\n\t\n\t// 2. When the children contains constrcuts that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren (children) {\n\t  return isPrimitive(children)\n\t    ? [createTextVNode(children)]\n\t    : Array.isArray(children)\n\t      ? normalizeArrayChildren(children)\n\t      : undefined\n\t}\n\t\n\tfunction normalizeArrayChildren (children, nestedIndex) {\n\t  var res = [];\n\t  var i, c, last;\n\t  for (i = 0; i < children.length; i++) {\n\t    c = children[i];\n\t    if (c == null || typeof c === 'boolean') { continue }\n\t    last = res[res.length - 1];\n\t    //  nested\n\t    if (Array.isArray(c)) {\n\t      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n\t    } else if (isPrimitive(c)) {\n\t      if (last && last.text) {\n\t        last.text += String(c);\n\t      } else if (c !== '') {\n\t        // convert primitive to vnode\n\t        res.push(createTextVNode(c));\n\t      }\n\t    } else {\n\t      if (c.text && last && last.text) {\n\t        res[res.length - 1] = createTextVNode(last.text + c.text);\n\t      } else {\n\t        // default key for nested array children (likely generated by v-for)\n\t        if (c.tag && c.key == null && nestedIndex != null) {\n\t          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t        }\n\t        res.push(c);\n\t      }\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction getFirstComponentChild (children) {\n\t  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n\t}\n\t\n\t/*  */\n\t\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\t\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType,\n\t  alwaysNormalize\n\t) {\n\t  if (Array.isArray(data) || isPrimitive(data)) {\n\t    normalizationType = children;\n\t    children = data;\n\t    data = undefined;\n\t  }\n\t  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n\t  return _createElement(context, tag, data, children, normalizationType)\n\t}\n\t\n\tfunction _createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children,\n\t  normalizationType\n\t) {\n\t  if (data && data.__ob__) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n\t      'Always create fresh vnode data objects in each render!',\n\t      context\n\t    );\n\t    return createEmptyVNode()\n\t  }\n\t  if (!tag) {\n\t    // in case of component :is set to falsy value\n\t    return createEmptyVNode()\n\t  }\n\t  // support single function children as default scoped slot\n\t  if (Array.isArray(children) &&\n\t      typeof children[0] === 'function') {\n\t    data = data || {};\n\t    data.scopedSlots = { default: children[0] };\n\t    children.length = 0;\n\t  }\n\t  if (normalizationType === ALWAYS_NORMALIZE) {\n\t    children = normalizeChildren(children);\n\t  } else if (normalizationType === SIMPLE_NORMALIZE) {\n\t    children = simpleNormalizeChildren(children);\n\t  }\n\t  var vnode, ns;\n\t  if (typeof tag === 'string') {\n\t    var Ctor;\n\t    ns = config.getTagNamespace(tag);\n\t    if (config.isReservedTag(tag)) {\n\t      // platform built-in elements\n\t      vnode = new VNode(\n\t        config.parsePlatformTagName(tag), data, children,\n\t        undefined, undefined, context\n\t      );\n\t    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t      // component\n\t      vnode = createComponent(Ctor, data, context, children, tag);\n\t    } else {\n\t      // unknown or unlisted namespaced elements\n\t      // check at runtime because it may get assigned a namespace when its\n\t      // parent normalizes children\n\t      vnode = new VNode(\n\t        tag, data, children,\n\t        undefined, undefined, context\n\t      );\n\t    }\n\t  } else {\n\t    // direct component options / constructor\n\t    vnode = createComponent(tag, data, context, children);\n\t  }\n\t  if (vnode) {\n\t    if (ns) { applyNS(vnode, ns); }\n\t    return vnode\n\t  } else {\n\t    return createEmptyVNode()\n\t  }\n\t}\n\t\n\tfunction applyNS (vnode, ns) {\n\t  vnode.ns = ns;\n\t  if (vnode.tag === 'foreignObject') {\n\t    // use default namespace inside foreignObject\n\t    return\n\t  }\n\t  if (vnode.children) {\n\t    for (var i = 0, l = vnode.children.length; i < l; i++) {\n\t      var child = vnode.children[i];\n\t      if (child.tag && !child.ns) {\n\t        applyNS(child, ns);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initRender (vm) {\n\t  vm.$vnode = null; // the placeholder node in parent tree\n\t  vm._vnode = null; // the root of the child tree\n\t  vm._staticTrees = null;\n\t  var parentVnode = vm.$options._parentVnode;\n\t  var renderContext = parentVnode && parentVnode.context;\n\t  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t  vm.$scopedSlots = {};\n\t  // bind the createElement fn to this instance\n\t  // so that we get proper render context inside it.\n\t  // args order: tag, data, children, normalizationType, alwaysNormalize\n\t  // internal version is used by render functions compiled from templates\n\t  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n\t  // normalization is always applied for the public version, used in\n\t  // user-written render functions.\n\t  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\t}\n\t\n\tfunction renderMixin (Vue) {\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    return nextTick(fn, this)\n\t  };\n\t\n\t  Vue.prototype._render = function () {\n\t    var vm = this;\n\t    var ref = vm.$options;\n\t    var render = ref.render;\n\t    var staticRenderFns = ref.staticRenderFns;\n\t    var _parentVnode = ref._parentVnode;\n\t\n\t    if (vm._isMounted) {\n\t      // clone slot nodes on re-renders\n\t      for (var key in vm.$slots) {\n\t        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t      }\n\t    }\n\t\n\t    if (_parentVnode && _parentVnode.data.scopedSlots) {\n\t      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n\t    }\n\t\n\t    if (staticRenderFns && !vm._staticTrees) {\n\t      vm._staticTrees = [];\n\t    }\n\t    // set parent vnode. this allows render functions to have access\n\t    // to the data on the placeholder node.\n\t    vm.$vnode = _parentVnode;\n\t    // render self\n\t    var vnode;\n\t    try {\n\t      vnode = render.call(vm._renderProxy, vm.$createElement);\n\t    } catch (e) {\n\t      /* istanbul ignore else */\n\t      if (config.errorHandler) {\n\t        config.errorHandler.call(null, e, vm);\n\t      } else {\n\t        if (false) {\n\t          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n\t        }\n\t        throw e\n\t      }\n\t      // return previous vnode to prevent render error causing blank component\n\t      vnode = vm._vnode;\n\t    }\n\t    // return empty vnode in case the render function errored out\n\t    if (!(vnode instanceof VNode)) {\n\t      if (false) {\n\t        warn(\n\t          'Multiple root nodes returned from render function. Render function ' +\n\t          'should return a single root node.',\n\t          vm\n\t        );\n\t      }\n\t      vnode = createEmptyVNode();\n\t    }\n\t    // set parent\n\t    vnode.parent = _parentVnode;\n\t    return vnode\n\t  };\n\t\n\t  // toString for mustaches\n\t  Vue.prototype._s = _toString;\n\t  // convert text to vnode\n\t  Vue.prototype._v = createTextVNode;\n\t  // number conversion\n\t  Vue.prototype._n = toNumber;\n\t  // empty vnode\n\t  Vue.prototype._e = createEmptyVNode;\n\t  // loose equal\n\t  Vue.prototype._q = looseEqual;\n\t  // loose indexOf\n\t  Vue.prototype._i = looseIndexOf;\n\t\n\t  // render static tree by index\n\t  Vue.prototype._m = function renderStatic (\n\t    index,\n\t    isInFor\n\t  ) {\n\t    var tree = this._staticTrees[index];\n\t    // if has already-rendered static tree and not inside v-for,\n\t    // we can reuse the same tree by doing a shallow clone.\n\t    if (tree && !isInFor) {\n\t      return Array.isArray(tree)\n\t        ? cloneVNodes(tree)\n\t        : cloneVNode(tree)\n\t    }\n\t    // otherwise, render a fresh tree.\n\t    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t    markStatic(tree, (\"__static__\" + index), false);\n\t    return tree\n\t  };\n\t\n\t  // mark node as static (v-once)\n\t  Vue.prototype._o = function markOnce (\n\t    tree,\n\t    index,\n\t    key\n\t  ) {\n\t    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n\t    return tree\n\t  };\n\t\n\t  function markStatic (tree, key, isOnce) {\n\t    if (Array.isArray(tree)) {\n\t      for (var i = 0; i < tree.length; i++) {\n\t        if (tree[i] && typeof tree[i] !== 'string') {\n\t          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n\t        }\n\t      }\n\t    } else {\n\t      markStaticNode(tree, key, isOnce);\n\t    }\n\t  }\n\t\n\t  function markStaticNode (node, key, isOnce) {\n\t    node.isStatic = true;\n\t    node.key = key;\n\t    node.isOnce = isOnce;\n\t  }\n\t\n\t  // filter resolution helper\n\t  Vue.prototype._f = function resolveFilter (id) {\n\t    return resolveAsset(this.$options, 'filters', id, true) || identity\n\t  };\n\t\n\t  // render v-for\n\t  Vue.prototype._l = function renderList (\n\t    val,\n\t    render\n\t  ) {\n\t    var ret, i, l, keys, key;\n\t    if (Array.isArray(val) || typeof val === 'string') {\n\t      ret = new Array(val.length);\n\t      for (i = 0, l = val.length; i < l; i++) {\n\t        ret[i] = render(val[i], i);\n\t      }\n\t    } else if (typeof val === 'number') {\n\t      ret = new Array(val);\n\t      for (i = 0; i < val; i++) {\n\t        ret[i] = render(i + 1, i);\n\t      }\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      ret = new Array(keys.length);\n\t      for (i = 0, l = keys.length; i < l; i++) {\n\t        key = keys[i];\n\t        ret[i] = render(val[key], key, i);\n\t      }\n\t    }\n\t    return ret\n\t  };\n\t\n\t  // renderSlot\n\t  Vue.prototype._t = function (\n\t    name,\n\t    fallback,\n\t    props,\n\t    bindObject\n\t  ) {\n\t    var scopedSlotFn = this.$scopedSlots[name];\n\t    if (scopedSlotFn) { // scoped slot\n\t      props = props || {};\n\t      if (bindObject) {\n\t        extend(props, bindObject);\n\t      }\n\t      return scopedSlotFn(props) || fallback\n\t    } else {\n\t      var slotNodes = this.$slots[name];\n\t      // warn duplicate slot usage\n\t      if (slotNodes && (\"production\") !== 'production') {\n\t        slotNodes._rendered && warn(\n\t          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n\t          \"- this will likely cause render errors.\",\n\t          this\n\t        );\n\t        slotNodes._rendered = true;\n\t      }\n\t      return slotNodes || fallback\n\t    }\n\t  };\n\t\n\t  // apply v-bind object\n\t  Vue.prototype._b = function bindProps (\n\t    data,\n\t    tag,\n\t    value,\n\t    asProp\n\t  ) {\n\t    if (value) {\n\t      if (!isObject(value)) {\n\t        (\"production\") !== 'production' && warn(\n\t          'v-bind without argument expects an Object or Array value',\n\t          this\n\t        );\n\t      } else {\n\t        if (Array.isArray(value)) {\n\t          value = toObject(value);\n\t        }\n\t        for (var key in value) {\n\t          if (key === 'class' || key === 'style') {\n\t            data[key] = value[key];\n\t          } else {\n\t            var type = data.attrs && data.attrs.type;\n\t            var hash = asProp || config.mustUseProp(tag, type, key)\n\t              ? data.domProps || (data.domProps = {})\n\t              : data.attrs || (data.attrs = {});\n\t            hash[key] = value[key];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return data\n\t  };\n\t\n\t  // check v-on keyCodes\n\t  Vue.prototype._k = function checkKeyCodes (\n\t    eventKeyCode,\n\t    key,\n\t    builtInAlias\n\t  ) {\n\t    var keyCodes = config.keyCodes[key] || builtInAlias;\n\t    if (Array.isArray(keyCodes)) {\n\t      return keyCodes.indexOf(eventKeyCode) === -1\n\t    } else {\n\t      return keyCodes !== eventKeyCode\n\t    }\n\t  };\n\t}\n\t\n\tfunction resolveSlots (\n\t  children,\n\t  context\n\t) {\n\t  var slots = {};\n\t  if (!children) {\n\t    return slots\n\t  }\n\t  var defaultSlot = [];\n\t  var name, child;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    child = children[i];\n\t    // named slots should only be respected if the vnode was rendered in the\n\t    // same context.\n\t    if ((child.context === context || child.functionalContext === context) &&\n\t        child.data && (name = child.data.slot)) {\n\t      var slot = (slots[name] || (slots[name] = []));\n\t      if (child.tag === 'template') {\n\t        slot.push.apply(slot, child.children);\n\t      } else {\n\t        slot.push(child);\n\t      }\n\t    } else {\n\t      defaultSlot.push(child);\n\t    }\n\t  }\n\t  // ignore single whitespace\n\t  if (defaultSlot.length && !(\n\t    defaultSlot.length === 1 &&\n\t    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n\t  )) {\n\t    slots.default = defaultSlot;\n\t  }\n\t  return slots\n\t}\n\t\n\t/*  */\n\t\n\tfunction initEvents (vm) {\n\t  vm._events = Object.create(null);\n\t  vm._hasHookEvent = false;\n\t  // init parent attached events\n\t  var listeners = vm.$options._parentListeners;\n\t  if (listeners) {\n\t    updateComponentListeners(vm, listeners);\n\t  }\n\t}\n\t\n\tvar target;\n\t\n\tfunction add$1 (event, fn, once) {\n\t  if (once) {\n\t    target.$once(event, fn);\n\t  } else {\n\t    target.$on(event, fn);\n\t  }\n\t}\n\t\n\tfunction remove$2 (event, fn) {\n\t  target.$off(event, fn);\n\t}\n\t\n\tfunction updateComponentListeners (\n\t  vm,\n\t  listeners,\n\t  oldListeners\n\t) {\n\t  target = vm;\n\t  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n\t}\n\t\n\tfunction eventsMixin (Vue) {\n\t  var hookRE = /^hook:/;\n\t  Vue.prototype.$on = function (event, fn) {\n\t    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t    // optimize hook:event cost by using a boolean flag marked at registration\n\t    // instead of a hash lookup\n\t    if (hookRE.test(event)) {\n\t      vm._hasHookEvent = true;\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var vm = this;\n\t    function on () {\n\t      vm.$off(event, on);\n\t      fn.apply(vm, arguments);\n\t    }\n\t    on.fn = fn;\n\t    vm.$on(event, on);\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var vm = this;\n\t    // all\n\t    if (!arguments.length) {\n\t      vm._events = Object.create(null);\n\t      return vm\n\t    }\n\t    // specific event\n\t    var cbs = vm._events[event];\n\t    if (!cbs) {\n\t      return vm\n\t    }\n\t    if (arguments.length === 1) {\n\t      vm._events[event] = null;\n\t      return vm\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        cbs.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var vm = this;\n\t    var cbs = vm._events[event];\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        cbs[i].apply(vm, args);\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar activeInstance = null;\n\t\n\tfunction initLifecycle (vm) {\n\t  var options = vm.$options;\n\t\n\t  // locate first non-abstract parent\n\t  var parent = options.parent;\n\t  if (parent && !options.abstract) {\n\t    while (parent.$options.abstract && parent.$parent) {\n\t      parent = parent.$parent;\n\t    }\n\t    parent.$children.push(vm);\n\t  }\n\t\n\t  vm.$parent = parent;\n\t  vm.$root = parent ? parent.$root : vm;\n\t\n\t  vm.$children = [];\n\t  vm.$refs = {};\n\t\n\t  vm._watcher = null;\n\t  vm._inactive = false;\n\t  vm._isMounted = false;\n\t  vm._isDestroyed = false;\n\t  vm._isBeingDestroyed = false;\n\t}\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  Vue.prototype._mount = function (\n\t    el,\n\t    hydrating\n\t  ) {\n\t    var vm = this;\n\t    vm.$el = el;\n\t    if (!vm.$options.render) {\n\t      vm.$options.render = createEmptyVNode;\n\t      if (false) {\n\t        /* istanbul ignore if */\n\t        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n\t          warn(\n\t            'You are using the runtime-only build of Vue where the template ' +\n\t            'option is not available. Either pre-compile the templates into ' +\n\t            'render functions, or use the compiler-included build.',\n\t            vm\n\t          );\n\t        } else {\n\t          warn(\n\t            'Failed to mount component: template or render function not defined.',\n\t            vm\n\t          );\n\t        }\n\t      }\n\t    }\n\t    callHook(vm, 'beforeMount');\n\t    vm._watcher = new Watcher(vm, function updateComponent () {\n\t      vm._update(vm._render(), hydrating);\n\t    }, noop);\n\t    hydrating = false;\n\t    // manually mounted instance, call mounted on self\n\t    // mounted is called for render-created child components in its inserted hook\n\t    if (vm.$vnode == null) {\n\t      vm._isMounted = true;\n\t      callHook(vm, 'mounted');\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype._update = function (vnode, hydrating) {\n\t    var vm = this;\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'beforeUpdate');\n\t    }\n\t    var prevEl = vm.$el;\n\t    var prevVnode = vm._vnode;\n\t    var prevActiveInstance = activeInstance;\n\t    activeInstance = vm;\n\t    vm._vnode = vnode;\n\t    // Vue.prototype.__patch__ is injected in entry points\n\t    // based on the rendering backend used.\n\t    if (!prevVnode) {\n\t      // initial render\n\t      vm.$el = vm.__patch__(\n\t        vm.$el, vnode, hydrating, false /* removeOnly */,\n\t        vm.$options._parentElm,\n\t        vm.$options._refElm\n\t      );\n\t    } else {\n\t      // updates\n\t      vm.$el = vm.__patch__(prevVnode, vnode);\n\t    }\n\t    activeInstance = prevActiveInstance;\n\t    // update __vue__ reference\n\t    if (prevEl) {\n\t      prevEl.__vue__ = null;\n\t    }\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = vm;\n\t    }\n\t    // if parent is an HOC, update its $el as well\n\t    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t      vm.$parent.$el = vm.$el;\n\t    }\n\t    // updated hook is called by the scheduler to ensure that children are\n\t    // updated in a parent's updated hook.\n\t  };\n\t\n\t  Vue.prototype._updateFromParent = function (\n\t    propsData,\n\t    listeners,\n\t    parentVnode,\n\t    renderChildren\n\t  ) {\n\t    var vm = this;\n\t    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n\t    vm.$options._parentVnode = parentVnode;\n\t    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t    if (vm._vnode) { // update child tree's parent\n\t      vm._vnode.parent = parentVnode;\n\t    }\n\t    vm.$options._renderChildren = renderChildren;\n\t    // update props\n\t    if (propsData && vm.$options.props) {\n\t      observerState.shouldConvert = false;\n\t      if (false) {\n\t        observerState.isSettingProps = true;\n\t      }\n\t      var propKeys = vm.$options._propKeys || [];\n\t      for (var i = 0; i < propKeys.length; i++) {\n\t        var key = propKeys[i];\n\t        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t      }\n\t      observerState.shouldConvert = true;\n\t      if (false) {\n\t        observerState.isSettingProps = false;\n\t      }\n\t      vm.$options.propsData = propsData;\n\t    }\n\t    // update listeners\n\t    if (listeners) {\n\t      var oldListeners = vm.$options._parentListeners;\n\t      vm.$options._parentListeners = listeners;\n\t      updateComponentListeners(vm, listeners, oldListeners);\n\t    }\n\t    // resolve slots + force update if has children\n\t    if (hasChildren) {\n\t      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t      vm.$forceUpdate();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$forceUpdate = function () {\n\t    var vm = this;\n\t    if (vm._watcher) {\n\t      vm._watcher.update();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$destroy = function () {\n\t    var vm = this;\n\t    if (vm._isBeingDestroyed) {\n\t      return\n\t    }\n\t    callHook(vm, 'beforeDestroy');\n\t    vm._isBeingDestroyed = true;\n\t    // remove self from parent\n\t    var parent = vm.$parent;\n\t    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t      remove$1(parent.$children, vm);\n\t    }\n\t    // teardown watchers\n\t    if (vm._watcher) {\n\t      vm._watcher.teardown();\n\t    }\n\t    var i = vm._watchers.length;\n\t    while (i--) {\n\t      vm._watchers[i].teardown();\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (vm._data.__ob__) {\n\t      vm._data.__ob__.vmCount--;\n\t    }\n\t    // call the last hook...\n\t    vm._isDestroyed = true;\n\t    callHook(vm, 'destroyed');\n\t    // turn off all instance listeners.\n\t    vm.$off();\n\t    // remove __vue__ reference\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = null;\n\t    }\n\t    // invoke destroy hooks on current rendered tree\n\t    vm.__patch__(vm._vnode, null);\n\t  };\n\t}\n\t\n\tfunction callHook (vm, hook) {\n\t  var handlers = vm.$options[hook];\n\t  if (handlers) {\n\t    for (var i = 0, j = handlers.length; i < j; i++) {\n\t      handlers[i].call(vm);\n\t    }\n\t  }\n\t  if (vm._hasHookEvent) {\n\t    vm.$emit('hook:' + hook);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar queue = [];\n\tvar has$1 = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\t\n\t/**\n\t * Reset the scheduler's state.\n\t */\n\tfunction resetSchedulerState () {\n\t  queue.length = 0;\n\t  has$1 = {};\n\t  if (false) {\n\t    circular = {};\n\t  }\n\t  waiting = flushing = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\tfunction flushSchedulerQueue () {\n\t  flushing = true;\n\t  var watcher, id, vm;\n\t\n\t  // Sort queue before flush.\n\t  // This ensures that:\n\t  // 1. Components are updated from parent to child. (because parent is always\n\t  //    created before the child)\n\t  // 2. A component's user watchers are run before its render watcher (because\n\t  //    user watchers are created before the render watcher)\n\t  // 3. If a component is destroyed during a parent component's watcher run,\n\t  //    its watchers can be skipped.\n\t  queue.sort(function (a, b) { return a.id - b.id; });\n\t\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (index = 0; index < queue.length; index++) {\n\t    watcher = queue[index];\n\t    id = watcher.id;\n\t    has$1[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (false) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn(\n\t          'You may have an infinite update loop ' + (\n\t            watcher.user\n\t              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n\t              : \"in a component render function.\"\n\t          ),\n\t          watcher.vm\n\t        );\n\t        break\n\t      }\n\t    }\n\t  }\n\t\n\t  // call updated hooks\n\t  index = queue.length;\n\t  while (index--) {\n\t    watcher = queue[index];\n\t    vm = watcher.vm;\n\t    if (vm._watcher === watcher && vm._isMounted) {\n\t      callHook(vm, 'updated');\n\t    }\n\t  }\n\t\n\t  // devtool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\t\n\t  resetSchedulerState();\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t */\n\tfunction queueWatcher (watcher) {\n\t  var id = watcher.id;\n\t  if (has$1[id] == null) {\n\t    has$1[id] = true;\n\t    if (!flushing) {\n\t      queue.push(watcher);\n\t    } else {\n\t      // if already flushing, splice the watcher based on its id\n\t      // if already past its id, it will be run next immediately.\n\t      var i = queue.length - 1;\n\t      while (i >= 0 && queue[i].id > watcher.id) {\n\t        i--;\n\t      }\n\t      queue.splice(Math.max(i, index) + 1, 0, watcher);\n\t    }\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushSchedulerQueue);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t */\n\tvar Watcher = function Watcher (\n\t  vm,\n\t  expOrFn,\n\t  cb,\n\t  options\n\t) {\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  // options\n\t  if (options) {\n\t    this.deep = !!options.deep;\n\t    this.user = !!options.user;\n\t    this.lazy = !!options.lazy;\n\t    this.sync = !!options.sync;\n\t  } else {\n\t    this.deep = this.user = this.lazy = this.sync = false;\n\t  }\n\t  this.cb = cb;\n\t  this.id = ++uid$2; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  this.expression =  false\n\t    ? expOrFn.toString()\n\t    : '';\n\t  // parse expression for getter\n\t  if (typeof expOrFn === 'function') {\n\t    this.getter = expOrFn;\n\t  } else {\n\t    this.getter = parsePath(expOrFn);\n\t    if (!this.getter) {\n\t      this.getter = function () {};\n\t      (\"production\") !== 'production' && warn(\n\t        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n\t        'Watcher only accepts simple dot-delimited paths. ' +\n\t        'For full control, use a function instead.',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  this.value = this.lazy\n\t    ? undefined\n\t    : this.get();\n\t};\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\tWatcher.prototype.get = function get () {\n\t  pushTarget(this);\n\t  var value = this.getter.call(this.vm, this.vm);\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  popTarget();\n\t  this.cleanupDeps();\n\t  return value\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t */\n\tWatcher.prototype.addDep = function addDep (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this$1.deps[i];\n\t    if (!this$1.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this$1);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t */\n\tWatcher.prototype.update = function update () {\n\t  /* istanbul ignore else */\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync) {\n\t    this.run();\n\t  } else {\n\t    queueWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Scheduler job interface.\n\t * Will be called by the scheduler.\n\t */\n\tWatcher.prototype.run = function run () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t    if (\n\t      value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated.\n\t      isObject(value) ||\n\t      this.deep\n\t    ) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      if (this.user) {\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          /* istanbul ignore else */\n\t          if (config.errorHandler) {\n\t            config.errorHandler.call(null, e, this.vm);\n\t          } else {\n\t            (\"production\") !== 'production' && warn(\n\t              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n\t              this.vm\n\t            );\n\t            throw e\n\t          }\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\tWatcher.prototype.evaluate = function evaluate () {\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\tWatcher.prototype.depend = function depend () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this$1.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subscriber list.\n\t */\n\tWatcher.prototype.teardown = function teardown () {\n\t    var this$1 = this;\n\t\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed.\n\t    if (!this.vm._isBeingDestroyed) {\n\t      remove$1(this.vm._watchers, this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this$1.deps[i].removeSub(this$1);\n\t    }\n\t    this.active = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Recursively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t */\n\tvar seenObjects = new _Set();\n\tfunction traverse (val) {\n\t  seenObjects.clear();\n\t  _traverse(val, seenObjects);\n\t}\n\t\n\tfunction _traverse (val, seen) {\n\t  var i, keys;\n\t  var isA = Array.isArray(val);\n\t  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n\t    return\n\t  }\n\t  if (val.__ob__) {\n\t    var depId = val.__ob__.dep.id;\n\t    if (seen.has(depId)) {\n\t      return\n\t    }\n\t    seen.add(depId);\n\t  }\n\t  if (isA) {\n\t    i = val.length;\n\t    while (i--) { _traverse(val[i], seen); }\n\t  } else {\n\t    keys = Object.keys(val);\n\t    i = keys.length;\n\t    while (i--) { _traverse(val[keys[i]], seen); }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initState (vm) {\n\t  vm._watchers = [];\n\t  var opts = vm.$options;\n\t  if (opts.props) { initProps(vm, opts.props); }\n\t  if (opts.methods) { initMethods(vm, opts.methods); }\n\t  if (opts.data) {\n\t    initData(vm);\n\t  } else {\n\t    observe(vm._data = {}, true /* asRootData */);\n\t  }\n\t  if (opts.computed) { initComputed(vm, opts.computed); }\n\t  if (opts.watch) { initWatch(vm, opts.watch); }\n\t}\n\t\n\tvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\t\n\tfunction initProps (vm, props) {\n\t  var propsData = vm.$options.propsData || {};\n\t  var keys = vm.$options._propKeys = Object.keys(props);\n\t  var isRoot = !vm.$parent;\n\t  // root instance props should be converted\n\t  observerState.shouldConvert = isRoot;\n\t  var loop = function ( i ) {\n\t    var key = keys[i];\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      if (isReservedProp[key]) {\n\t        warn(\n\t          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n\t          vm\n\t        );\n\t      }\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n\t        if (vm.$parent && !observerState.isSettingProps) {\n\t          warn(\n\t            \"Avoid mutating a prop directly since the value will be \" +\n\t            \"overwritten whenever the parent component re-renders. \" +\n\t            \"Instead, use a data or computed property based on the prop's \" +\n\t            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n\t            vm\n\t          );\n\t        }\n\t      });\n\t    } else {\n\t      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n\t    }\n\t  };\n\t\n\t  for (var i = 0; i < keys.length; i++) loop( i );\n\t  observerState.shouldConvert = true;\n\t}\n\t\n\tfunction initData (vm) {\n\t  var data = vm.$options.data;\n\t  data = vm._data = typeof data === 'function'\n\t    ? data.call(vm)\n\t    : data || {};\n\t  if (!isPlainObject(data)) {\n\t    data = {};\n\t    (\"production\") !== 'production' && warn(\n\t      'data functions should return an object:\\n' +\n\t      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n\t      vm\n\t    );\n\t  }\n\t  // proxy data on instance\n\t  var keys = Object.keys(data);\n\t  var props = vm.$options.props;\n\t  var i = keys.length;\n\t  while (i--) {\n\t    if (props && hasOwn(props, keys[i])) {\n\t      (\"production\") !== 'production' && warn(\n\t        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n\t        \"Use prop default value instead.\",\n\t        vm\n\t      );\n\t    } else {\n\t      proxy(vm, keys[i]);\n\t    }\n\t  }\n\t  // observe data\n\t  observe(data, true /* asRootData */);\n\t}\n\t\n\tvar computedSharedDefinition = {\n\t  enumerable: true,\n\t  configurable: true,\n\t  get: noop,\n\t  set: noop\n\t};\n\t\n\tfunction initComputed (vm, computed) {\n\t  for (var key in computed) {\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      warn(\n\t        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n\t        \"overwritten by a computed property with the same name.\",\n\t        vm\n\t      );\n\t    }\n\t    var userDef = computed[key];\n\t    if (typeof userDef === 'function') {\n\t      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n\t      computedSharedDefinition.set = noop;\n\t    } else {\n\t      computedSharedDefinition.get = userDef.get\n\t        ? userDef.cache !== false\n\t          ? makeComputedGetter(userDef.get, vm)\n\t          : bind$1(userDef.get, vm)\n\t        : noop;\n\t      computedSharedDefinition.set = userDef.set\n\t        ? bind$1(userDef.set, vm)\n\t        : noop;\n\t    }\n\t    Object.defineProperty(vm, key, computedSharedDefinition);\n\t  }\n\t}\n\t\n\tfunction makeComputedGetter (getter, owner) {\n\t  var watcher = new Watcher(owner, getter, noop, {\n\t    lazy: true\n\t  });\n\t  return function computedGetter () {\n\t    if (watcher.dirty) {\n\t      watcher.evaluate();\n\t    }\n\t    if (Dep.target) {\n\t      watcher.depend();\n\t    }\n\t    return watcher.value\n\t  }\n\t}\n\t\n\tfunction initMethods (vm, methods) {\n\t  for (var key in methods) {\n\t    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n\t    if (false) {\n\t      warn(\n\t        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n\t        \"Did you reference the function correctly?\",\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\tfunction initWatch (vm, watch) {\n\t  for (var key in watch) {\n\t    var handler = watch[key];\n\t    if (Array.isArray(handler)) {\n\t      for (var i = 0; i < handler.length; i++) {\n\t        createWatcher(vm, key, handler[i]);\n\t      }\n\t    } else {\n\t      createWatcher(vm, key, handler);\n\t    }\n\t  }\n\t}\n\t\n\tfunction createWatcher (vm, key, handler) {\n\t  var options;\n\t  if (isPlainObject(handler)) {\n\t    options = handler;\n\t    handler = handler.handler;\n\t  }\n\t  if (typeof handler === 'string') {\n\t    handler = vm[handler];\n\t  }\n\t  vm.$watch(key, handler, options);\n\t}\n\t\n\tfunction stateMixin (Vue) {\n\t  // flow somehow has problems with directly declared definition object\n\t  // when using Object.defineProperty, so we have to procedurally build up\n\t  // the object here.\n\t  var dataDef = {};\n\t  dataDef.get = function () {\n\t    return this._data\n\t  };\n\t  if (false) {\n\t    dataDef.set = function (newData) {\n\t      warn(\n\t        'Avoid replacing instance root $data. ' +\n\t        'Use nested data properties instead.',\n\t        this\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\t\n\t  Vue.prototype.$set = set$1;\n\t  Vue.prototype.$delete = del;\n\t\n\t  Vue.prototype.$watch = function (\n\t    expOrFn,\n\t    cb,\n\t    options\n\t  ) {\n\t    var vm = this;\n\t    options = options || {};\n\t    options.user = true;\n\t    var watcher = new Watcher(vm, expOrFn, cb, options);\n\t    if (options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn () {\n\t      watcher.teardown();\n\t    }\n\t  };\n\t}\n\t\n\tfunction proxy (vm, key) {\n\t  if (!isReserved(key)) {\n\t    Object.defineProperty(vm, key, {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function proxyGetter () {\n\t        return vm._data[key]\n\t      },\n\t      set: function proxySetter (val) {\n\t        vm._data[key] = val;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  Vue.prototype._init = function (options) {\n\t    var vm = this;\n\t    // a uid\n\t    vm._uid = uid++;\n\t    // a flag to avoid this being observed\n\t    vm._isVue = true;\n\t    // merge options\n\t    if (options && options._isComponent) {\n\t      // optimize internal component instantiation\n\t      // since dynamic options merging is pretty slow, and none of the\n\t      // internal component options needs special treatment.\n\t      initInternalComponent(vm, options);\n\t    } else {\n\t      vm.$options = mergeOptions(\n\t        resolveConstructorOptions(vm.constructor),\n\t        options || {},\n\t        vm\n\t      );\n\t    }\n\t    /* istanbul ignore else */\n\t    if (false) {\n\t      initProxy(vm);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t    // expose real self\n\t    vm._self = vm;\n\t    initLifecycle(vm);\n\t    initEvents(vm);\n\t    initRender(vm);\n\t    callHook(vm, 'beforeCreate');\n\t    initState(vm);\n\t    callHook(vm, 'created');\n\t    if (vm.$options.el) {\n\t      vm.$mount(vm.$options.el);\n\t    }\n\t  };\n\t}\n\t\n\tfunction initInternalComponent (vm, options) {\n\t  var opts = vm.$options = Object.create(vm.constructor.options);\n\t  // doing this because it's faster than dynamic enumeration.\n\t  opts.parent = options.parent;\n\t  opts.propsData = options.propsData;\n\t  opts._parentVnode = options._parentVnode;\n\t  opts._parentListeners = options._parentListeners;\n\t  opts._renderChildren = options._renderChildren;\n\t  opts._componentTag = options._componentTag;\n\t  opts._parentElm = options._parentElm;\n\t  opts._refElm = options._refElm;\n\t  if (options.render) {\n\t    opts.render = options.render;\n\t    opts.staticRenderFns = options.staticRenderFns;\n\t  }\n\t}\n\t\n\tfunction resolveConstructorOptions (Ctor) {\n\t  var options = Ctor.options;\n\t  if (Ctor.super) {\n\t    var superOptions = Ctor.super.options;\n\t    var cachedSuperOptions = Ctor.superOptions;\n\t    var extendOptions = Ctor.extendOptions;\n\t    if (superOptions !== cachedSuperOptions) {\n\t      // super option changed\n\t      Ctor.superOptions = superOptions;\n\t      extendOptions.render = options.render;\n\t      extendOptions.staticRenderFns = options.staticRenderFns;\n\t      extendOptions._scopeId = options._scopeId;\n\t      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n\t      if (options.name) {\n\t        options.components[options.name] = Ctor;\n\t      }\n\t    }\n\t  }\n\t  return options\n\t}\n\t\n\tfunction Vue$3 (options) {\n\t  if (false) {\n\t    warn('Vue is a constructor and should be called with the `new` keyword');\n\t  }\n\t  this._init(options);\n\t}\n\t\n\tinitMixin(Vue$3);\n\tstateMixin(Vue$3);\n\teventsMixin(Vue$3);\n\tlifecycleMixin(Vue$3);\n\trenderMixin(Vue$3);\n\t\n\t/*  */\n\t\n\tfunction initUse (Vue) {\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initMixin$1 (Vue) {\n\t  Vue.mixin = function (mixin) {\n\t    this.options = mergeOptions(this.options, mixin);\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initExtend (Vue) {\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   */\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var SuperId = Super.cid;\n\t    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t    if (cachedCtors[SuperId]) {\n\t      return cachedCtors[SuperId]\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    if (false) {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn(\n\t          'Invalid component name: \"' + name + '\". Component names ' +\n\t          'can only contain alphanumeric characters and the hyphen, ' +\n\t          'and must start with a letter.'\n\t        );\n\t      }\n\t    }\n\t    var Sub = function VueComponent (options) {\n\t      this._init(options);\n\t    };\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(\n\t      Super.options,\n\t      extendOptions\n\t    );\n\t    Sub['super'] = Super;\n\t    // allow further extension/mixin/plugin usage\n\t    Sub.extend = Super.extend;\n\t    Sub.mixin = Super.mixin;\n\t    Sub.use = Super.use;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // keep a reference to the super options at extension time.\n\t    // later at instantiation we can check if Super's options have\n\t    // been updated.\n\t    Sub.superOptions = Super.options;\n\t    Sub.extendOptions = extendOptions;\n\t    // cache constructor\n\t    cachedCtors[SuperId] = Sub;\n\t    return Sub\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initAssetRegisters (Vue) {\n\t  /**\n\t   * Create asset registration methods.\n\t   */\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (\n\t      id,\n\t      definition\n\t    ) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id]\n\t      } else {\n\t        /* istanbul ignore if */\n\t        if (false) {\n\t          if (type === 'component' && config.isReservedTag(id)) {\n\t            warn(\n\t              'Do not use built-in or reserved HTML elements as component ' +\n\t              'id: ' + id\n\t            );\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = definition.name || id;\n\t          definition = this.options._base.extend(definition);\n\t        }\n\t        if (type === 'directive' && typeof definition === 'function') {\n\t          definition = { bind: definition, update: definition };\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\t/*  */\n\t\n\tvar patternTypes = [String, RegExp];\n\t\n\tfunction getComponentName (opts) {\n\t  return opts && (opts.Ctor.options.name || opts.tag)\n\t}\n\t\n\tfunction matches (pattern, name) {\n\t  if (typeof pattern === 'string') {\n\t    return pattern.split(',').indexOf(name) > -1\n\t  } else {\n\t    return pattern.test(name)\n\t  }\n\t}\n\t\n\tfunction pruneCache (cache, filter) {\n\t  for (var key in cache) {\n\t    var cachedNode = cache[key];\n\t    if (cachedNode) {\n\t      var name = getComponentName(cachedNode.componentOptions);\n\t      if (name && !filter(name)) {\n\t        pruneCacheEntry(cachedNode);\n\t        cache[key] = null;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction pruneCacheEntry (vnode) {\n\t  if (vnode) {\n\t    if (!vnode.componentInstance._inactive) {\n\t      callHook(vnode.componentInstance, 'deactivated');\n\t    }\n\t    vnode.componentInstance.$destroy();\n\t  }\n\t}\n\t\n\tvar KeepAlive = {\n\t  name: 'keep-alive',\n\t  abstract: true,\n\t\n\t  props: {\n\t    include: patternTypes,\n\t    exclude: patternTypes\n\t  },\n\t\n\t  created: function created () {\n\t    this.cache = Object.create(null);\n\t  },\n\t\n\t  destroyed: function destroyed () {\n\t    var this$1 = this;\n\t\n\t    for (var key in this.cache) {\n\t      pruneCacheEntry(this$1.cache[key]);\n\t    }\n\t  },\n\t\n\t  watch: {\n\t    include: function include (val) {\n\t      pruneCache(this.cache, function (name) { return matches(val, name); });\n\t    },\n\t    exclude: function exclude (val) {\n\t      pruneCache(this.cache, function (name) { return !matches(val, name); });\n\t    }\n\t  },\n\t\n\t  render: function render () {\n\t    var vnode = getFirstComponentChild(this.$slots.default);\n\t    var componentOptions = vnode && vnode.componentOptions;\n\t    if (componentOptions) {\n\t      // check pattern\n\t      var name = getComponentName(componentOptions);\n\t      if (name && (\n\t        (this.include && !matches(this.include, name)) ||\n\t        (this.exclude && matches(this.exclude, name))\n\t      )) {\n\t        return vnode\n\t      }\n\t      var key = vnode.key == null\n\t        // same constructor may get registered as different local components\n\t        // so cid alone is not enough (#3269)\n\t        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n\t        : vnode.key;\n\t      if (this.cache[key]) {\n\t        vnode.componentInstance = this.cache[key].componentInstance;\n\t      } else {\n\t        this.cache[key] = vnode;\n\t      }\n\t      vnode.data.keepAlive = true;\n\t    }\n\t    return vnode\n\t  }\n\t};\n\t\n\tvar builtInComponents = {\n\t  KeepAlive: KeepAlive\n\t};\n\t\n\t/*  */\n\t\n\tfunction initGlobalAPI (Vue) {\n\t  // config\n\t  var configDef = {};\n\t  configDef.get = function () { return config; };\n\t  if (false) {\n\t    configDef.set = function () {\n\t      warn(\n\t        'Do not replace the Vue.config object, set individual fields instead.'\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue, 'config', configDef);\n\t  Vue.util = util;\n\t  Vue.set = set$1;\n\t  Vue.delete = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  Vue.options = Object.create(null);\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue.options[type + 's'] = Object.create(null);\n\t  });\n\t\n\t  // this is used to identify the \"base\" constructor to extend all plain-object\n\t  // components with in Weex's multi-instance scenarios.\n\t  Vue.options._base = Vue;\n\t\n\t  extend(Vue.options.components, builtInComponents);\n\t\n\t  initUse(Vue);\n\t  initMixin$1(Vue);\n\t  initExtend(Vue);\n\t  initAssetRegisters(Vue);\n\t}\n\t\n\tinitGlobalAPI(Vue$3);\n\t\n\tObject.defineProperty(Vue$3.prototype, '$isServer', {\n\t  get: isServerRendering\n\t});\n\t\n\tVue$3.version = '2.1.10';\n\t\n\t/*  */\n\t\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function (tag, type, attr) {\n\t  return (\n\t    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n\t    (attr === 'selected' && tag === 'option') ||\n\t    (attr === 'checked' && tag === 'input') ||\n\t    (attr === 'muted' && tag === 'video')\n\t  )\n\t};\n\t\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\t\n\tvar isBooleanAttr = makeMap(\n\t  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n\t  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n\t  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n\t  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n\t  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n\t  'truespeed,typemustmatch,visible'\n\t);\n\t\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\n\tvar isXlink = function (name) {\n\t  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n\t};\n\t\n\tvar getXlinkProp = function (name) {\n\t  return isXlink(name) ? name.slice(6, name.length) : ''\n\t};\n\t\n\tvar isFalsyAttrValue = function (val) {\n\t  return val == null || val === false\n\t};\n\t\n\t/*  */\n\t\n\tfunction genClassForVnode (vnode) {\n\t  var data = vnode.data;\n\t  var parentNode = vnode;\n\t  var childNode = vnode;\n\t  while (childNode.componentInstance) {\n\t    childNode = childNode.componentInstance._vnode;\n\t    if (childNode.data) {\n\t      data = mergeClassData(childNode.data, data);\n\t    }\n\t  }\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data) {\n\t      data = mergeClassData(data, parentNode.data);\n\t    }\n\t  }\n\t  return genClassFromData(data)\n\t}\n\t\n\tfunction mergeClassData (child, parent) {\n\t  return {\n\t    staticClass: concat(child.staticClass, parent.staticClass),\n\t    class: child.class\n\t      ? [child.class, parent.class]\n\t      : parent.class\n\t  }\n\t}\n\t\n\tfunction genClassFromData (data) {\n\t  var dynamicClass = data.class;\n\t  var staticClass = data.staticClass;\n\t  if (staticClass || dynamicClass) {\n\t    return concat(staticClass, stringifyClass(dynamicClass))\n\t  }\n\t  /* istanbul ignore next */\n\t  return ''\n\t}\n\t\n\tfunction concat (a, b) {\n\t  return a ? b ? (a + ' ' + b) : a : (b || '')\n\t}\n\t\n\tfunction stringifyClass (value) {\n\t  var res = '';\n\t  if (!value) {\n\t    return res\n\t  }\n\t  if (typeof value === 'string') {\n\t    return value\n\t  }\n\t  if (Array.isArray(value)) {\n\t    var stringified;\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      if (value[i]) {\n\t        if ((stringified = stringifyClass(value[i]))) {\n\t          res += stringified + ' ';\n\t        }\n\t      }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) { res += key + ' '; }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  /* istanbul ignore next */\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar namespaceMap = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  math: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\t\n\tvar isHTMLTag = makeMap(\n\t  'html,body,base,head,link,meta,style,title,' +\n\t  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n\t  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n\t  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n\t  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n\t  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n\t  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n\t  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n\t  'output,progress,select,textarea,' +\n\t  'details,dialog,menu,menuitem,summary,' +\n\t  'content,element,shadow,template'\n\t);\n\t\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap(\n\t  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n\t  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n\t  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n\t  true\n\t);\n\t\n\tvar isPreTag = function (tag) { return tag === 'pre'; };\n\t\n\tvar isReservedTag = function (tag) {\n\t  return isHTMLTag(tag) || isSVG(tag)\n\t};\n\t\n\tfunction getTagNamespace (tag) {\n\t  if (isSVG(tag)) {\n\t    return 'svg'\n\t  }\n\t  // basic support for MathML\n\t  // note it doesn't support other MathML elements being component roots\n\t  if (tag === 'math') {\n\t    return 'math'\n\t  }\n\t}\n\t\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement (tag) {\n\t  /* istanbul ignore if */\n\t  if (!inBrowser) {\n\t    return true\n\t  }\n\t  if (isReservedTag(tag)) {\n\t    return false\n\t  }\n\t  tag = tag.toLowerCase();\n\t  /* istanbul ignore if */\n\t  if (unknownElementCache[tag] != null) {\n\t    return unknownElementCache[tag]\n\t  }\n\t  var el = document.createElement(tag);\n\t  if (tag.indexOf('-') > -1) {\n\t    // http://stackoverflow.com/a/28210364/1070244\n\t    return (unknownElementCache[tag] = (\n\t      el.constructor === window.HTMLUnknownElement ||\n\t      el.constructor === window.HTMLElement\n\t    ))\n\t  } else {\n\t    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t */\n\tfunction query (el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      (\"production\") !== 'production' && warn(\n\t        'Cannot find element: ' + selector\n\t      );\n\t      return document.createElement('div')\n\t    }\n\t  }\n\t  return el\n\t}\n\t\n\t/*  */\n\t\n\tfunction createElement$1 (tagName, vnode) {\n\t  var elm = document.createElement(tagName);\n\t  if (tagName !== 'select') {\n\t    return elm\n\t  }\n\t  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n\t    elm.setAttribute('multiple', 'multiple');\n\t  }\n\t  return elm\n\t}\n\t\n\tfunction createElementNS (namespace, tagName) {\n\t  return document.createElementNS(namespaceMap[namespace], tagName)\n\t}\n\t\n\tfunction createTextNode (text) {\n\t  return document.createTextNode(text)\n\t}\n\t\n\tfunction createComment (text) {\n\t  return document.createComment(text)\n\t}\n\t\n\tfunction insertBefore (parentNode, newNode, referenceNode) {\n\t  parentNode.insertBefore(newNode, referenceNode);\n\t}\n\t\n\tfunction removeChild (node, child) {\n\t  node.removeChild(child);\n\t}\n\t\n\tfunction appendChild (node, child) {\n\t  node.appendChild(child);\n\t}\n\t\n\tfunction parentNode (node) {\n\t  return node.parentNode\n\t}\n\t\n\tfunction nextSibling (node) {\n\t  return node.nextSibling\n\t}\n\t\n\tfunction tagName (node) {\n\t  return node.tagName\n\t}\n\t\n\tfunction setTextContent (node, text) {\n\t  node.textContent = text;\n\t}\n\t\n\tfunction setAttribute (node, key, val) {\n\t  node.setAttribute(key, val);\n\t}\n\t\n\t\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\t\n\t/*  */\n\t\n\tvar ref = {\n\t  create: function create (_, vnode) {\n\t    registerRef(vnode);\n\t  },\n\t  update: function update (oldVnode, vnode) {\n\t    if (oldVnode.data.ref !== vnode.data.ref) {\n\t      registerRef(oldVnode, true);\n\t      registerRef(vnode);\n\t    }\n\t  },\n\t  destroy: function destroy (vnode) {\n\t    registerRef(vnode, true);\n\t  }\n\t};\n\t\n\tfunction registerRef (vnode, isRemoval) {\n\t  var key = vnode.data.ref;\n\t  if (!key) { return }\n\t\n\t  var vm = vnode.context;\n\t  var ref = vnode.componentInstance || vnode.elm;\n\t  var refs = vm.$refs;\n\t  if (isRemoval) {\n\t    if (Array.isArray(refs[key])) {\n\t      remove$1(refs[key], ref);\n\t    } else if (refs[key] === ref) {\n\t      refs[key] = undefined;\n\t    }\n\t  } else {\n\t    if (vnode.data.refInFor) {\n\t      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t        refs[key].push(ref);\n\t      } else {\n\t        refs[key] = [ref];\n\t      }\n\t    } else {\n\t      refs[key] = ref;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Virtual DOM patching algorithm based on Snabbdom by\n\t * Simon Friis Vindum (@paldepind)\n\t * Licensed under the MIT License\n\t * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n\t *\n\t * modified by Evan You (@yyx990803)\n\t *\n\t\n\t/*\n\t * Not type-checking this because this file is perf-critical and the cost\n\t * of making flow understand it is not worth it.\n\t */\n\t\n\tvar emptyNode = new VNode('', {}, []);\n\t\n\tvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\t\n\tfunction isUndef (s) {\n\t  return s == null\n\t}\n\t\n\tfunction isDef (s) {\n\t  return s != null\n\t}\n\t\n\tfunction sameVnode (vnode1, vnode2) {\n\t  return (\n\t    vnode1.key === vnode2.key &&\n\t    vnode1.tag === vnode2.tag &&\n\t    vnode1.isComment === vnode2.isComment &&\n\t    !vnode1.data === !vnode2.data\n\t  )\n\t}\n\t\n\tfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n\t  var i, key;\n\t  var map = {};\n\t  for (i = beginIdx; i <= endIdx; ++i) {\n\t    key = children[i].key;\n\t    if (isDef(key)) { map[key] = i; }\n\t  }\n\t  return map\n\t}\n\t\n\tfunction createPatchFunction (backend) {\n\t  var i, j;\n\t  var cbs = {};\n\t\n\t  var modules = backend.modules;\n\t  var nodeOps = backend.nodeOps;\n\t\n\t  for (i = 0; i < hooks$1.length; ++i) {\n\t    cbs[hooks$1[i]] = [];\n\t    for (j = 0; j < modules.length; ++j) {\n\t      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n\t    }\n\t  }\n\t\n\t  function emptyNodeAt (elm) {\n\t    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n\t  }\n\t\n\t  function createRmCb (childElm, listeners) {\n\t    function remove$$1 () {\n\t      if (--remove$$1.listeners === 0) {\n\t        removeNode(childElm);\n\t      }\n\t    }\n\t    remove$$1.listeners = listeners;\n\t    return remove$$1\n\t  }\n\t\n\t  function removeNode (el) {\n\t    var parent = nodeOps.parentNode(el);\n\t    // element may have already been removed due to v-html / v-text\n\t    if (parent) {\n\t      nodeOps.removeChild(parent, el);\n\t    }\n\t  }\n\t\n\t  var inPre = 0;\n\t  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t    vnode.isRootInsert = !nested; // for transition enter check\n\t    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t      return\n\t    }\n\t\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    var tag = vnode.tag;\n\t    if (isDef(tag)) {\n\t      if (false) {\n\t        if (data && data.pre) {\n\t          inPre++;\n\t        }\n\t        if (\n\t          !inPre &&\n\t          !vnode.ns &&\n\t          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n\t          config.isUnknownElement(tag)\n\t        ) {\n\t          warn(\n\t            'Unknown custom element: <' + tag + '> - did you ' +\n\t            'register the component correctly? For recursive components, ' +\n\t            'make sure to provide the \"name\" option.',\n\t            vnode.context\n\t          );\n\t        }\n\t      }\n\t      vnode.elm = vnode.ns\n\t        ? nodeOps.createElementNS(vnode.ns, tag)\n\t        : nodeOps.createElement(tag, vnode);\n\t      setScope(vnode);\n\t\n\t      /* istanbul ignore if */\n\t      {\n\t        createChildren(vnode, children, insertedVnodeQueue);\n\t        if (isDef(data)) {\n\t          invokeCreateHooks(vnode, insertedVnodeQueue);\n\t        }\n\t        insert(parentElm, vnode.elm, refElm);\n\t      }\n\t\n\t      if (false) {\n\t        inPre--;\n\t      }\n\t    } else if (vnode.isComment) {\n\t      vnode.elm = nodeOps.createComment(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    } else {\n\t      vnode.elm = nodeOps.createTextNode(vnode.text);\n\t      insert(parentElm, vnode.elm, refElm);\n\t    }\n\t  }\n\t\n\t  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i = vnode.data;\n\t    if (isDef(i)) {\n\t      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\t      if (isDef(i = i.hook) && isDef(i = i.init)) {\n\t        i(vnode, false /* hydrating */, parentElm, refElm);\n\t      }\n\t      // after calling the init hook, if the vnode is a child component\n\t      // it should've created a child instance and mounted it. the child\n\t      // component also has set the placeholder vnode's elm.\n\t      // in that case we can just return the element and be done.\n\t      if (isDef(vnode.componentInstance)) {\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        if (isReactivated) {\n\t          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t        }\n\t        return true\n\t      }\n\t    }\n\t  }\n\t\n\t  function initComponent (vnode, insertedVnodeQueue) {\n\t    if (vnode.data.pendingInsert) {\n\t      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t    }\n\t    vnode.elm = vnode.componentInstance.$el;\n\t    if (isPatchable(vnode)) {\n\t      invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      setScope(vnode);\n\t    } else {\n\t      // empty component root.\n\t      // skip all element-related modules except for ref (#3455)\n\t      registerRef(vnode);\n\t      // make sure to invoke the insert hook\n\t      insertedVnodeQueue.push(vnode);\n\t    }\n\t  }\n\t\n\t  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n\t    var i;\n\t    // hack for #4339: a reactivated component with inner transition\n\t    // does not trigger because the inner node's created hooks are not called\n\t    // again. It's not ideal to involve module-specific logic in here but\n\t    // there doesn't seem to be a better way to do it.\n\t    var innerNode = vnode;\n\t    while (innerNode.componentInstance) {\n\t      innerNode = innerNode.componentInstance._vnode;\n\t      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t        for (i = 0; i < cbs.activate.length; ++i) {\n\t          cbs.activate[i](emptyNode, innerNode);\n\t        }\n\t        insertedVnodeQueue.push(innerNode);\n\t        break\n\t      }\n\t    }\n\t    // unlike a newly created component,\n\t    // a reactivated keep-alive component doesn't insert itself\n\t    insert(parentElm, vnode.elm, refElm);\n\t  }\n\t\n\t  function insert (parent, elm, ref) {\n\t    if (parent) {\n\t      if (ref) {\n\t        nodeOps.insertBefore(parent, elm, ref);\n\t      } else {\n\t        nodeOps.appendChild(parent, elm);\n\t      }\n\t    }\n\t  }\n\t\n\t  function createChildren (vnode, children, insertedVnodeQueue) {\n\t    if (Array.isArray(children)) {\n\t      for (var i = 0; i < children.length; ++i) {\n\t        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t      }\n\t    } else if (isPrimitive(vnode.text)) {\n\t      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t    }\n\t  }\n\t\n\t  function isPatchable (vnode) {\n\t    while (vnode.componentInstance) {\n\t      vnode = vnode.componentInstance._vnode;\n\t    }\n\t    return isDef(vnode.tag)\n\t  }\n\t\n\t  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n\t    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t      cbs.create[i$1](emptyNode, vnode);\n\t    }\n\t    i = vnode.data.hook; // Reuse variable\n\t    if (isDef(i)) {\n\t      if (i.create) { i.create(emptyNode, vnode); }\n\t      if (i.insert) { insertedVnodeQueue.push(vnode); }\n\t    }\n\t  }\n\t\n\t  // set scope id attribute for scoped CSS.\n\t  // this is implemented as a special case to avoid the overhead\n\t  // of going through the normal attribute patching process.\n\t  function setScope (vnode) {\n\t    var i;\n\t    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t    if (isDef(i = activeInstance) &&\n\t        i !== vnode.context &&\n\t        isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t  }\n\t\n\t  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t    }\n\t  }\n\t\n\t  function invokeDestroyHook (vnode) {\n\t    var i, j;\n\t    var data = vnode.data;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n\t      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n\t    }\n\t    if (isDef(i = vnode.children)) {\n\t      for (j = 0; j < vnode.children.length; ++j) {\n\t        invokeDestroyHook(vnode.children[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      var ch = vnodes[startIdx];\n\t      if (isDef(ch)) {\n\t        if (isDef(ch.tag)) {\n\t          removeAndInvokeRemoveHook(ch);\n\t          invokeDestroyHook(ch);\n\t        } else { // Text node\n\t          removeNode(ch.elm);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeAndInvokeRemoveHook (vnode, rm) {\n\t    if (rm || isDef(vnode.data)) {\n\t      var listeners = cbs.remove.length + 1;\n\t      if (!rm) {\n\t        // directly removing\n\t        rm = createRmCb(vnode.elm, listeners);\n\t      } else {\n\t        // we have a recursively passed down rm callback\n\t        // increase the listeners count\n\t        rm.listeners += listeners;\n\t      }\n\t      // recursively invoke hooks on child component root node\n\t      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n\t        removeAndInvokeRemoveHook(i, rm);\n\t      }\n\t      for (i = 0; i < cbs.remove.length; ++i) {\n\t        cbs.remove[i](vnode, rm);\n\t      }\n\t      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t        i(vnode, rm);\n\t      } else {\n\t        rm();\n\t      }\n\t    } else {\n\t      removeNode(vnode.elm);\n\t    }\n\t  }\n\t\n\t  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t    var oldStartIdx = 0;\n\t    var newStartIdx = 0;\n\t    var oldEndIdx = oldCh.length - 1;\n\t    var oldStartVnode = oldCh[0];\n\t    var oldEndVnode = oldCh[oldEndIdx];\n\t    var newEndIdx = newCh.length - 1;\n\t    var newStartVnode = newCh[0];\n\t    var newEndVnode = newCh[newEndIdx];\n\t    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\t\n\t    // removeOnly is a special flag used only by <transition-group>\n\t    // to ensure removed elements stay in correct relative positions\n\t    // during leaving transitions\n\t    var canMove = !removeOnly;\n\t\n\t    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t      if (isUndef(oldStartVnode)) {\n\t        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t      } else if (isUndef(oldEndVnode)) {\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else {\n\t        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n\t        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t        if (isUndef(idxInOld)) { // New element\n\t          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t          newStartVnode = newCh[++newStartIdx];\n\t        } else {\n\t          elmToMove = oldCh[idxInOld];\n\t          /* istanbul ignore if */\n\t          if (false) {\n\t            warn(\n\t              'It seems there are duplicate keys that is causing an update error. ' +\n\t              'Make sure each v-for item has a unique key.'\n\t            );\n\t          }\n\t          if (sameVnode(elmToMove, newStartVnode)) {\n\t            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t            oldCh[idxInOld] = undefined;\n\t            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          } else {\n\t            // same key but different element. treat as new element\n\t            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (oldStartIdx > oldEndIdx) {\n\t      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t    } else if (newStartIdx > newEndIdx) {\n\t      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t    }\n\t  }\n\t\n\t  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t    if (oldVnode === vnode) {\n\t      return\n\t    }\n\t    // reuse element for static trees.\n\t    // note we only do this if the vnode is cloned -\n\t    // if the new node is not cloned it means the render functions have been\n\t    // reset by the hot-reload-api and we need to do a proper re-render.\n\t    if (vnode.isStatic &&\n\t        oldVnode.isStatic &&\n\t        vnode.key === oldVnode.key &&\n\t        (vnode.isCloned || vnode.isOnce)) {\n\t      vnode.elm = oldVnode.elm;\n\t      vnode.componentInstance = oldVnode.componentInstance;\n\t      return\n\t    }\n\t    var i;\n\t    var data = vnode.data;\n\t    var hasData = isDef(data);\n\t    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t      i(oldVnode, vnode);\n\t    }\n\t    var elm = vnode.elm = oldVnode.elm;\n\t    var oldCh = oldVnode.children;\n\t    var ch = vnode.children;\n\t    if (hasData && isPatchable(vnode)) {\n\t      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n\t      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n\t    }\n\t    if (isUndef(vnode.text)) {\n\t      if (isDef(oldCh) && isDef(ch)) {\n\t        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n\t      } else if (isDef(ch)) {\n\t        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n\t        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t      } else if (isDef(oldCh)) {\n\t        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t      } else if (isDef(oldVnode.text)) {\n\t        nodeOps.setTextContent(elm, '');\n\t      }\n\t    } else if (oldVnode.text !== vnode.text) {\n\t      nodeOps.setTextContent(elm, vnode.text);\n\t    }\n\t    if (hasData) {\n\t      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n\t    }\n\t  }\n\t\n\t  function invokeInsertHook (vnode, queue, initial) {\n\t    // delay insert hooks for component root nodes, invoke them after the\n\t    // element is really inserted\n\t    if (initial && vnode.parent) {\n\t      vnode.parent.data.pendingInsert = queue;\n\t    } else {\n\t      for (var i = 0; i < queue.length; ++i) {\n\t        queue[i].data.hook.insert(queue[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var bailed = false;\n\t  // list of modules that can skip create hook during hydration because they\n\t  // are already rendered on the client or has no need for initialization\n\t  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\t\n\t  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t  function hydrate (elm, vnode, insertedVnodeQueue) {\n\t    if (false) {\n\t      if (!assertNodeMatch(elm, vnode)) {\n\t        return false\n\t      }\n\t    }\n\t    vnode.elm = elm;\n\t    var tag = vnode.tag;\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n\t      if (isDef(i = vnode.componentInstance)) {\n\t        // child component. it should have hydrated its own tree.\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return true\n\t      }\n\t    }\n\t    if (isDef(tag)) {\n\t      if (isDef(children)) {\n\t        // empty element, allow client to pick up and populate children\n\t        if (!elm.hasChildNodes()) {\n\t          createChildren(vnode, children, insertedVnodeQueue);\n\t        } else {\n\t          var childrenMatch = true;\n\t          var childNode = elm.firstChild;\n\t          for (var i$1 = 0; i$1 < children.length; i$1++) {\n\t            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t              childrenMatch = false;\n\t              break\n\t            }\n\t            childNode = childNode.nextSibling;\n\t          }\n\t          // if childNode is not null, it means the actual childNodes list is\n\t          // longer than the virtual children list.\n\t          if (!childrenMatch || childNode) {\n\t            if (false) {\n\t              bailed = true;\n\t              console.warn('Parent: ', elm);\n\t              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n\t            }\n\t            return false\n\t          }\n\t        }\n\t      }\n\t      if (isDef(data)) {\n\t        for (var key in data) {\n\t          if (!isRenderedModule(key)) {\n\t            invokeCreateHooks(vnode, insertedVnodeQueue);\n\t            break\n\t          }\n\t        }\n\t      }\n\t    } else if (elm.data !== vnode.text) {\n\t      elm.data = vnode.text;\n\t    }\n\t    return true\n\t  }\n\t\n\t  function assertNodeMatch (node, vnode) {\n\t    if (vnode.tag) {\n\t      return (\n\t        vnode.tag.indexOf('vue-component') === 0 ||\n\t        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n\t      )\n\t    } else {\n\t      return node.nodeType === (vnode.isComment ? 8 : 3)\n\t    }\n\t  }\n\t\n\t  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t    if (!vnode) {\n\t      if (oldVnode) { invokeDestroyHook(oldVnode); }\n\t      return\n\t    }\n\t\n\t    var isInitialPatch = false;\n\t    var insertedVnodeQueue = [];\n\t\n\t    if (!oldVnode) {\n\t      // empty mount (likely as component), create new root element\n\t      isInitialPatch = true;\n\t      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t    } else {\n\t      var isRealElement = isDef(oldVnode.nodeType);\n\t      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t        // patch existing root node\n\t        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t      } else {\n\t        if (isRealElement) {\n\t          // mounting to a real element\n\t          // check if this is server-rendered content and if we can perform\n\t          // a successful hydration.\n\t          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n\t            oldVnode.removeAttribute('server-rendered');\n\t            hydrating = true;\n\t          }\n\t          if (hydrating) {\n\t            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t              invokeInsertHook(vnode, insertedVnodeQueue, true);\n\t              return oldVnode\n\t            } else if (false) {\n\t              warn(\n\t                'The client-side rendered virtual DOM tree is not matching ' +\n\t                'server-rendered content. This is likely caused by incorrect ' +\n\t                'HTML markup, for example nesting block-level elements inside ' +\n\t                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n\t                'full client-side render.'\n\t              );\n\t            }\n\t          }\n\t          // either not server-rendered, or hydration failed.\n\t          // create an empty node and replace it\n\t          oldVnode = emptyNodeAt(oldVnode);\n\t        }\n\t        // replacing existing element\n\t        var oldElm = oldVnode.elm;\n\t        var parentElm$1 = nodeOps.parentNode(oldElm);\n\t        createElm(\n\t          vnode,\n\t          insertedVnodeQueue,\n\t          // extremely rare edge case: do not insert if old element is in a\n\t          // leaving transition. Only happens when combining transition +\n\t          // keep-alive + HOCs. (#4590)\n\t          oldElm._leaveCb ? null : parentElm$1,\n\t          nodeOps.nextSibling(oldElm)\n\t        );\n\t\n\t        if (vnode.parent) {\n\t          // component root element replaced.\n\t          // update parent placeholder node element, recursively\n\t          var ancestor = vnode.parent;\n\t          while (ancestor) {\n\t            ancestor.elm = vnode.elm;\n\t            ancestor = ancestor.parent;\n\t          }\n\t          if (isPatchable(vnode)) {\n\t            for (var i = 0; i < cbs.create.length; ++i) {\n\t              cbs.create[i](emptyNode, vnode.parent);\n\t            }\n\t          }\n\t        }\n\t\n\t        if (parentElm$1 !== null) {\n\t          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n\t        } else if (isDef(oldVnode.tag)) {\n\t          invokeDestroyHook(oldVnode);\n\t        }\n\t      }\n\t    }\n\t\n\t    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t    return vnode.elm\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar directives = {\n\t  create: updateDirectives,\n\t  update: updateDirectives,\n\t  destroy: function unbindDirectives (vnode) {\n\t    updateDirectives(vnode, emptyNode);\n\t  }\n\t};\n\t\n\tfunction updateDirectives (oldVnode, vnode) {\n\t  if (oldVnode.data.directives || vnode.data.directives) {\n\t    _update(oldVnode, vnode);\n\t  }\n\t}\n\t\n\tfunction _update (oldVnode, vnode) {\n\t  var isCreate = oldVnode === emptyNode;\n\t  var isDestroy = vnode === emptyNode;\n\t  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\t\n\t  var dirsWithInsert = [];\n\t  var dirsWithPostpatch = [];\n\t\n\t  var key, oldDir, dir;\n\t  for (key in newDirs) {\n\t    oldDir = oldDirs[key];\n\t    dir = newDirs[key];\n\t    if (!oldDir) {\n\t      // new directive, bind\n\t      callHook$1(dir, 'bind', vnode, oldVnode);\n\t      if (dir.def && dir.def.inserted) {\n\t        dirsWithInsert.push(dir);\n\t      }\n\t    } else {\n\t      // existing directive, update\n\t      dir.oldValue = oldDir.value;\n\t      callHook$1(dir, 'update', vnode, oldVnode);\n\t      if (dir.def && dir.def.componentUpdated) {\n\t        dirsWithPostpatch.push(dir);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dirsWithInsert.length) {\n\t    var callInsert = function () {\n\t      for (var i = 0; i < dirsWithInsert.length; i++) {\n\t        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t      }\n\t    };\n\t    if (isCreate) {\n\t      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n\t    } else {\n\t      callInsert();\n\t    }\n\t  }\n\t\n\t  if (dirsWithPostpatch.length) {\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t      }\n\t    }, 'dir-postpatch');\n\t  }\n\t\n\t  if (!isCreate) {\n\t    for (key in oldDirs) {\n\t      if (!newDirs[key]) {\n\t        // no longer present, unbind\n\t        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar emptyModifiers = Object.create(null);\n\t\n\tfunction normalizeDirectives$1 (\n\t  dirs,\n\t  vm\n\t) {\n\t  var res = Object.create(null);\n\t  if (!dirs) {\n\t    return res\n\t  }\n\t  var i, dir;\n\t  for (i = 0; i < dirs.length; i++) {\n\t    dir = dirs[i];\n\t    if (!dir.modifiers) {\n\t      dir.modifiers = emptyModifiers;\n\t    }\n\t    res[getRawDirName(dir)] = dir;\n\t    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getRawDirName (dir) {\n\t  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n\t}\n\t\n\tfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n\t  var fn = dir.def && dir.def[hook];\n\t  if (fn) {\n\t    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t  }\n\t}\n\t\n\tvar baseModules = [\n\t  ref,\n\t  directives\n\t];\n\t\n\t/*  */\n\t\n\tfunction updateAttrs (oldVnode, vnode) {\n\t  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n\t    return\n\t  }\n\t  var key, cur, old;\n\t  var elm = vnode.elm;\n\t  var oldAttrs = oldVnode.data.attrs || {};\n\t  var attrs = vnode.data.attrs || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (attrs.__ob__) {\n\t    attrs = vnode.data.attrs = extend({}, attrs);\n\t  }\n\t\n\t  for (key in attrs) {\n\t    cur = attrs[key];\n\t    old = oldAttrs[key];\n\t    if (old !== cur) {\n\t      setAttr(elm, key, cur);\n\t    }\n\t  }\n\t  // #4391: in IE9, setting type can reset value for input[type=radio]\n\t  /* istanbul ignore if */\n\t  if (isIE9 && attrs.value !== oldAttrs.value) {\n\t    setAttr(elm, 'value', attrs.value);\n\t  }\n\t  for (key in oldAttrs) {\n\t    if (attrs[key] == null) {\n\t      if (isXlink(key)) {\n\t        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t      } else if (!isEnumeratedAttr(key)) {\n\t        elm.removeAttribute(key);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction setAttr (el, key, value) {\n\t  if (isBooleanAttr(key)) {\n\t    // set attribute for blank value\n\t    // e.g. <option disabled>Select one</option>\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, key);\n\t    }\n\t  } else if (isEnumeratedAttr(key)) {\n\t    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t  } else if (isXlink(key)) {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t    } else {\n\t      el.setAttributeNS(xlinkNS, key, value);\n\t    }\n\t  } else {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, value);\n\t    }\n\t  }\n\t}\n\t\n\tvar attrs = {\n\t  create: updateAttrs,\n\t  update: updateAttrs\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateClass (oldVnode, vnode) {\n\t  var el = vnode.elm;\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t  if (!data.staticClass && !data.class &&\n\t      (!oldData || (!oldData.staticClass && !oldData.class))) {\n\t    return\n\t  }\n\t\n\t  var cls = genClassForVnode(vnode);\n\t\n\t  // handle transition classes\n\t  var transitionClass = el._transitionClasses;\n\t  if (transitionClass) {\n\t    cls = concat(cls, stringifyClass(transitionClass));\n\t  }\n\t\n\t  // set the class\n\t  if (cls !== el._prevClass) {\n\t    el.setAttribute('class', cls);\n\t    el._prevClass = cls;\n\t  }\n\t}\n\t\n\tvar klass = {\n\t  create: updateClass,\n\t  update: updateClass\n\t};\n\t\n\t/*  */\n\t\n\tvar target$1;\n\t\n\tfunction add$2 (\n\t  event,\n\t  handler,\n\t  once,\n\t  capture\n\t) {\n\t  if (once) {\n\t    var oldHandler = handler;\n\t    var _target = target$1; // save current target element in closure\n\t    handler = function (ev) {\n\t      remove$3(event, handler, capture, _target);\n\t      arguments.length === 1\n\t        ? oldHandler(ev)\n\t        : oldHandler.apply(null, arguments);\n\t    };\n\t  }\n\t  target$1.addEventListener(event, handler, capture);\n\t}\n\t\n\tfunction remove$3 (\n\t  event,\n\t  handler,\n\t  capture,\n\t  _target\n\t) {\n\t  (_target || target$1).removeEventListener(event, handler, capture);\n\t}\n\t\n\tfunction updateDOMListeners (oldVnode, vnode) {\n\t  if (!oldVnode.data.on && !vnode.data.on) {\n\t    return\n\t  }\n\t  var on = vnode.data.on || {};\n\t  var oldOn = oldVnode.data.on || {};\n\t  target$1 = vnode.elm;\n\t  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n\t}\n\t\n\tvar events = {\n\t  create: updateDOMListeners,\n\t  update: updateDOMListeners\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateDOMProps (oldVnode, vnode) {\n\t  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n\t    return\n\t  }\n\t  var key, cur;\n\t  var elm = vnode.elm;\n\t  var oldProps = oldVnode.data.domProps || {};\n\t  var props = vnode.data.domProps || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (props.__ob__) {\n\t    props = vnode.data.domProps = extend({}, props);\n\t  }\n\t\n\t  for (key in oldProps) {\n\t    if (props[key] == null) {\n\t      elm[key] = '';\n\t    }\n\t  }\n\t  for (key in props) {\n\t    cur = props[key];\n\t    // ignore children if the node has textContent or innerHTML,\n\t    // as these will throw away existing DOM nodes and cause removal errors\n\t    // on subsequent patches (#3360)\n\t    if (key === 'textContent' || key === 'innerHTML') {\n\t      if (vnode.children) { vnode.children.length = 0; }\n\t      if (cur === oldProps[key]) { continue }\n\t    }\n\t\n\t    if (key === 'value') {\n\t      // store value as _value as well since\n\t      // non-string values will be stringified\n\t      elm._value = cur;\n\t      // avoid resetting cursor position when value is the same\n\t      var strCur = cur == null ? '' : String(cur);\n\t      if (shouldUpdateValue(elm, vnode, strCur)) {\n\t        elm.value = strCur;\n\t      }\n\t    } else {\n\t      elm[key] = cur;\n\t    }\n\t  }\n\t}\n\t\n\t// check platforms/web/util/attrs.js acceptValue\n\t\n\t\n\tfunction shouldUpdateValue (\n\t  elm,\n\t  vnode,\n\t  checkVal\n\t) {\n\t  return (!elm.composing && (\n\t    vnode.tag === 'option' ||\n\t    isDirty(elm, checkVal) ||\n\t    isInputChanged(vnode, checkVal)\n\t  ))\n\t}\n\t\n\tfunction isDirty (elm, checkVal) {\n\t  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n\t  return document.activeElement !== elm && elm.value !== checkVal\n\t}\n\t\n\tfunction isInputChanged (vnode, newVal) {\n\t  var value = vnode.elm.value;\n\t  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n\t  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n\t    return toNumber(value) !== toNumber(newVal)\n\t  }\n\t  if (modifiers && modifiers.trim) {\n\t    return value.trim() !== newVal.trim()\n\t  }\n\t  return value !== newVal\n\t}\n\t\n\tvar domProps = {\n\t  create: updateDOMProps,\n\t  update: updateDOMProps\n\t};\n\t\n\t/*  */\n\t\n\tvar parseStyleText = cached(function (cssText) {\n\t  var res = {};\n\t  var listDelimiter = /;(?![^(]*\\))/g;\n\t  var propertyDelimiter = /:(.+)/;\n\t  cssText.split(listDelimiter).forEach(function (item) {\n\t    if (item) {\n\t      var tmp = item.split(propertyDelimiter);\n\t      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t    }\n\t  });\n\t  return res\n\t});\n\t\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData (data) {\n\t  var style = normalizeStyleBinding(data.style);\n\t  // static style is pre-processed into an object during compilation\n\t  // and is always a fresh object, so it's safe to merge into it\n\t  return data.staticStyle\n\t    ? extend(data.staticStyle, style)\n\t    : style\n\t}\n\t\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding (bindingStyle) {\n\t  if (Array.isArray(bindingStyle)) {\n\t    return toObject(bindingStyle)\n\t  }\n\t  if (typeof bindingStyle === 'string') {\n\t    return parseStyleText(bindingStyle)\n\t  }\n\t  return bindingStyle\n\t}\n\t\n\t/**\n\t * parent component style should be after child's\n\t * so that parent component's style could override it\n\t */\n\tfunction getStyle (vnode, checkChild) {\n\t  var res = {};\n\t  var styleData;\n\t\n\t  if (checkChild) {\n\t    var childNode = vnode;\n\t    while (childNode.componentInstance) {\n\t      childNode = childNode.componentInstance._vnode;\n\t      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t        extend(res, styleData);\n\t      }\n\t    }\n\t  }\n\t\n\t  if ((styleData = normalizeStyleData(vnode.data))) {\n\t    extend(res, styleData);\n\t  }\n\t\n\t  var parentNode = vnode;\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t      extend(res, styleData);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function (el, name, val) {\n\t  /* istanbul ignore if */\n\t  if (cssVarRE.test(name)) {\n\t    el.style.setProperty(name, val);\n\t  } else if (importantRE.test(val)) {\n\t    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t  } else {\n\t    el.style[normalize(name)] = val;\n\t  }\n\t};\n\t\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\t\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t  testEl = testEl || document.createElement('div');\n\t  prop = camelize(prop);\n\t  if (prop !== 'filter' && (prop in testEl.style)) {\n\t    return prop\n\t  }\n\t  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t  for (var i = 0; i < prefixes.length; i++) {\n\t    var prefixed = prefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return prefixed\n\t    }\n\t  }\n\t});\n\t\n\tfunction updateStyle (oldVnode, vnode) {\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t\n\t  if (!data.staticStyle && !data.style &&\n\t      !oldData.staticStyle && !oldData.style) {\n\t    return\n\t  }\n\t\n\t  var cur, name;\n\t  var el = vnode.elm;\n\t  var oldStaticStyle = oldVnode.data.staticStyle;\n\t  var oldStyleBinding = oldVnode.data.style || {};\n\t\n\t  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t  var oldStyle = oldStaticStyle || oldStyleBinding;\n\t\n\t  var style = normalizeStyleBinding(vnode.data.style) || {};\n\t\n\t  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\t\n\t  var newStyle = getStyle(vnode, true);\n\t\n\t  for (name in oldStyle) {\n\t    if (newStyle[name] == null) {\n\t      setProp(el, name, '');\n\t    }\n\t  }\n\t  for (name in newStyle) {\n\t    cur = newStyle[name];\n\t    if (cur !== oldStyle[name]) {\n\t      // ie9 setting to null has no effect, must use empty string\n\t      setProp(el, name, cur == null ? '' : cur);\n\t    }\n\t  }\n\t}\n\t\n\tvar style = {\n\t  create: updateStyle,\n\t  update: updateStyle\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Add class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction addClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n\t    } else {\n\t      el.classList.add(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      el.setAttribute('class', (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction removeClass (el, cls) {\n\t  /* istanbul ignore if */\n\t  if (!cls || !cls.trim()) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n\t    } else {\n\t      el.classList.remove(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    el.setAttribute('class', cur.trim());\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\t\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t  /* istanbul ignore if */\n\t  if (window.ontransitionend === undefined &&\n\t    window.onwebkittransitionend !== undefined) {\n\t    transitionProp = 'WebkitTransition';\n\t    transitionEndEvent = 'webkitTransitionEnd';\n\t  }\n\t  if (window.onanimationend === undefined &&\n\t    window.onwebkitanimationend !== undefined) {\n\t    animationProp = 'WebkitAnimation';\n\t    animationEndEvent = 'webkitAnimationEnd';\n\t  }\n\t}\n\t\n\t// binding to window is necessary to make hot reload work in IE in strict mode\n\tvar raf = inBrowser && window.requestAnimationFrame\n\t  ? window.requestAnimationFrame.bind(window)\n\t  : setTimeout;\n\t\n\tfunction nextFrame (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t}\n\t\n\tfunction addTransitionClass (el, cls) {\n\t  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t  addClass(el, cls);\n\t}\n\t\n\tfunction removeTransitionClass (el, cls) {\n\t  if (el._transitionClasses) {\n\t    remove$1(el._transitionClasses, cls);\n\t  }\n\t  removeClass(el, cls);\n\t}\n\t\n\tfunction whenTransitionEnds (\n\t  el,\n\t  expectedType,\n\t  cb\n\t) {\n\t  var ref = getTransitionInfo(el, expectedType);\n\t  var type = ref.type;\n\t  var timeout = ref.timeout;\n\t  var propCount = ref.propCount;\n\t  if (!type) { return cb() }\n\t  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t  var ended = 0;\n\t  var end = function () {\n\t    el.removeEventListener(event, onEnd);\n\t    cb();\n\t  };\n\t  var onEnd = function (e) {\n\t    if (e.target === el) {\n\t      if (++ended >= propCount) {\n\t        end();\n\t      }\n\t    }\n\t  };\n\t  setTimeout(function () {\n\t    if (ended < propCount) {\n\t      end();\n\t    }\n\t  }, timeout + 1);\n\t  el.addEventListener(event, onEnd);\n\t}\n\t\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\t\n\tfunction getTransitionInfo (el, expectedType) {\n\t  var styles = window.getComputedStyle(el);\n\t  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n\t  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n\t  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\t\n\t  var type;\n\t  var timeout = 0;\n\t  var propCount = 0;\n\t  /* istanbul ignore if */\n\t  if (expectedType === TRANSITION) {\n\t    if (transitionTimeout > 0) {\n\t      type = TRANSITION;\n\t      timeout = transitionTimeout;\n\t      propCount = transitionDurations.length;\n\t    }\n\t  } else if (expectedType === ANIMATION) {\n\t    if (animationTimeout > 0) {\n\t      type = ANIMATION;\n\t      timeout = animationTimeout;\n\t      propCount = animationDurations.length;\n\t    }\n\t  } else {\n\t    timeout = Math.max(transitionTimeout, animationTimeout);\n\t    type = timeout > 0\n\t      ? transitionTimeout > animationTimeout\n\t        ? TRANSITION\n\t        : ANIMATION\n\t      : null;\n\t    propCount = type\n\t      ? type === TRANSITION\n\t        ? transitionDurations.length\n\t        : animationDurations.length\n\t      : 0;\n\t  }\n\t  var hasTransform =\n\t    type === TRANSITION &&\n\t    transformRE.test(styles[transitionProp + 'Property']);\n\t  return {\n\t    type: type,\n\t    timeout: timeout,\n\t    propCount: propCount,\n\t    hasTransform: hasTransform\n\t  }\n\t}\n\t\n\tfunction getTimeout (delays, durations) {\n\t  /* istanbul ignore next */\n\t  while (delays.length < durations.length) {\n\t    delays = delays.concat(delays);\n\t  }\n\t\n\t  return Math.max.apply(null, durations.map(function (d, i) {\n\t    return toMs(d) + toMs(delays[i])\n\t  }))\n\t}\n\t\n\tfunction toMs (s) {\n\t  return Number(s.slice(0, -1)) * 1000\n\t}\n\t\n\t/*  */\n\t\n\tfunction enter (vnode, toggleDisplay) {\n\t  var el = vnode.elm;\n\t\n\t  // call leave callback now\n\t  if (el._leaveCb) {\n\t    el._leaveCb.cancelled = true;\n\t    el._leaveCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._enterCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var enterClass = data.enterClass;\n\t  var enterToClass = data.enterToClass;\n\t  var enterActiveClass = data.enterActiveClass;\n\t  var appearClass = data.appearClass;\n\t  var appearToClass = data.appearToClass;\n\t  var appearActiveClass = data.appearActiveClass;\n\t  var beforeEnter = data.beforeEnter;\n\t  var enter = data.enter;\n\t  var afterEnter = data.afterEnter;\n\t  var enterCancelled = data.enterCancelled;\n\t  var beforeAppear = data.beforeAppear;\n\t  var appear = data.appear;\n\t  var afterAppear = data.afterAppear;\n\t  var appearCancelled = data.appearCancelled;\n\t\n\t  // activeInstance will always be the <transition> component managing this\n\t  // transition. One edge case to check is when the <transition> is placed\n\t  // as the root node of a child component. In that case we need to check\n\t  // <transition>'s parent for appear check.\n\t  var context = activeInstance;\n\t  var transitionNode = activeInstance.$vnode;\n\t  while (transitionNode && transitionNode.parent) {\n\t    transitionNode = transitionNode.parent;\n\t    context = transitionNode.context;\n\t  }\n\t\n\t  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\t\n\t  if (isAppear && !appear && appear !== '') {\n\t    return\n\t  }\n\t\n\t  var startClass = isAppear ? appearClass : enterClass;\n\t  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n\t  var toClass = isAppear ? appearToClass : enterToClass;\n\t  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n\t  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n\t  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n\t  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    enterHook &&\n\t    // enterHook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (enterHook._length || enterHook.length) > 1;\n\t\n\t  var cb = el._enterCb = once(function () {\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, toClass);\n\t      removeTransitionClass(el, activeClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, startClass);\n\t      }\n\t      enterCancelledHook && enterCancelledHook(el);\n\t    } else {\n\t      afterEnterHook && afterEnterHook(el);\n\t    }\n\t    el._enterCb = null;\n\t  });\n\t\n\t  if (!vnode.data.show) {\n\t    // remove pending leave element on enter by injecting an insert hook\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t      var parent = el.parentNode;\n\t      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t      if (pendingNode &&\n\t          pendingNode.tag === vnode.tag &&\n\t          pendingNode.elm._leaveCb) {\n\t        pendingNode.elm._leaveCb();\n\t      }\n\t      enterHook && enterHook(el, cb);\n\t    }, 'transition-insert');\n\t  }\n\t\n\t  // start enter transition\n\t  beforeEnterHook && beforeEnterHook(el);\n\t  if (expectsCSS) {\n\t    addTransitionClass(el, startClass);\n\t    addTransitionClass(el, activeClass);\n\t    nextFrame(function () {\n\t      addTransitionClass(el, toClass);\n\t      removeTransitionClass(el, startClass);\n\t      if (!cb.cancelled && !userWantsControl) {\n\t        whenTransitionEnds(el, type, cb);\n\t      }\n\t    });\n\t  }\n\t\n\t  if (vnode.data.show) {\n\t    toggleDisplay && toggleDisplay();\n\t    enterHook && enterHook(el, cb);\n\t  }\n\t\n\t  if (!expectsCSS && !userWantsControl) {\n\t    cb();\n\t  }\n\t}\n\t\n\tfunction leave (vnode, rm) {\n\t  var el = vnode.elm;\n\t\n\t  // call enter callback now\n\t  if (el._enterCb) {\n\t    el._enterCb.cancelled = true;\n\t    el._enterCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return rm()\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._leaveCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var leaveClass = data.leaveClass;\n\t  var leaveToClass = data.leaveToClass;\n\t  var leaveActiveClass = data.leaveActiveClass;\n\t  var beforeLeave = data.beforeLeave;\n\t  var leave = data.leave;\n\t  var afterLeave = data.afterLeave;\n\t  var leaveCancelled = data.leaveCancelled;\n\t  var delayLeave = data.delayLeave;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    leave &&\n\t    // leave hook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (leave._length || leave.length) > 1;\n\t\n\t  var cb = el._leaveCb = once(function () {\n\t    if (el.parentNode && el.parentNode._pending) {\n\t      el.parentNode._pending[vnode.key] = null;\n\t    }\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, leaveToClass);\n\t      removeTransitionClass(el, leaveActiveClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, leaveClass);\n\t      }\n\t      leaveCancelled && leaveCancelled(el);\n\t    } else {\n\t      rm();\n\t      afterLeave && afterLeave(el);\n\t    }\n\t    el._leaveCb = null;\n\t  });\n\t\n\t  if (delayLeave) {\n\t    delayLeave(performLeave);\n\t  } else {\n\t    performLeave();\n\t  }\n\t\n\t  function performLeave () {\n\t    // the delayed leave may have already been cancelled\n\t    if (cb.cancelled) {\n\t      return\n\t    }\n\t    // record leaving element\n\t    if (!vnode.data.show) {\n\t      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t    }\n\t    beforeLeave && beforeLeave(el);\n\t    if (expectsCSS) {\n\t      addTransitionClass(el, leaveClass);\n\t      addTransitionClass(el, leaveActiveClass);\n\t      nextFrame(function () {\n\t        addTransitionClass(el, leaveToClass);\n\t        removeTransitionClass(el, leaveClass);\n\t        if (!cb.cancelled && !userWantsControl) {\n\t          whenTransitionEnds(el, type, cb);\n\t        }\n\t      });\n\t    }\n\t    leave && leave(el, cb);\n\t    if (!expectsCSS && !userWantsControl) {\n\t      cb();\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveTransition (def$$1) {\n\t  if (!def$$1) {\n\t    return\n\t  }\n\t  /* istanbul ignore else */\n\t  if (typeof def$$1 === 'object') {\n\t    var res = {};\n\t    if (def$$1.css !== false) {\n\t      extend(res, autoCssTransition(def$$1.name || 'v'));\n\t    }\n\t    extend(res, def$$1);\n\t    return res\n\t  } else if (typeof def$$1 === 'string') {\n\t    return autoCssTransition(def$$1)\n\t  }\n\t}\n\t\n\tvar autoCssTransition = cached(function (name) {\n\t  return {\n\t    enterClass: (name + \"-enter\"),\n\t    leaveClass: (name + \"-leave\"),\n\t    appearClass: (name + \"-enter\"),\n\t    enterToClass: (name + \"-enter-to\"),\n\t    leaveToClass: (name + \"-leave-to\"),\n\t    appearToClass: (name + \"-enter-to\"),\n\t    enterActiveClass: (name + \"-enter-active\"),\n\t    leaveActiveClass: (name + \"-leave-active\"),\n\t    appearActiveClass: (name + \"-enter-active\")\n\t  }\n\t});\n\t\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (!called) {\n\t      called = true;\n\t      fn();\n\t    }\n\t  }\n\t}\n\t\n\tfunction _enter (_, vnode) {\n\t  if (!vnode.data.show) {\n\t    enter(vnode);\n\t  }\n\t}\n\t\n\tvar transition = inBrowser ? {\n\t  create: _enter,\n\t  activate: _enter,\n\t  remove: function remove (vnode, rm) {\n\t    /* istanbul ignore else */\n\t    if (!vnode.data.show) {\n\t      leave(vnode, rm);\n\t    } else {\n\t      rm();\n\t    }\n\t  }\n\t} : {};\n\t\n\tvar platformModules = [\n\t  attrs,\n\t  klass,\n\t  events,\n\t  domProps,\n\t  style,\n\t  transition\n\t];\n\t\n\t/*  */\n\t\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\t\n\tvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\t\n\t/**\n\t * Not type checking this file because flow doesn't like attaching\n\t * properties to Elements.\n\t */\n\t\n\tvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\t\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t  // http://www.matts411.com/post/internet-explorer-9-oninput/\n\t  document.addEventListener('selectionchange', function () {\n\t    var el = document.activeElement;\n\t    if (el && el.vmodel) {\n\t      trigger(el, 'input');\n\t    }\n\t  });\n\t}\n\t\n\tvar model = {\n\t  inserted: function inserted (el, binding, vnode) {\n\t    if (false) {\n\t      if (!modelableTagRE.test(vnode.tag)) {\n\t        warn(\n\t          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n\t          'If you are working with contenteditable, it\\'s recommended to ' +\n\t          'wrap a library dedicated for that purpose inside a custom component.',\n\t          vnode.context\n\t        );\n\t      }\n\t    }\n\t    if (vnode.tag === 'select') {\n\t      var cb = function () {\n\t        setSelected(el, binding, vnode.context);\n\t      };\n\t      cb();\n\t      /* istanbul ignore if */\n\t      if (isIE || isEdge) {\n\t        setTimeout(cb, 0);\n\t      }\n\t    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n\t      el._vModifiers = binding.modifiers;\n\t      if (!binding.modifiers.lazy) {\n\t        if (!isAndroid) {\n\t          el.addEventListener('compositionstart', onCompositionStart);\n\t          el.addEventListener('compositionend', onCompositionEnd);\n\t        }\n\t        /* istanbul ignore if */\n\t        if (isIE9) {\n\t          el.vmodel = true;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  componentUpdated: function componentUpdated (el, binding, vnode) {\n\t    if (vnode.tag === 'select') {\n\t      setSelected(el, binding, vnode.context);\n\t      // in case the options rendered by v-for have changed,\n\t      // it's possible that the value is out-of-sync with the rendered options.\n\t      // detect such cases and filter out values that no longer has a matching\n\t      // option in the DOM.\n\t      var needReset = el.multiple\n\t        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n\t        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t      if (needReset) {\n\t        trigger(el, 'change');\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction setSelected (el, binding, vm) {\n\t  var value = binding.value;\n\t  var isMultiple = el.multiple;\n\t  if (isMultiple && !Array.isArray(value)) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n\t      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var selected, option;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    option = el.options[i];\n\t    if (isMultiple) {\n\t      selected = looseIndexOf(value, getValue(option)) > -1;\n\t      if (option.selected !== selected) {\n\t        option.selected = selected;\n\t      }\n\t    } else {\n\t      if (looseEqual(getValue(option), value)) {\n\t        if (el.selectedIndex !== i) {\n\t          el.selectedIndex = i;\n\t        }\n\t        return\n\t      }\n\t    }\n\t  }\n\t  if (!isMultiple) {\n\t    el.selectedIndex = -1;\n\t  }\n\t}\n\t\n\tfunction hasNoMatchingOption (value, options) {\n\t  for (var i = 0, l = options.length; i < l; i++) {\n\t    if (looseEqual(getValue(options[i]), value)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\tfunction getValue (option) {\n\t  return '_value' in option\n\t    ? option._value\n\t    : option.value\n\t}\n\t\n\tfunction onCompositionStart (e) {\n\t  e.target.composing = true;\n\t}\n\t\n\tfunction onCompositionEnd (e) {\n\t  e.target.composing = false;\n\t  trigger(e.target, 'input');\n\t}\n\t\n\tfunction trigger (el, type) {\n\t  var e = document.createEvent('HTMLEvents');\n\t  e.initEvent(type, true, true);\n\t  el.dispatchEvent(e);\n\t}\n\t\n\t/*  */\n\t\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode (vnode) {\n\t  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n\t    ? locateNode(vnode.componentInstance._vnode)\n\t    : vnode\n\t}\n\t\n\tvar show = {\n\t  bind: function bind (el, ref, vnode) {\n\t    var value = ref.value;\n\t\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    var originalDisplay = el.__vOriginalDisplay =\n\t      el.style.display === 'none' ? '' : el.style.display;\n\t    if (value && transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      enter(vnode, function () {\n\t        el.style.display = originalDisplay;\n\t      });\n\t    } else {\n\t      el.style.display = value ? originalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  update: function update (el, ref, vnode) {\n\t    var value = ref.value;\n\t    var oldValue = ref.oldValue;\n\t\n\t    /* istanbul ignore if */\n\t    if (value === oldValue) { return }\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (transition && !isIE9) {\n\t      vnode.data.show = true;\n\t      if (value) {\n\t        enter(vnode, function () {\n\t          el.style.display = el.__vOriginalDisplay;\n\t        });\n\t      } else {\n\t        leave(vnode, function () {\n\t          el.style.display = 'none';\n\t        });\n\t      }\n\t    } else {\n\t      el.style.display = value ? el.__vOriginalDisplay : 'none';\n\t    }\n\t  },\n\t\n\t  unbind: function unbind (\n\t    el,\n\t    binding,\n\t    vnode,\n\t    oldVnode,\n\t    isDestroy\n\t  ) {\n\t    if (!isDestroy) {\n\t      el.style.display = el.__vOriginalDisplay;\n\t    }\n\t  }\n\t};\n\t\n\tvar platformDirectives = {\n\t  model: model,\n\t  show: show\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\t\n\tvar transitionProps = {\n\t  name: String,\n\t  appear: Boolean,\n\t  css: Boolean,\n\t  mode: String,\n\t  type: String,\n\t  enterClass: String,\n\t  leaveClass: String,\n\t  enterToClass: String,\n\t  leaveToClass: String,\n\t  enterActiveClass: String,\n\t  leaveActiveClass: String,\n\t  appearClass: String,\n\t  appearActiveClass: String,\n\t  appearToClass: String\n\t};\n\t\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild (vnode) {\n\t  var compOptions = vnode && vnode.componentOptions;\n\t  if (compOptions && compOptions.Ctor.options.abstract) {\n\t    return getRealChild(getFirstComponentChild(compOptions.children))\n\t  } else {\n\t    return vnode\n\t  }\n\t}\n\t\n\tfunction extractTransitionData (comp) {\n\t  var data = {};\n\t  var options = comp.$options;\n\t  // props\n\t  for (var key in options.propsData) {\n\t    data[key] = comp[key];\n\t  }\n\t  // events.\n\t  // extract listeners and pass them directly to the transition methods\n\t  var listeners = options._parentListeners;\n\t  for (var key$1 in listeners) {\n\t    data[camelize(key$1)] = listeners[key$1].fn;\n\t  }\n\t  return data\n\t}\n\t\n\tfunction placeholder (h, rawChild) {\n\t  return /\\d-keep-alive$/.test(rawChild.tag)\n\t    ? h('keep-alive')\n\t    : null\n\t}\n\t\n\tfunction hasParentTransition (vnode) {\n\t  while ((vnode = vnode.parent)) {\n\t    if (vnode.data.transition) {\n\t      return true\n\t    }\n\t  }\n\t}\n\t\n\tfunction isSameChild (child, oldChild) {\n\t  return oldChild.key === child.key && oldChild.tag === child.tag\n\t}\n\t\n\tvar Transition = {\n\t  name: 'transition',\n\t  props: transitionProps,\n\t  abstract: true,\n\t\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var children = this.$slots.default;\n\t    if (!children) {\n\t      return\n\t    }\n\t\n\t    // filter out text nodes (possible whitespaces)\n\t    children = children.filter(function (c) { return c.tag; });\n\t    /* istanbul ignore if */\n\t    if (!children.length) {\n\t      return\n\t    }\n\t\n\t    // warn multiple elements\n\t    if (false) {\n\t      warn(\n\t        '<transition> can only be used on a single element. Use ' +\n\t        '<transition-group> for lists.',\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var mode = this.mode;\n\t\n\t    // warn invalid mode\n\t    if (false) {\n\t      warn(\n\t        'invalid <transition> mode: ' + mode,\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var rawChild = children[0];\n\t\n\t    // if this is a component root node and the component's\n\t    // parent container node also has transition, skip.\n\t    if (hasParentTransition(this.$vnode)) {\n\t      return rawChild\n\t    }\n\t\n\t    // apply transition data to child\n\t    // use getRealChild() to ignore abstract components e.g. keep-alive\n\t    var child = getRealChild(rawChild);\n\t    /* istanbul ignore if */\n\t    if (!child) {\n\t      return rawChild\n\t    }\n\t\n\t    if (this._leaving) {\n\t      return placeholder(h, rawChild)\n\t    }\n\t\n\t    // ensure a key that is unique to the vnode type and to this transition\n\t    // component instance. This key will be used to remove pending leaving nodes\n\t    // during entering.\n\t    var id = \"__transition-\" + (this._uid) + \"-\";\n\t    var key = child.key = child.key == null\n\t      ? id + child.tag\n\t      : isPrimitive(child.key)\n\t        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n\t        : child.key;\n\t    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t    var oldRawChild = this._vnode;\n\t    var oldChild = getRealChild(oldRawChild);\n\t\n\t    // mark v-show\n\t    // so that the transition module can hand over the control to the directive\n\t    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n\t      child.data.show = true;\n\t    }\n\t\n\t    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t      // replace old child transition data with fresh one\n\t      // important for dynamic transitions!\n\t      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t      // handle transition mode\n\t      if (mode === 'out-in') {\n\t        // return placeholder node and queue update when leave finishes\n\t        this._leaving = true;\n\t        mergeVNodeHook(oldData, 'afterLeave', function () {\n\t          this$1._leaving = false;\n\t          this$1.$forceUpdate();\n\t        }, key);\n\t        return placeholder(h, rawChild)\n\t      } else if (mode === 'in-out') {\n\t        var delayedLeave;\n\t        var performLeave = function () { delayedLeave(); };\n\t        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n\t        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n\t        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t          delayedLeave = leave;\n\t        }, key);\n\t      }\n\t    }\n\t\n\t    return rawChild\n\t  }\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\t\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final disired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\t\n\tvar props = extend({\n\t  tag: String,\n\t  moveClass: String\n\t}, transitionProps);\n\t\n\tdelete props.mode;\n\t\n\tvar TransitionGroup = {\n\t  props: props,\n\t\n\t  render: function render (h) {\n\t    var tag = this.tag || this.$vnode.data.tag || 'span';\n\t    var map = Object.create(null);\n\t    var prevChildren = this.prevChildren = this.children;\n\t    var rawChildren = this.$slots.default || [];\n\t    var children = this.children = [];\n\t    var transitionData = extractTransitionData(this);\n\t\n\t    for (var i = 0; i < rawChildren.length; i++) {\n\t      var c = rawChildren[i];\n\t      if (c.tag) {\n\t        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t          children.push(c);\n\t          map[c.key] = c\n\t          ;(c.data || (c.data = {})).transition = transitionData;\n\t        } else if (false) {\n\t          var opts = c.componentOptions;\n\t          var name = opts\n\t            ? (opts.Ctor.options.name || opts.tag)\n\t            : c.tag;\n\t          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n\t        }\n\t      }\n\t    }\n\t\n\t    if (prevChildren) {\n\t      var kept = [];\n\t      var removed = [];\n\t      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t        var c$1 = prevChildren[i$1];\n\t        c$1.data.transition = transitionData;\n\t        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\t        if (map[c$1.key]) {\n\t          kept.push(c$1);\n\t        } else {\n\t          removed.push(c$1);\n\t        }\n\t      }\n\t      this.kept = h(tag, null, kept);\n\t      this.removed = removed;\n\t    }\n\t\n\t    return h(tag, null, children)\n\t  },\n\t\n\t  beforeUpdate: function beforeUpdate () {\n\t    // force removing pass\n\t    this.__patch__(\n\t      this._vnode,\n\t      this.kept,\n\t      false, // hydrating\n\t      true // removeOnly (!important, avoids unnecessary moves)\n\t    );\n\t    this._vnode = this.kept;\n\t  },\n\t\n\t  updated: function updated () {\n\t    var children = this.prevChildren;\n\t    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n\t    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t      return\n\t    }\n\t\n\t    // we divide the work into three loops to avoid mixing DOM reads and writes\n\t    // in each iteration - which helps prevent layout thrashing.\n\t    children.forEach(callPendingCbs);\n\t    children.forEach(recordPosition);\n\t    children.forEach(applyTranslation);\n\t\n\t    // force reflow to put everything in position\n\t    var f = document.body.offsetHeight; // eslint-disable-line\n\t\n\t    children.forEach(function (c) {\n\t      if (c.data.moved) {\n\t        var el = c.elm;\n\t        var s = el.style;\n\t        addTransitionClass(el, moveClass);\n\t        s.transform = s.WebkitTransform = s.transitionDuration = '';\n\t        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n\t          if (!e || /transform$/.test(e.propertyName)) {\n\t            el.removeEventListener(transitionEndEvent, cb);\n\t            el._moveCb = null;\n\t            removeTransitionClass(el, moveClass);\n\t          }\n\t        });\n\t      }\n\t    });\n\t  },\n\t\n\t  methods: {\n\t    hasMove: function hasMove (el, moveClass) {\n\t      /* istanbul ignore if */\n\t      if (!hasTransition) {\n\t        return false\n\t      }\n\t      if (this._hasMove != null) {\n\t        return this._hasMove\n\t      }\n\t      addTransitionClass(el, moveClass);\n\t      var info = getTransitionInfo(el);\n\t      removeTransitionClass(el, moveClass);\n\t      return (this._hasMove = info.hasTransform)\n\t    }\n\t  }\n\t};\n\t\n\tfunction callPendingCbs (c) {\n\t  /* istanbul ignore if */\n\t  if (c.elm._moveCb) {\n\t    c.elm._moveCb();\n\t  }\n\t  /* istanbul ignore if */\n\t  if (c.elm._enterCb) {\n\t    c.elm._enterCb();\n\t  }\n\t}\n\t\n\tfunction recordPosition (c) {\n\t  c.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\t\n\tfunction applyTranslation (c) {\n\t  var oldPos = c.data.pos;\n\t  var newPos = c.data.newPos;\n\t  var dx = oldPos.left - newPos.left;\n\t  var dy = oldPos.top - newPos.top;\n\t  if (dx || dy) {\n\t    c.data.moved = true;\n\t    var s = c.elm.style;\n\t    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t    s.transitionDuration = '0s';\n\t  }\n\t}\n\t\n\tvar platformComponents = {\n\t  Transition: Transition,\n\t  TransitionGroup: TransitionGroup\n\t};\n\t\n\t/*  */\n\t\n\t// install platform specific utils\n\tVue$3.config.isUnknownElement = isUnknownElement;\n\tVue$3.config.isReservedTag = isReservedTag;\n\tVue$3.config.getTagNamespace = getTagNamespace;\n\tVue$3.config.mustUseProp = mustUseProp;\n\t\n\t// install platform runtime directives & components\n\textend(Vue$3.options.directives, platformDirectives);\n\textend(Vue$3.options.components, platformComponents);\n\t\n\t// install platform patch function\n\tVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\t\n\t// wrap mount\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && inBrowser ? query(el) : undefined;\n\t  return this._mount(el, hydrating)\n\t};\n\t\n\tif (false) {\n\t  console[console.info ? 'info' : 'log'](\n\t    \"You are running Vue in development mode.\\n\" +\n\t    \"Make sure to turn on production mode when deploying for production.\\n\" +\n\t    \"See more tips at https://vuejs.org/guide/deployment.html\"\n\t  );\n\t}\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue$3);\n\t    } else if (\n\t      false\n\t    ) {\n\t      console[console.info ? 'info' : 'log'](\n\t        'Download the Vue Devtools extension for a better development experience:\\n' +\n\t        'https://github.com/vuejs/vue-devtools'\n\t      );\n\t    }\n\t  }\n\t}, 0);\n\t\n\t/*  */\n\t\n\t// check whether current browser encodes a char inside attribute values\n\tfunction shouldDecode (content, encoded) {\n\t  var div = document.createElement('div');\n\t  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n\t  return div.innerHTML.indexOf(encoded) > 0\n\t}\n\t\n\t// #3663\n\t// IE encodes newlines inside attribute values while other browsers don't\n\tvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\t\n\t/*  */\n\t\n\tvar decoder;\n\t\n\tfunction decode (html) {\n\t  decoder = decoder || document.createElement('div');\n\t  decoder.innerHTML = html;\n\t  return decoder.textContent\n\t}\n\t\n\t/*  */\n\t\n\tvar isUnaryTag = makeMap(\n\t  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n\t  'link,meta,param,source,track,wbr',\n\t  true\n\t);\n\t\n\t// Elements that you can, intentionally, leave open\n\t// (and which close themselves)\n\tvar canBeLeftOpenTag = makeMap(\n\t  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n\t  true\n\t);\n\t\n\t// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n\t// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\tvar isNonPhrasingTag = makeMap(\n\t  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n\t  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n\t  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n\t  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n\t  'title,tr,track',\n\t  true\n\t);\n\t\n\t/**\n\t * Not type-checking this file because it's mostly vendor code.\n\t */\n\t\n\t/*!\n\t * HTML Parser By John Resig (ejohn.org)\n\t * Modified by Juriy \"kangax\" Zaytsev\n\t * Original code by Erik Arvidsson, Mozilla Public License\n\t * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n\t */\n\t\n\t// Regular Expressions for parsing tags and attributes\n\tvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\n\tvar singleAttrAssign = /(?:=)/;\n\tvar singleAttrValues = [\n\t  // attr value double quotes\n\t  /\"([^\"]*)\"+/.source,\n\t  // attr value, single quotes\n\t  /'([^']*)'+/.source,\n\t  // attr value, no quotes\n\t  /([^\\s\"'=<>`]+)/.source\n\t];\n\tvar attribute = new RegExp(\n\t  '^\\\\s*' + singleAttrIdentifier.source +\n\t  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n\t  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n\t);\n\t\n\t// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n\t// but for Vue templates we can enforce a simple charset\n\tvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n\tvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n\tvar startTagOpen = new RegExp('^<' + qnameCapture);\n\tvar startTagClose = /^\\s*(\\/?)>/;\n\tvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n\tvar doctype = /^<!DOCTYPE [^>]+>/i;\n\tvar comment = /^<!--/;\n\tvar conditionalComment = /^<!\\[/;\n\t\n\tvar IS_REGEX_CAPTURING_BROKEN = false;\n\t'x'.replace(/x(.)?/g, function (m, g) {\n\t  IS_REGEX_CAPTURING_BROKEN = g === '';\n\t});\n\t\n\t// Special Elements (can contain anything)\n\tvar isScriptOrStyle = makeMap('script,style', true);\n\tvar reCache = {};\n\t\n\tvar ltRE = /&lt;/g;\n\tvar gtRE = /&gt;/g;\n\tvar nlRE = /&#10;/g;\n\tvar ampRE = /&amp;/g;\n\tvar quoteRE = /&quot;/g;\n\t\n\tfunction decodeAttr (value, shouldDecodeNewlines) {\n\t  if (shouldDecodeNewlines) {\n\t    value = value.replace(nlRE, '\\n');\n\t  }\n\t  return value\n\t    .replace(ltRE, '<')\n\t    .replace(gtRE, '>')\n\t    .replace(ampRE, '&')\n\t    .replace(quoteRE, '\"')\n\t}\n\t\n\tfunction parseHTML (html, options) {\n\t  var stack = [];\n\t  var expectHTML = options.expectHTML;\n\t  var isUnaryTag$$1 = options.isUnaryTag || no;\n\t  var index = 0;\n\t  var last, lastTag;\n\t  while (html) {\n\t    last = html;\n\t    // Make sure we're not in a script or style element\n\t    if (!lastTag || !isScriptOrStyle(lastTag)) {\n\t      var textEnd = html.indexOf('<');\n\t      if (textEnd === 0) {\n\t        // Comment:\n\t        if (comment.test(html)) {\n\t          var commentEnd = html.indexOf('-->');\n\t\n\t          if (commentEnd >= 0) {\n\t            advance(commentEnd + 3);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\t        if (conditionalComment.test(html)) {\n\t          var conditionalEnd = html.indexOf(']>');\n\t\n\t          if (conditionalEnd >= 0) {\n\t            advance(conditionalEnd + 2);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // Doctype:\n\t        var doctypeMatch = html.match(doctype);\n\t        if (doctypeMatch) {\n\t          advance(doctypeMatch[0].length);\n\t          continue\n\t        }\n\t\n\t        // End tag:\n\t        var endTagMatch = html.match(endTag);\n\t        if (endTagMatch) {\n\t          var curIndex = index;\n\t          advance(endTagMatch[0].length);\n\t          parseEndTag(endTagMatch[1], curIndex, index);\n\t          continue\n\t        }\n\t\n\t        // Start tag:\n\t        var startTagMatch = parseStartTag();\n\t        if (startTagMatch) {\n\t          handleStartTag(startTagMatch);\n\t          continue\n\t        }\n\t      }\n\t\n\t      var text = (void 0), rest$1 = (void 0), next = (void 0);\n\t      if (textEnd > 0) {\n\t        rest$1 = html.slice(textEnd);\n\t        while (\n\t          !endTag.test(rest$1) &&\n\t          !startTagOpen.test(rest$1) &&\n\t          !comment.test(rest$1) &&\n\t          !conditionalComment.test(rest$1)\n\t        ) {\n\t          // < in plain text, be forgiving and treat it as text\n\t          next = rest$1.indexOf('<', 1);\n\t          if (next < 0) { break }\n\t          textEnd += next;\n\t          rest$1 = html.slice(textEnd);\n\t        }\n\t        text = html.substring(0, textEnd);\n\t        advance(textEnd);\n\t      }\n\t\n\t      if (textEnd < 0) {\n\t        text = html;\n\t        html = '';\n\t      }\n\t\n\t      if (options.chars && text) {\n\t        options.chars(text);\n\t      }\n\t    } else {\n\t      var stackedTag = lastTag.toLowerCase();\n\t      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n\t      var endTagLength = 0;\n\t      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n\t        endTagLength = endTag.length;\n\t        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n\t          text = text\n\t            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n\t            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n\t        }\n\t        if (options.chars) {\n\t          options.chars(text);\n\t        }\n\t        return ''\n\t      });\n\t      index += html.length - rest.length;\n\t      html = rest;\n\t      parseEndTag(stackedTag, index - endTagLength, index);\n\t    }\n\t\n\t    if (html === last && options.chars) {\n\t      options.chars(html);\n\t      break\n\t    }\n\t  }\n\t\n\t  // Clean up any remaining tags\n\t  parseEndTag();\n\t\n\t  function advance (n) {\n\t    index += n;\n\t    html = html.substring(n);\n\t  }\n\t\n\t  function parseStartTag () {\n\t    var start = html.match(startTagOpen);\n\t    if (start) {\n\t      var match = {\n\t        tagName: start[1],\n\t        attrs: [],\n\t        start: index\n\t      };\n\t      advance(start[0].length);\n\t      var end, attr;\n\t      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n\t        advance(attr[0].length);\n\t        match.attrs.push(attr);\n\t      }\n\t      if (end) {\n\t        match.unarySlash = end[1];\n\t        advance(end[0].length);\n\t        match.end = index;\n\t        return match\n\t      }\n\t    }\n\t  }\n\t\n\t  function handleStartTag (match) {\n\t    var tagName = match.tagName;\n\t    var unarySlash = match.unarySlash;\n\t\n\t    if (expectHTML) {\n\t      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n\t        parseEndTag(lastTag);\n\t      }\n\t      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n\t        parseEndTag(tagName);\n\t      }\n\t    }\n\t\n\t    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\t\n\t    var l = match.attrs.length;\n\t    var attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      var args = match.attrs[i];\n\t      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\t      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n\t        if (args[3] === '') { delete args[3]; }\n\t        if (args[4] === '') { delete args[4]; }\n\t        if (args[5] === '') { delete args[5]; }\n\t      }\n\t      var value = args[3] || args[4] || args[5] || '';\n\t      attrs[i] = {\n\t        name: args[1],\n\t        value: decodeAttr(\n\t          value,\n\t          options.shouldDecodeNewlines\n\t        )\n\t      };\n\t    }\n\t\n\t    if (!unary) {\n\t      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n\t      lastTag = tagName;\n\t      unarySlash = '';\n\t    }\n\t\n\t    if (options.start) {\n\t      options.start(tagName, attrs, unary, match.start, match.end);\n\t    }\n\t  }\n\t\n\t  function parseEndTag (tagName, start, end) {\n\t    var pos, lowerCasedTagName;\n\t    if (start == null) { start = index; }\n\t    if (end == null) { end = index; }\n\t\n\t    if (tagName) {\n\t      lowerCasedTagName = tagName.toLowerCase();\n\t    }\n\t\n\t    // Find the closest opened tag of the same type\n\t    if (tagName) {\n\t      for (pos = stack.length - 1; pos >= 0; pos--) {\n\t        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n\t          break\n\t        }\n\t      }\n\t    } else {\n\t      // If no tag name is provided, clean shop\n\t      pos = 0;\n\t    }\n\t\n\t    if (pos >= 0) {\n\t      // Close all the open elements, up the stack\n\t      for (var i = stack.length - 1; i >= pos; i--) {\n\t        if (options.end) {\n\t          options.end(stack[i].tag, start, end);\n\t        }\n\t      }\n\t\n\t      // Remove the open elements from the stack\n\t      stack.length = pos;\n\t      lastTag = pos && stack[pos - 1].tag;\n\t    } else if (lowerCasedTagName === 'br') {\n\t      if (options.start) {\n\t        options.start(tagName, [], true, start, end);\n\t      }\n\t    } else if (lowerCasedTagName === 'p') {\n\t      if (options.start) {\n\t        options.start(tagName, [], false, start, end);\n\t      }\n\t      if (options.end) {\n\t        options.end(tagName, start, end);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction parseFilters (exp) {\n\t  var inSingle = false;\n\t  var inDouble = false;\n\t  var inTemplateString = false;\n\t  var inRegex = false;\n\t  var curly = 0;\n\t  var square = 0;\n\t  var paren = 0;\n\t  var lastFilterIndex = 0;\n\t  var c, prev, i, expression, filters;\n\t\n\t  for (i = 0; i < exp.length; i++) {\n\t    prev = c;\n\t    c = exp.charCodeAt(i);\n\t    if (inSingle) {\n\t      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n\t    } else if (inDouble) {\n\t      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n\t    } else if (inTemplateString) {\n\t      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n\t    } else if (inRegex) {\n\t      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n\t    } else if (\n\t      c === 0x7C && // pipe\n\t      exp.charCodeAt(i + 1) !== 0x7C &&\n\t      exp.charCodeAt(i - 1) !== 0x7C &&\n\t      !curly && !square && !paren\n\t    ) {\n\t      if (expression === undefined) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        expression = exp.slice(0, i).trim();\n\t      } else {\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22: inDouble = true; break         // \"\n\t        case 0x27: inSingle = true; break         // '\n\t        case 0x60: inTemplateString = true; break // `\n\t        case 0x28: paren++; break                 // (\n\t        case 0x29: paren--; break                 // )\n\t        case 0x5B: square++; break                // [\n\t        case 0x5D: square--; break                // ]\n\t        case 0x7B: curly++; break                 // {\n\t        case 0x7D: curly--; break                 // }\n\t      }\n\t      if (c === 0x2f) { // /\n\t        var j = i - 1;\n\t        var p = (void 0);\n\t        // find first non-whitespace prev char\n\t        for (; j >= 0; j--) {\n\t          p = exp.charAt(j);\n\t          if (p !== ' ') { break }\n\t        }\n\t        if (!p || !/[\\w$]/.test(p)) {\n\t          inRegex = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (expression === undefined) {\n\t    expression = exp.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  function pushFilter () {\n\t    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n\t    lastFilterIndex = i + 1;\n\t  }\n\t\n\t  if (filters) {\n\t    for (i = 0; i < filters.length; i++) {\n\t      expression = wrapFilter(expression, filters[i]);\n\t    }\n\t  }\n\t\n\t  return expression\n\t}\n\t\n\tfunction wrapFilter (exp, filter) {\n\t  var i = filter.indexOf('(');\n\t  if (i < 0) {\n\t    // _f: resolveFilter\n\t    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n\t  } else {\n\t    var name = filter.slice(0, i);\n\t    var args = filter.slice(i + 1);\n\t    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\t\n\tvar buildRegex = cached(function (delimiters) {\n\t  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n\t  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n\t  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n\t});\n\t\n\tfunction parseText (\n\t  text,\n\t  delimiters\n\t) {\n\t  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\t  if (!tagRE.test(text)) {\n\t    return\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index;\n\t  while ((match = tagRE.exec(text))) {\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n\t    }\n\t    // tag token\n\t    var exp = parseFilters(match[1].trim());\n\t    tokens.push((\"_s(\" + exp + \")\"));\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push(JSON.stringify(text.slice(lastIndex)));\n\t  }\n\t  return tokens.join('+')\n\t}\n\t\n\t/*  */\n\t\n\tfunction baseWarn (msg) {\n\t  console.error((\"[Vue parser]: \" + msg));\n\t}\n\t\n\tfunction pluckModuleFunction (\n\t  modules,\n\t  key\n\t) {\n\t  return modules\n\t    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n\t    : []\n\t}\n\t\n\tfunction addProp (el, name, value) {\n\t  (el.props || (el.props = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addAttr (el, name, value) {\n\t  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addDirective (\n\t  el,\n\t  name,\n\t  rawName,\n\t  value,\n\t  arg,\n\t  modifiers\n\t) {\n\t  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n\t}\n\t\n\tfunction addHandler (\n\t  el,\n\t  name,\n\t  value,\n\t  modifiers,\n\t  important\n\t) {\n\t  // check capture modifier\n\t  if (modifiers && modifiers.capture) {\n\t    delete modifiers.capture;\n\t    name = '!' + name; // mark the event as captured\n\t  }\n\t  if (modifiers && modifiers.once) {\n\t    delete modifiers.once;\n\t    name = '~' + name; // mark the event as once\n\t  }\n\t  var events;\n\t  if (modifiers && modifiers.native) {\n\t    delete modifiers.native;\n\t    events = el.nativeEvents || (el.nativeEvents = {});\n\t  } else {\n\t    events = el.events || (el.events = {});\n\t  }\n\t  var newHandler = { value: value, modifiers: modifiers };\n\t  var handlers = events[name];\n\t  /* istanbul ignore if */\n\t  if (Array.isArray(handlers)) {\n\t    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n\t  } else if (handlers) {\n\t    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n\t  } else {\n\t    events[name] = newHandler;\n\t  }\n\t}\n\t\n\tfunction getBindingAttr (\n\t  el,\n\t  name,\n\t  getStatic\n\t) {\n\t  var dynamicValue =\n\t    getAndRemoveAttr(el, ':' + name) ||\n\t    getAndRemoveAttr(el, 'v-bind:' + name);\n\t  if (dynamicValue != null) {\n\t    return parseFilters(dynamicValue)\n\t  } else if (getStatic !== false) {\n\t    var staticValue = getAndRemoveAttr(el, name);\n\t    if (staticValue != null) {\n\t      return JSON.stringify(staticValue)\n\t    }\n\t  }\n\t}\n\t\n\tfunction getAndRemoveAttr (el, name) {\n\t  var val;\n\t  if ((val = el.attrsMap[name]) != null) {\n\t    var list = el.attrsList;\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      if (list[i].name === name) {\n\t        list.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t  }\n\t  return val\n\t}\n\t\n\tvar len;\n\tvar str;\n\tvar chr;\n\tvar index$1;\n\tvar expressionPos;\n\tvar expressionEndPos;\n\t\n\t/**\n\t * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n\t *\n\t * for loop possible cases:\n\t *\n\t * - test\n\t * - test[idx]\n\t * - test[test1[idx]]\n\t * - test[\"a\"][idx]\n\t * - xxx.test[a[a].test1[idx]]\n\t * - test.xxx.a[\"asa\"][test1[idx]]\n\t *\n\t */\n\t\n\tfunction parseModel (val) {\n\t  str = val;\n\t  len = str.length;\n\t  index$1 = expressionPos = expressionEndPos = 0;\n\t\n\t  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n\t    return {\n\t      exp: val,\n\t      idx: null\n\t    }\n\t  }\n\t\n\t  while (!eof()) {\n\t    chr = next();\n\t    /* istanbul ignore if */\n\t    if (isStringStart(chr)) {\n\t      parseString(chr);\n\t    } else if (chr === 0x5B) {\n\t      parseBracket(chr);\n\t    }\n\t  }\n\t\n\t  return {\n\t    exp: val.substring(0, expressionPos),\n\t    idx: val.substring(expressionPos + 1, expressionEndPos)\n\t  }\n\t}\n\t\n\tfunction next () {\n\t  return str.charCodeAt(++index$1)\n\t}\n\t\n\tfunction eof () {\n\t  return index$1 >= len\n\t}\n\t\n\tfunction isStringStart (chr) {\n\t  return chr === 0x22 || chr === 0x27\n\t}\n\t\n\tfunction parseBracket (chr) {\n\t  var inBracket = 1;\n\t  expressionPos = index$1;\n\t  while (!eof()) {\n\t    chr = next();\n\t    if (isStringStart(chr)) {\n\t      parseString(chr);\n\t      continue\n\t    }\n\t    if (chr === 0x5B) { inBracket++; }\n\t    if (chr === 0x5D) { inBracket--; }\n\t    if (inBracket === 0) {\n\t      expressionEndPos = index$1;\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseString (chr) {\n\t  var stringQuote = chr;\n\t  while (!eof()) {\n\t    chr = next();\n\t    if (chr === stringQuote) {\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar dirRE = /^v-|^@|^:/;\n\tvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n\tvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\tvar bindRE = /^:|^v-bind:/;\n\tvar onRE = /^@|^v-on:/;\n\tvar argRE = /:(.*)$/;\n\tvar modifierRE = /\\.[^.]+/g;\n\t\n\tvar decodeHTMLCached = cached(decode);\n\t\n\t// configurable state\n\tvar warn$1;\n\tvar platformGetTagNamespace;\n\tvar platformMustUseProp;\n\tvar platformIsPreTag;\n\tvar preTransforms;\n\tvar transforms;\n\tvar postTransforms;\n\tvar delimiters;\n\t\n\t/**\n\t * Convert HTML string to AST.\n\t */\n\tfunction parse (\n\t  template,\n\t  options\n\t) {\n\t  warn$1 = options.warn || baseWarn;\n\t  platformGetTagNamespace = options.getTagNamespace || no;\n\t  platformMustUseProp = options.mustUseProp || no;\n\t  platformIsPreTag = options.isPreTag || no;\n\t  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n\t  transforms = pluckModuleFunction(options.modules, 'transformNode');\n\t  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\t  delimiters = options.delimiters;\n\t  var stack = [];\n\t  var preserveWhitespace = options.preserveWhitespace !== false;\n\t  var root;\n\t  var currentParent;\n\t  var inVPre = false;\n\t  var inPre = false;\n\t  var warned = false;\n\t  parseHTML(template, {\n\t    expectHTML: options.expectHTML,\n\t    isUnaryTag: options.isUnaryTag,\n\t    shouldDecodeNewlines: options.shouldDecodeNewlines,\n\t    start: function start (tag, attrs, unary) {\n\t      // check namespace.\n\t      // inherit parent ns if there is one\n\t      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\t\n\t      // handle IE svg bug\n\t      /* istanbul ignore if */\n\t      if (isIE && ns === 'svg') {\n\t        attrs = guardIESVGBug(attrs);\n\t      }\n\t\n\t      var element = {\n\t        type: 1,\n\t        tag: tag,\n\t        attrsList: attrs,\n\t        attrsMap: makeAttrsMap(attrs),\n\t        parent: currentParent,\n\t        children: []\n\t      };\n\t      if (ns) {\n\t        element.ns = ns;\n\t      }\n\t\n\t      if (isForbiddenTag(element) && !isServerRendering()) {\n\t        element.forbidden = true;\n\t        (\"production\") !== 'production' && warn$1(\n\t          'Templates should only be responsible for mapping the state to the ' +\n\t          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n\t          \"<\" + tag + \">\" + ', as they will not be parsed.'\n\t        );\n\t      }\n\t\n\t      // apply pre-transforms\n\t      for (var i = 0; i < preTransforms.length; i++) {\n\t        preTransforms[i](element, options);\n\t      }\n\t\n\t      if (!inVPre) {\n\t        processPre(element);\n\t        if (element.pre) {\n\t          inVPre = true;\n\t        }\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = true;\n\t      }\n\t      if (inVPre) {\n\t        processRawAttrs(element);\n\t      } else {\n\t        processFor(element);\n\t        processIf(element);\n\t        processOnce(element);\n\t        processKey(element);\n\t\n\t        // determine whether this is a plain element after\n\t        // removing structural attributes\n\t        element.plain = !element.key && !attrs.length;\n\t\n\t        processRef(element);\n\t        processSlot(element);\n\t        processComponent(element);\n\t        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n\t          transforms[i$1](element, options);\n\t        }\n\t        processAttrs(element);\n\t      }\n\t\n\t      function checkRootConstraints (el) {\n\t        if (false) {\n\t          if (el.tag === 'slot' || el.tag === 'template') {\n\t            warned = true;\n\t            warn$1(\n\t              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n\t              'contain multiple nodes:\\n' + template\n\t            );\n\t          }\n\t          if (el.attrsMap.hasOwnProperty('v-for')) {\n\t            warned = true;\n\t            warn$1(\n\t              'Cannot use v-for on stateful component root element because ' +\n\t              'it renders multiple elements:\\n' + template\n\t            );\n\t          }\n\t        }\n\t      }\n\t\n\t      // tree management\n\t      if (!root) {\n\t        root = element;\n\t        checkRootConstraints(root);\n\t      } else if (!stack.length) {\n\t        // allow root elements with v-if, v-else-if and v-else\n\t        if (root.if && (element.elseif || element.else)) {\n\t          checkRootConstraints(element);\n\t          addIfCondition(root, {\n\t            exp: element.elseif,\n\t            block: element\n\t          });\n\t        } else if (false) {\n\t          warned = true;\n\t          warn$1(\n\t            \"Component template should contain exactly one root element:\" +\n\t            \"\\n\\n\" + template + \"\\n\\n\" +\n\t            \"If you are using v-if on multiple elements, \" +\n\t            \"use v-else-if to chain them instead.\"\n\t          );\n\t        }\n\t      }\n\t      if (currentParent && !element.forbidden) {\n\t        if (element.elseif || element.else) {\n\t          processIfConditions(element, currentParent);\n\t        } else if (element.slotScope) { // scoped slot\n\t          currentParent.plain = false;\n\t          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n\t        } else {\n\t          currentParent.children.push(element);\n\t          element.parent = currentParent;\n\t        }\n\t      }\n\t      if (!unary) {\n\t        currentParent = element;\n\t        stack.push(element);\n\t      }\n\t      // apply post-transforms\n\t      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n\t        postTransforms[i$2](element, options);\n\t      }\n\t    },\n\t\n\t    end: function end () {\n\t      // remove trailing whitespace\n\t      var element = stack[stack.length - 1];\n\t      var lastNode = element.children[element.children.length - 1];\n\t      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n\t        element.children.pop();\n\t      }\n\t      // pop stack\n\t      stack.length -= 1;\n\t      currentParent = stack[stack.length - 1];\n\t      // check pre state\n\t      if (element.pre) {\n\t        inVPre = false;\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = false;\n\t      }\n\t    },\n\t\n\t    chars: function chars (text) {\n\t      if (!currentParent) {\n\t        if (false) {\n\t          warned = true;\n\t          warn$1(\n\t            'Component template requires a root element, rather than just text:\\n\\n' + template\n\t          );\n\t        }\n\t        return\n\t      }\n\t      // IE textarea placeholder bug\n\t      /* istanbul ignore if */\n\t      if (isIE &&\n\t          currentParent.tag === 'textarea' &&\n\t          currentParent.attrsMap.placeholder === text) {\n\t        return\n\t      }\n\t      var children = currentParent.children;\n\t      text = inPre || text.trim()\n\t        ? decodeHTMLCached(text)\n\t        // only preserve whitespace if its not right after a starting tag\n\t        : preserveWhitespace && children.length ? ' ' : '';\n\t      if (text) {\n\t        var expression;\n\t        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n\t          children.push({\n\t            type: 2,\n\t            expression: expression,\n\t            text: text\n\t          });\n\t        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n\t          currentParent.children.push({\n\t            type: 3,\n\t            text: text\n\t          });\n\t        }\n\t      }\n\t    }\n\t  });\n\t  return root\n\t}\n\t\n\tfunction processPre (el) {\n\t  if (getAndRemoveAttr(el, 'v-pre') != null) {\n\t    el.pre = true;\n\t  }\n\t}\n\t\n\tfunction processRawAttrs (el) {\n\t  var l = el.attrsList.length;\n\t  if (l) {\n\t    var attrs = el.attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      attrs[i] = {\n\t        name: el.attrsList[i].name,\n\t        value: JSON.stringify(el.attrsList[i].value)\n\t      };\n\t    }\n\t  } else if (!el.pre) {\n\t    // non root node in pre blocks with no attributes\n\t    el.plain = true;\n\t  }\n\t}\n\t\n\tfunction processKey (el) {\n\t  var exp = getBindingAttr(el, 'key');\n\t  if (exp) {\n\t    if (false) {\n\t      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n\t    }\n\t    el.key = exp;\n\t  }\n\t}\n\t\n\tfunction processRef (el) {\n\t  var ref = getBindingAttr(el, 'ref');\n\t  if (ref) {\n\t    el.ref = ref;\n\t    el.refInFor = checkInFor(el);\n\t  }\n\t}\n\t\n\tfunction processFor (el) {\n\t  var exp;\n\t  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n\t    var inMatch = exp.match(forAliasRE);\n\t    if (!inMatch) {\n\t      (\"production\") !== 'production' && warn$1(\n\t        (\"Invalid v-for expression: \" + exp)\n\t      );\n\t      return\n\t    }\n\t    el.for = inMatch[2].trim();\n\t    var alias = inMatch[1].trim();\n\t    var iteratorMatch = alias.match(forIteratorRE);\n\t    if (iteratorMatch) {\n\t      el.alias = iteratorMatch[1].trim();\n\t      el.iterator1 = iteratorMatch[2].trim();\n\t      if (iteratorMatch[3]) {\n\t        el.iterator2 = iteratorMatch[3].trim();\n\t      }\n\t    } else {\n\t      el.alias = alias;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processIf (el) {\n\t  var exp = getAndRemoveAttr(el, 'v-if');\n\t  if (exp) {\n\t    el.if = exp;\n\t    addIfCondition(el, {\n\t      exp: exp,\n\t      block: el\n\t    });\n\t  } else {\n\t    if (getAndRemoveAttr(el, 'v-else') != null) {\n\t      el.else = true;\n\t    }\n\t    var elseif = getAndRemoveAttr(el, 'v-else-if');\n\t    if (elseif) {\n\t      el.elseif = elseif;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processIfConditions (el, parent) {\n\t  var prev = findPrevElement(parent.children);\n\t  if (prev && prev.if) {\n\t    addIfCondition(prev, {\n\t      exp: el.elseif,\n\t      block: el\n\t    });\n\t  } else if (false) {\n\t    warn$1(\n\t      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n\t      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n\t    );\n\t  }\n\t}\n\t\n\tfunction findPrevElement (children) {\n\t  var i = children.length;\n\t  while (i--) {\n\t    if (children[i].type === 1) {\n\t      return children[i]\n\t    } else {\n\t      if (false) {\n\t        warn$1(\n\t          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n\t          \"will be ignored.\"\n\t        );\n\t      }\n\t      children.pop();\n\t    }\n\t  }\n\t}\n\t\n\tfunction addIfCondition (el, condition) {\n\t  if (!el.ifConditions) {\n\t    el.ifConditions = [];\n\t  }\n\t  el.ifConditions.push(condition);\n\t}\n\t\n\tfunction processOnce (el) {\n\t  var once = getAndRemoveAttr(el, 'v-once');\n\t  if (once != null) {\n\t    el.once = true;\n\t  }\n\t}\n\t\n\tfunction processSlot (el) {\n\t  if (el.tag === 'slot') {\n\t    el.slotName = getBindingAttr(el, 'name');\n\t    if (false) {\n\t      warn$1(\n\t        \"`key` does not work on <slot> because slots are abstract outlets \" +\n\t        \"and can possibly expand into multiple elements. \" +\n\t        \"Use the key on a wrapping element instead.\"\n\t      );\n\t    }\n\t  } else {\n\t    var slotTarget = getBindingAttr(el, 'slot');\n\t    if (slotTarget) {\n\t      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n\t    }\n\t    if (el.tag === 'template') {\n\t      el.slotScope = getAndRemoveAttr(el, 'scope');\n\t    }\n\t  }\n\t}\n\t\n\tfunction processComponent (el) {\n\t  var binding;\n\t  if ((binding = getBindingAttr(el, 'is'))) {\n\t    el.component = binding;\n\t  }\n\t  if (getAndRemoveAttr(el, 'inline-template') != null) {\n\t    el.inlineTemplate = true;\n\t  }\n\t}\n\t\n\tfunction processAttrs (el) {\n\t  var list = el.attrsList;\n\t  var i, l, name, rawName, value, arg, modifiers, isProp;\n\t  for (i = 0, l = list.length; i < l; i++) {\n\t    name = rawName = list[i].name;\n\t    value = list[i].value;\n\t    if (dirRE.test(name)) {\n\t      // mark element as dynamic\n\t      el.hasBindings = true;\n\t      // modifiers\n\t      modifiers = parseModifiers(name);\n\t      if (modifiers) {\n\t        name = name.replace(modifierRE, '');\n\t      }\n\t      if (bindRE.test(name)) { // v-bind\n\t        name = name.replace(bindRE, '');\n\t        value = parseFilters(value);\n\t        isProp = false;\n\t        if (modifiers) {\n\t          if (modifiers.prop) {\n\t            isProp = true;\n\t            name = camelize(name);\n\t            if (name === 'innerHtml') { name = 'innerHTML'; }\n\t          }\n\t          if (modifiers.camel) {\n\t            name = camelize(name);\n\t          }\n\t        }\n\t        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n\t          addProp(el, name, value);\n\t        } else {\n\t          addAttr(el, name, value);\n\t        }\n\t      } else if (onRE.test(name)) { // v-on\n\t        name = name.replace(onRE, '');\n\t        addHandler(el, name, value, modifiers);\n\t      } else { // normal directives\n\t        name = name.replace(dirRE, '');\n\t        // parse arg\n\t        var argMatch = name.match(argRE);\n\t        if (argMatch && (arg = argMatch[1])) {\n\t          name = name.slice(0, -(arg.length + 1));\n\t        }\n\t        addDirective(el, name, rawName, value, arg, modifiers);\n\t        if (false) {\n\t          checkForAliasModel(el, value);\n\t        }\n\t      }\n\t    } else {\n\t      // literal attribute\n\t      if (false) {\n\t        var expression = parseText(value, delimiters);\n\t        if (expression) {\n\t          warn$1(\n\t            name + \"=\\\"\" + value + \"\\\": \" +\n\t            'Interpolation inside attributes has been removed. ' +\n\t            'Use v-bind or the colon shorthand instead. For example, ' +\n\t            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n\t          );\n\t        }\n\t      }\n\t      addAttr(el, name, JSON.stringify(value));\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkInFor (el) {\n\t  var parent = el;\n\t  while (parent) {\n\t    if (parent.for !== undefined) {\n\t      return true\n\t    }\n\t    parent = parent.parent;\n\t  }\n\t  return false\n\t}\n\t\n\tfunction parseModifiers (name) {\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var ret = {};\n\t    match.forEach(function (m) { ret[m.slice(1)] = true; });\n\t    return ret\n\t  }\n\t}\n\t\n\tfunction makeAttrsMap (attrs) {\n\t  var map = {};\n\t  for (var i = 0, l = attrs.length; i < l; i++) {\n\t    if (false) {\n\t      warn$1('duplicate attribute: ' + attrs[i].name);\n\t    }\n\t    map[attrs[i].name] = attrs[i].value;\n\t  }\n\t  return map\n\t}\n\t\n\tfunction isForbiddenTag (el) {\n\t  return (\n\t    el.tag === 'style' ||\n\t    (el.tag === 'script' && (\n\t      !el.attrsMap.type ||\n\t      el.attrsMap.type === 'text/javascript'\n\t    ))\n\t  )\n\t}\n\t\n\tvar ieNSBug = /^xmlns:NS\\d+/;\n\tvar ieNSPrefix = /^NS\\d+:/;\n\t\n\t/* istanbul ignore next */\n\tfunction guardIESVGBug (attrs) {\n\t  var res = [];\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    if (!ieNSBug.test(attr.name)) {\n\t      attr.name = attr.name.replace(ieNSPrefix, '');\n\t      res.push(attr);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkForAliasModel (el, value) {\n\t  var _el = el;\n\t  while (_el) {\n\t    if (_el.for && _el.alias === value) {\n\t      warn$1(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n\t        \"You are binding v-model directly to a v-for iteration alias. \" +\n\t        \"This will not be able to modify the v-for source array because \" +\n\t        \"writing to the alias is like modifying a function local variable. \" +\n\t        \"Consider using an array of objects and use v-model on an object property instead.\"\n\t      );\n\t    }\n\t    _el = _el.parent;\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar isStaticKey;\n\tvar isPlatformReservedTag;\n\t\n\tvar genStaticKeysCached = cached(genStaticKeys$1);\n\t\n\t/**\n\t * Goal of the optimizer: walk the generated template AST tree\n\t * and detect sub-trees that are purely static, i.e. parts of\n\t * the DOM that never needs to change.\n\t *\n\t * Once we detect these sub-trees, we can:\n\t *\n\t * 1. Hoist them into constants, so that we no longer need to\n\t *    create fresh nodes for them on each re-render;\n\t * 2. Completely skip them in the patching process.\n\t */\n\tfunction optimize (root, options) {\n\t  if (!root) { return }\n\t  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n\t  isPlatformReservedTag = options.isReservedTag || no;\n\t  // first pass: mark all non-static nodes.\n\t  markStatic(root);\n\t  // second pass: mark static roots.\n\t  markStaticRoots(root, false);\n\t}\n\t\n\tfunction genStaticKeys$1 (keys) {\n\t  return makeMap(\n\t    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n\t    (keys ? ',' + keys : '')\n\t  )\n\t}\n\t\n\tfunction markStatic (node) {\n\t  node.static = isStatic(node);\n\t  if (node.type === 1) {\n\t    // do not make component slot content static. this avoids\n\t    // 1. components not able to mutate slot nodes\n\t    // 2. static slot content fails for hot-reloading\n\t    if (\n\t      !isPlatformReservedTag(node.tag) &&\n\t      node.tag !== 'slot' &&\n\t      node.attrsMap['inline-template'] == null\n\t    ) {\n\t      return\n\t    }\n\t    for (var i = 0, l = node.children.length; i < l; i++) {\n\t      var child = node.children[i];\n\t      markStatic(child);\n\t      if (!child.static) {\n\t        node.static = false;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction markStaticRoots (node, isInFor) {\n\t  if (node.type === 1) {\n\t    if (node.static || node.once) {\n\t      node.staticInFor = isInFor;\n\t    }\n\t    // For a node to qualify as a static root, it should have children that\n\t    // are not just static text. Otherwise the cost of hoisting out will\n\t    // outweigh the benefits and it's better off to just always render it fresh.\n\t    if (node.static && node.children.length && !(\n\t      node.children.length === 1 &&\n\t      node.children[0].type === 3\n\t    )) {\n\t      node.staticRoot = true;\n\t      return\n\t    } else {\n\t      node.staticRoot = false;\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0, l = node.children.length; i < l; i++) {\n\t        markStaticRoots(node.children[i], isInFor || !!node.for);\n\t      }\n\t    }\n\t    if (node.ifConditions) {\n\t      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n\t    }\n\t  }\n\t}\n\t\n\tfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n\t  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n\t    markStaticRoots(conditionBlocks[i].block, isInFor);\n\t  }\n\t}\n\t\n\tfunction isStatic (node) {\n\t  if (node.type === 2) { // expression\n\t    return false\n\t  }\n\t  if (node.type === 3) { // text\n\t    return true\n\t  }\n\t  return !!(node.pre || (\n\t    !node.hasBindings && // no dynamic bindings\n\t    !node.if && !node.for && // not v-if or v-for or v-else\n\t    !isBuiltInTag(node.tag) && // not a built-in\n\t    isPlatformReservedTag(node.tag) && // not a component\n\t    !isDirectChildOfTemplateFor(node) &&\n\t    Object.keys(node).every(isStaticKey)\n\t  ))\n\t}\n\t\n\tfunction isDirectChildOfTemplateFor (node) {\n\t  while (node.parent) {\n\t    node = node.parent;\n\t    if (node.tag !== 'template') {\n\t      return false\n\t    }\n\t    if (node.for) {\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\t/*  */\n\t\n\tvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n\tvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40,\n\t  'delete': [8, 46]\n\t};\n\t\n\tvar modifierCode = {\n\t  stop: '$event.stopPropagation();',\n\t  prevent: '$event.preventDefault();',\n\t  self: 'if($event.target !== $event.currentTarget)return;',\n\t  ctrl: 'if(!$event.ctrlKey)return;',\n\t  shift: 'if(!$event.shiftKey)return;',\n\t  alt: 'if(!$event.altKey)return;',\n\t  meta: 'if(!$event.metaKey)return;'\n\t};\n\t\n\tfunction genHandlers (events, native) {\n\t  var res = native ? 'nativeOn:{' : 'on:{';\n\t  for (var name in events) {\n\t    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n\t  }\n\t  return res.slice(0, -1) + '}'\n\t}\n\t\n\tfunction genHandler (\n\t  name,\n\t  handler\n\t) {\n\t  if (!handler) {\n\t    return 'function(){}'\n\t  } else if (Array.isArray(handler)) {\n\t    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n\t  } else if (!handler.modifiers) {\n\t    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n\t      ? handler.value\n\t      : (\"function($event){\" + (handler.value) + \"}\")\n\t  } else {\n\t    var code = '';\n\t    var keys = [];\n\t    for (var key in handler.modifiers) {\n\t      if (modifierCode[key]) {\n\t        code += modifierCode[key];\n\t      } else {\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (keys.length) {\n\t      code = genKeyFilter(keys) + code;\n\t    }\n\t    var handlerCode = simplePathRE.test(handler.value)\n\t      ? handler.value + '($event)'\n\t      : handler.value;\n\t    return 'function($event){' + code + handlerCode + '}'\n\t  }\n\t}\n\t\n\tfunction genKeyFilter (keys) {\n\t  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n\t}\n\t\n\tfunction genFilterCode (key) {\n\t  var keyVal = parseInt(key, 10);\n\t  if (keyVal) {\n\t    return (\"$event.keyCode!==\" + keyVal)\n\t  }\n\t  var alias = keyCodes[key];\n\t  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n\t}\n\t\n\t/*  */\n\t\n\tfunction bind$2 (el, dir) {\n\t  el.wrapData = function (code) {\n\t    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar baseDirectives = {\n\t  bind: bind$2,\n\t  cloak: noop\n\t};\n\t\n\t/*  */\n\t\n\t// configurable state\n\tvar warn$2;\n\tvar transforms$1;\n\tvar dataGenFns;\n\tvar platformDirectives$1;\n\tvar isPlatformReservedTag$1;\n\tvar staticRenderFns;\n\tvar onceCount;\n\tvar currentOptions;\n\t\n\tfunction generate (\n\t  ast,\n\t  options\n\t) {\n\t  // save previous staticRenderFns so generate calls can be nested\n\t  var prevStaticRenderFns = staticRenderFns;\n\t  var currentStaticRenderFns = staticRenderFns = [];\n\t  var prevOnceCount = onceCount;\n\t  onceCount = 0;\n\t  currentOptions = options;\n\t  warn$2 = options.warn || baseWarn;\n\t  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n\t  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n\t  platformDirectives$1 = options.directives || {};\n\t  isPlatformReservedTag$1 = options.isReservedTag || no;\n\t  var code = ast ? genElement(ast) : '_c(\"div\")';\n\t  staticRenderFns = prevStaticRenderFns;\n\t  onceCount = prevOnceCount;\n\t  return {\n\t    render: (\"with(this){return \" + code + \"}\"),\n\t    staticRenderFns: currentStaticRenderFns\n\t  }\n\t}\n\t\n\tfunction genElement (el) {\n\t  if (el.staticRoot && !el.staticProcessed) {\n\t    return genStatic(el)\n\t  } else if (el.once && !el.onceProcessed) {\n\t    return genOnce(el)\n\t  } else if (el.for && !el.forProcessed) {\n\t    return genFor(el)\n\t  } else if (el.if && !el.ifProcessed) {\n\t    return genIf(el)\n\t  } else if (el.tag === 'template' && !el.slotTarget) {\n\t    return genChildren(el) || 'void 0'\n\t  } else if (el.tag === 'slot') {\n\t    return genSlot(el)\n\t  } else {\n\t    // component or element\n\t    var code;\n\t    if (el.component) {\n\t      code = genComponent(el.component, el);\n\t    } else {\n\t      var data = el.plain ? undefined : genData(el);\n\t\n\t      var children = el.inlineTemplate ? null : genChildren(el, true);\n\t      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n\t    }\n\t    // module transforms\n\t    for (var i = 0; i < transforms$1.length; i++) {\n\t      code = transforms$1[i](el, code);\n\t    }\n\t    return code\n\t  }\n\t}\n\t\n\t// hoist static sub-trees out\n\tfunction genStatic (el) {\n\t  el.staticProcessed = true;\n\t  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n\t  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n\t}\n\t\n\t// v-once\n\tfunction genOnce (el) {\n\t  el.onceProcessed = true;\n\t  if (el.if && !el.ifProcessed) {\n\t    return genIf(el)\n\t  } else if (el.staticInFor) {\n\t    var key = '';\n\t    var parent = el.parent;\n\t    while (parent) {\n\t      if (parent.for) {\n\t        key = parent.key;\n\t        break\n\t      }\n\t      parent = parent.parent;\n\t    }\n\t    if (!key) {\n\t      (\"production\") !== 'production' && warn$2(\n\t        \"v-once can only be used inside v-for that is keyed. \"\n\t      );\n\t      return genElement(el)\n\t    }\n\t    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n\t  } else {\n\t    return genStatic(el)\n\t  }\n\t}\n\t\n\tfunction genIf (el) {\n\t  el.ifProcessed = true; // avoid recursion\n\t  return genIfConditions(el.ifConditions.slice())\n\t}\n\t\n\tfunction genIfConditions (conditions) {\n\t  if (!conditions.length) {\n\t    return '_e()'\n\t  }\n\t\n\t  var condition = conditions.shift();\n\t  if (condition.exp) {\n\t    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n\t  } else {\n\t    return (\"\" + (genTernaryExp(condition.block)))\n\t  }\n\t\n\t  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\t  function genTernaryExp (el) {\n\t    return el.once ? genOnce(el) : genElement(el)\n\t  }\n\t}\n\t\n\tfunction genFor (el) {\n\t  var exp = el.for;\n\t  var alias = el.alias;\n\t  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n\t  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\t  el.forProcessed = true; // avoid recursion\n\t  return \"_l((\" + exp + \"),\" +\n\t    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n\t      \"return \" + (genElement(el)) +\n\t    '})'\n\t}\n\t\n\tfunction genData (el) {\n\t  var data = '{';\n\t\n\t  // directives first.\n\t  // directives may mutate the el's other properties before they are generated.\n\t  var dirs = genDirectives(el);\n\t  if (dirs) { data += dirs + ','; }\n\t\n\t  // key\n\t  if (el.key) {\n\t    data += \"key:\" + (el.key) + \",\";\n\t  }\n\t  // ref\n\t  if (el.ref) {\n\t    data += \"ref:\" + (el.ref) + \",\";\n\t  }\n\t  if (el.refInFor) {\n\t    data += \"refInFor:true,\";\n\t  }\n\t  // pre\n\t  if (el.pre) {\n\t    data += \"pre:true,\";\n\t  }\n\t  // record original tag name for components using \"is\" attribute\n\t  if (el.component) {\n\t    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n\t  }\n\t  // module data generation functions\n\t  for (var i = 0; i < dataGenFns.length; i++) {\n\t    data += dataGenFns[i](el);\n\t  }\n\t  // attributes\n\t  if (el.attrs) {\n\t    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n\t  }\n\t  // DOM props\n\t  if (el.props) {\n\t    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n\t  }\n\t  // event handlers\n\t  if (el.events) {\n\t    data += (genHandlers(el.events)) + \",\";\n\t  }\n\t  if (el.nativeEvents) {\n\t    data += (genHandlers(el.nativeEvents, true)) + \",\";\n\t  }\n\t  // slot target\n\t  if (el.slotTarget) {\n\t    data += \"slot:\" + (el.slotTarget) + \",\";\n\t  }\n\t  // scoped slots\n\t  if (el.scopedSlots) {\n\t    data += (genScopedSlots(el.scopedSlots)) + \",\";\n\t  }\n\t  // inline-template\n\t  if (el.inlineTemplate) {\n\t    var inlineTemplate = genInlineTemplate(el);\n\t    if (inlineTemplate) {\n\t      data += inlineTemplate + \",\";\n\t    }\n\t  }\n\t  data = data.replace(/,$/, '') + '}';\n\t  // v-bind data wrap\n\t  if (el.wrapData) {\n\t    data = el.wrapData(data);\n\t  }\n\t  return data\n\t}\n\t\n\tfunction genDirectives (el) {\n\t  var dirs = el.directives;\n\t  if (!dirs) { return }\n\t  var res = 'directives:[';\n\t  var hasRuntime = false;\n\t  var i, l, dir, needRuntime;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    dir = dirs[i];\n\t    needRuntime = true;\n\t    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n\t    if (gen) {\n\t      // compile-time directive that manipulates AST.\n\t      // returns true if it also needs a runtime counterpart.\n\t      needRuntime = !!gen(el, dir, warn$2);\n\t    }\n\t    if (needRuntime) {\n\t      hasRuntime = true;\n\t      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n\t    }\n\t  }\n\t  if (hasRuntime) {\n\t    return res.slice(0, -1) + ']'\n\t  }\n\t}\n\t\n\tfunction genInlineTemplate (el) {\n\t  var ast = el.children[0];\n\t  if (false) {\n\t    warn$2('Inline-template components must have exactly one child element.');\n\t  }\n\t  if (ast.type === 1) {\n\t    var inlineRenderFns = generate(ast, currentOptions);\n\t    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n\t  }\n\t}\n\t\n\tfunction genScopedSlots (slots) {\n\t  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n\t}\n\t\n\tfunction genScopedSlot (key, el) {\n\t  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n\t    \"return \" + (el.tag === 'template'\n\t      ? genChildren(el) || 'void 0'\n\t      : genElement(el)) + \"}\"\n\t}\n\t\n\tfunction genChildren (el, checkSkip) {\n\t  var children = el.children;\n\t  if (children.length) {\n\t    var el$1 = children[0];\n\t    // optimize single v-for\n\t    if (children.length === 1 &&\n\t        el$1.for &&\n\t        el$1.tag !== 'template' &&\n\t        el$1.tag !== 'slot') {\n\t      return genElement(el$1)\n\t    }\n\t    var normalizationType = getNormalizationType(children);\n\t    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n\t        ? normalizationType ? (\",\" + normalizationType) : ''\n\t        : ''))\n\t  }\n\t}\n\t\n\t// determine the normalization needed for the children array.\n\t// 0: no normalization needed\n\t// 1: simple normalization needed (possible 1-level deep nested array)\n\t// 2: full normalization needed\n\tfunction getNormalizationType (children) {\n\t  var res = 0;\n\t  for (var i = 0; i < children.length; i++) {\n\t    var el = children[i];\n\t    if (el.type !== 1) {\n\t      continue\n\t    }\n\t    if (needsNormalization(el) ||\n\t        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n\t      res = 2;\n\t      break\n\t    }\n\t    if (maybeComponent(el) ||\n\t        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n\t      res = 1;\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction needsNormalization (el) {\n\t  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n\t}\n\t\n\tfunction maybeComponent (el) {\n\t  return !isPlatformReservedTag$1(el.tag)\n\t}\n\t\n\tfunction genNode (node) {\n\t  if (node.type === 1) {\n\t    return genElement(node)\n\t  } else {\n\t    return genText(node)\n\t  }\n\t}\n\t\n\tfunction genText (text) {\n\t  return (\"_v(\" + (text.type === 2\n\t    ? text.expression // no need for () because already wrapped in _s()\n\t    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n\t}\n\t\n\tfunction genSlot (el) {\n\t  var slotName = el.slotName || '\"default\"';\n\t  var children = genChildren(el);\n\t  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n\t  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n\t  var bind$$1 = el.attrsMap['v-bind'];\n\t  if ((attrs || bind$$1) && !children) {\n\t    res += \",null\";\n\t  }\n\t  if (attrs) {\n\t    res += \",\" + attrs;\n\t  }\n\t  if (bind$$1) {\n\t    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n\t  }\n\t  return res + ')'\n\t}\n\t\n\t// componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\tfunction genComponent (componentName, el) {\n\t  var children = el.inlineTemplate ? null : genChildren(el, true);\n\t  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n\t}\n\t\n\tfunction genProps (props) {\n\t  var res = '';\n\t  for (var i = 0; i < props.length; i++) {\n\t    var prop = props[i];\n\t    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n\t  }\n\t  return res.slice(0, -1)\n\t}\n\t\n\t// #3895, #4268\n\tfunction transformSpecialNewlines (text) {\n\t  return text\n\t    .replace(/\\u2028/g, '\\\\u2028')\n\t    .replace(/\\u2029/g, '\\\\u2029')\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Compile a template.\n\t */\n\tfunction compile$1 (\n\t  template,\n\t  options\n\t) {\n\t  var ast = parse(template.trim(), options);\n\t  optimize(ast, options);\n\t  var code = generate(ast, options);\n\t  return {\n\t    ast: ast,\n\t    render: code.render,\n\t    staticRenderFns: code.staticRenderFns\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// operators like typeof, instanceof and in are allowed\n\tvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n\t  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n\t  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n\t  'extends,finally,continue,debugger,function,arguments'\n\t).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\t// check valid identifier for v-for\n\tvar identRE = /[A-Za-z_$][\\w$]*/;\n\t// strip strings in expressions\n\tvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\t\n\t// detect problematic expressions in a template\n\tfunction detectErrors (ast) {\n\t  var errors = [];\n\t  if (ast) {\n\t    checkNode(ast, errors);\n\t  }\n\t  return errors\n\t}\n\t\n\tfunction checkNode (node, errors) {\n\t  if (node.type === 1) {\n\t    for (var name in node.attrsMap) {\n\t      if (dirRE.test(name)) {\n\t        var value = node.attrsMap[name];\n\t        if (value) {\n\t          if (name === 'v-for') {\n\t            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n\t          } else {\n\t            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0; i < node.children.length; i++) {\n\t        checkNode(node.children[i], errors);\n\t      }\n\t    }\n\t  } else if (node.type === 2) {\n\t    checkExpression(node.expression, node.text, errors);\n\t  }\n\t}\n\t\n\tfunction checkFor (node, text, errors) {\n\t  checkExpression(node.for || '', text, errors);\n\t  checkIdentifier(node.alias, 'v-for alias', text, errors);\n\t  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n\t  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n\t}\n\t\n\tfunction checkIdentifier (ident, type, text, errors) {\n\t  if (typeof ident === 'string' && !identRE.test(ident)) {\n\t    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n\t  }\n\t}\n\t\n\tfunction checkExpression (exp, text, errors) {\n\t  try {\n\t    new Function((\"return \" + exp));\n\t  } catch (e) {\n\t    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\t    if (keywordMatch) {\n\t      errors.push(\n\t        \"- avoid using JavaScript keyword as property name: \" +\n\t        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n\t      );\n\t    } else {\n\t      errors.push((\"- invalid expression: \" + text));\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction transformNode (el, options) {\n\t  var warn = options.warn || baseWarn;\n\t  var staticClass = getAndRemoveAttr(el, 'class');\n\t  if (false) {\n\t    var expression = parseText(staticClass, options.delimiters);\n\t    if (expression) {\n\t      warn(\n\t        \"class=\\\"\" + staticClass + \"\\\": \" +\n\t        'Interpolation inside attributes has been removed. ' +\n\t        'Use v-bind or the colon shorthand instead. For example, ' +\n\t        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n\t      );\n\t    }\n\t  }\n\t  if (staticClass) {\n\t    el.staticClass = JSON.stringify(staticClass);\n\t  }\n\t  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n\t  if (classBinding) {\n\t    el.classBinding = classBinding;\n\t  }\n\t}\n\t\n\tfunction genData$1 (el) {\n\t  var data = '';\n\t  if (el.staticClass) {\n\t    data += \"staticClass:\" + (el.staticClass) + \",\";\n\t  }\n\t  if (el.classBinding) {\n\t    data += \"class:\" + (el.classBinding) + \",\";\n\t  }\n\t  return data\n\t}\n\t\n\tvar klass$1 = {\n\t  staticKeys: ['staticClass'],\n\t  transformNode: transformNode,\n\t  genData: genData$1\n\t};\n\t\n\t/*  */\n\t\n\tfunction transformNode$1 (el, options) {\n\t  var warn = options.warn || baseWarn;\n\t  var staticStyle = getAndRemoveAttr(el, 'style');\n\t  if (staticStyle) {\n\t    /* istanbul ignore if */\n\t    if (false) {\n\t      var expression = parseText(staticStyle, options.delimiters);\n\t      if (expression) {\n\t        warn(\n\t          \"style=\\\"\" + staticStyle + \"\\\": \" +\n\t          'Interpolation inside attributes has been removed. ' +\n\t          'Use v-bind or the colon shorthand instead. For example, ' +\n\t          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n\t        );\n\t      }\n\t    }\n\t    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n\t  }\n\t\n\t  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n\t  if (styleBinding) {\n\t    el.styleBinding = styleBinding;\n\t  }\n\t}\n\t\n\tfunction genData$2 (el) {\n\t  var data = '';\n\t  if (el.staticStyle) {\n\t    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n\t  }\n\t  if (el.styleBinding) {\n\t    data += \"style:(\" + (el.styleBinding) + \"),\";\n\t  }\n\t  return data\n\t}\n\t\n\tvar style$1 = {\n\t  staticKeys: ['staticStyle'],\n\t  transformNode: transformNode$1,\n\t  genData: genData$2\n\t};\n\t\n\tvar modules$1 = [\n\t  klass$1,\n\t  style$1\n\t];\n\t\n\t/*  */\n\t\n\tvar warn$3;\n\t\n\tfunction model$1 (\n\t  el,\n\t  dir,\n\t  _warn\n\t) {\n\t  warn$3 = _warn;\n\t  var value = dir.value;\n\t  var modifiers = dir.modifiers;\n\t  var tag = el.tag;\n\t  var type = el.attrsMap.type;\n\t  if (false) {\n\t    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\t    if (tag === 'input' && dynamicType) {\n\t      warn$3(\n\t        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n\t      );\n\t    }\n\t  }\n\t  if (tag === 'select') {\n\t    genSelect(el, value, modifiers);\n\t  } else if (tag === 'input' && type === 'checkbox') {\n\t    genCheckboxModel(el, value, modifiers);\n\t  } else if (tag === 'input' && type === 'radio') {\n\t    genRadioModel(el, value, modifiers);\n\t  } else {\n\t    genDefaultModel(el, value, modifiers);\n\t  }\n\t  // ensure runtime directive metadata\n\t  return true\n\t}\n\t\n\tfunction genCheckboxModel (\n\t  el,\n\t  value,\n\t  modifiers\n\t) {\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var number = modifiers && modifiers.number;\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n\t  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n\t  addProp(el, 'checked',\n\t    \"Array.isArray(\" + value + \")\" +\n\t      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n\t        trueValueBinding === 'true'\n\t          ? (\":(\" + value + \")\")\n\t          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n\t      )\n\t  );\n\t  addHandler(el, 'click',\n\t    \"var $$a=\" + value + \",\" +\n\t        '$$el=$event.target,' +\n\t        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n\t    'if(Array.isArray($$a)){' +\n\t      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n\t          '$$i=_i($$a,$$v);' +\n\t      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n\t      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n\t    \"}else{\" + value + \"=$$c}\",\n\t    null, true\n\t  );\n\t}\n\t\n\tfunction genRadioModel (\n\t    el,\n\t    value,\n\t    modifiers\n\t) {\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var number = modifiers && modifiers.number;\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n\t  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n\t  addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);\n\t}\n\t\n\tfunction genDefaultModel (\n\t  el,\n\t  value,\n\t  modifiers\n\t) {\n\t  if (false) {\n\t    if (el.tag === 'input' && el.attrsMap.value) {\n\t      warn$3(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n\t        'inline value attributes will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t    if (el.tag === 'textarea' && el.children.length) {\n\t      warn$3(\n\t        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        'inline content inside <textarea> will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t  }\n\t\n\t  var type = el.attrsMap.type;\n\t  var ref = modifiers || {};\n\t  var lazy = ref.lazy;\n\t  var number = ref.number;\n\t  var trim = ref.trim;\n\t  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n\t  var needCompositionGuard = !lazy && type !== 'range';\n\t  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\t\n\t  var valueExpression = isNative\n\t    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n\t    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n\t  valueExpression = number || type === 'number'\n\t    ? (\"_n(\" + valueExpression + \")\")\n\t    : valueExpression;\n\t\n\t  var code = genAssignmentCode(value, valueExpression);\n\t  if (isNative && needCompositionGuard) {\n\t    code = \"if($event.target.composing)return;\" + code;\n\t  }\n\t\n\t  // inputs with type=\"file\" are read only and setting the input's\n\t  // value will throw an error.\n\t  if (false) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n\t      \"File inputs are read only. Use a v-on:change listener instead.\"\n\t    );\n\t  }\n\t\n\t  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n\t  addHandler(el, event, code, null, true);\n\t  if (trim || number || type === 'number') {\n\t    addHandler(el, 'blur', '$forceUpdate()');\n\t  }\n\t}\n\t\n\tfunction genSelect (\n\t    el,\n\t    value,\n\t    modifiers\n\t) {\n\t  if (false) {\n\t    el.children.some(checkOptionWarning);\n\t  }\n\t\n\t  var number = modifiers && modifiers.number;\n\t  var assignment = \"Array.prototype.filter\" +\n\t    \".call($event.target.options,function(o){return o.selected})\" +\n\t    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n\t    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n\t    (el.attrsMap.multiple == null ? '[0]' : '');\n\t\n\t  var code = genAssignmentCode(value, assignment);\n\t  addHandler(el, 'change', code, null, true);\n\t}\n\t\n\tfunction checkOptionWarning (option) {\n\t  if (option.type === 1 &&\n\t    option.tag === 'option' &&\n\t    option.attrsMap.selected != null) {\n\t    warn$3(\n\t      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n\t      'inline selected attributes on <option> will be ignored when using v-model. ' +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\tfunction genAssignmentCode (value, assignment) {\n\t  var modelRs = parseModel(value);\n\t  if (modelRs.idx === null) {\n\t    return (value + \"=\" + assignment)\n\t  } else {\n\t    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n\t      \"if (!Array.isArray($$exp)){\" +\n\t        value + \"=\" + assignment + \"}\" +\n\t      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction text (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction html (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\tvar directives$1 = {\n\t  model: model$1,\n\t  text: text,\n\t  html: html\n\t};\n\t\n\t/*  */\n\t\n\tvar cache = Object.create(null);\n\t\n\tvar baseOptions = {\n\t  expectHTML: true,\n\t  modules: modules$1,\n\t  staticKeys: genStaticKeys(modules$1),\n\t  directives: directives$1,\n\t  isReservedTag: isReservedTag,\n\t  isUnaryTag: isUnaryTag,\n\t  mustUseProp: mustUseProp,\n\t  getTagNamespace: getTagNamespace,\n\t  isPreTag: isPreTag\n\t};\n\t\n\tfunction compile$$1 (\n\t  template,\n\t  options\n\t) {\n\t  options = options\n\t    ? extend(extend({}, baseOptions), options)\n\t    : baseOptions;\n\t  return compile$1(template, options)\n\t}\n\t\n\tfunction compileToFunctions (\n\t  template,\n\t  options,\n\t  vm\n\t) {\n\t  var _warn = (options && options.warn) || warn;\n\t  // detect possible CSP restriction\n\t  /* istanbul ignore if */\n\t  if (false) {\n\t    try {\n\t      new Function('return 1');\n\t    } catch (e) {\n\t      if (e.toString().match(/unsafe-eval|CSP/)) {\n\t        _warn(\n\t          'It seems you are using the standalone build of Vue.js in an ' +\n\t          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n\t          'The template compiler cannot work in this environment. Consider ' +\n\t          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n\t          'templates into render functions.'\n\t        );\n\t      }\n\t    }\n\t  }\n\t  var key = options && options.delimiters\n\t    ? String(options.delimiters) + template\n\t    : template;\n\t  if (cache[key]) {\n\t    return cache[key]\n\t  }\n\t  var res = {};\n\t  var compiled = compile$$1(template, options);\n\t  res.render = makeFunction(compiled.render);\n\t  var l = compiled.staticRenderFns.length;\n\t  res.staticRenderFns = new Array(l);\n\t  for (var i = 0; i < l; i++) {\n\t    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n\t  }\n\t  if (false) {\n\t    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n\t      _warn(\n\t        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n\t        detectErrors(compiled.ast).join('\\n') +\n\t        '\\n\\n',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  return (cache[key] = res)\n\t}\n\t\n\tfunction makeFunction (code) {\n\t  try {\n\t    return new Function(code)\n\t  } catch (e) {\n\t    return noop\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar idToTemplate = cached(function (id) {\n\t  var el = query(id);\n\t  return el && el.innerHTML\n\t});\n\t\n\tvar mount = Vue$3.prototype.$mount;\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && query(el);\n\t\n\t  /* istanbul ignore if */\n\t  if (el === document.body || el === document.documentElement) {\n\t    (\"production\") !== 'production' && warn(\n\t      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n\t    );\n\t    return this\n\t  }\n\t\n\t  var options = this.$options;\n\t  // resolve template/el and convert to render function\n\t  if (!options.render) {\n\t    var template = options.template;\n\t    if (template) {\n\t      if (typeof template === 'string') {\n\t        if (template.charAt(0) === '#') {\n\t          template = idToTemplate(template);\n\t          /* istanbul ignore if */\n\t          if (false) {\n\t            warn(\n\t              (\"Template element not found or is empty: \" + (options.template)),\n\t              this\n\t            );\n\t          }\n\t        }\n\t      } else if (template.nodeType) {\n\t        template = template.innerHTML;\n\t      } else {\n\t        if (false) {\n\t          warn('invalid template option:' + template, this);\n\t        }\n\t        return this\n\t      }\n\t    } else if (el) {\n\t      template = getOuterHTML(el);\n\t    }\n\t    if (template) {\n\t      var ref = compileToFunctions(template, {\n\t        warn: warn,\n\t        shouldDecodeNewlines: shouldDecodeNewlines,\n\t        delimiters: options.delimiters\n\t      }, this);\n\t      var render = ref.render;\n\t      var staticRenderFns = ref.staticRenderFns;\n\t      options.render = render;\n\t      options.staticRenderFns = staticRenderFns;\n\t    }\n\t  }\n\t  return mount.call(this, el, hydrating)\n\t};\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t */\n\tfunction getOuterHTML (el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\tVue$3.compile = compileToFunctions;\n\t\n\tmodule.exports = Vue$3;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(30)\n\t  , TAG = __webpack_require__(7)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8).document && document.documentElement;\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// check on default Array iterator\n\tvar Iterators  = __webpack_require__(25)\n\t  , ITERATOR   = __webpack_require__(7)('iterator')\n\t  , ArrayProto = Array.prototype;\n\t\n\tmodule.exports = function(it){\n\t  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n\t};\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// call something on iterator step with safe closing on error\n\tvar anObject = __webpack_require__(18);\n\tmodule.exports = function(iterator, fn, value, entries){\n\t  try {\n\t    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch(e){\n\t    var ret = iterator['return'];\n\t    if(ret !== undefined)anObject(ret.call(iterator));\n\t    throw e;\n\t  }\n\t};\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(71)\n\t  , $export        = __webpack_require__(44)\n\t  , redefine       = __webpack_require__(118)\n\t  , hide           = __webpack_require__(19)\n\t  , has            = __webpack_require__(31)\n\t  , Iterators      = __webpack_require__(25)\n\t  , $iterCreate    = __webpack_require__(109)\n\t  , setToStringTag = __webpack_require__(46)\n\t  , getPrototypeOf = __webpack_require__(114)\n\t  , ITERATOR       = __webpack_require__(7)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ITERATOR     = __webpack_require__(7)('iterator')\n\t  , SAFE_CLOSING = false;\n\t\n\ttry {\n\t  var riter = [7][ITERATOR]();\n\t  riter['return'] = function(){ SAFE_CLOSING = true; };\n\t  Array.from(riter, function(){ throw 2; });\n\t} catch(e){ /* empty */ }\n\t\n\tmodule.exports = function(exec, skipClosing){\n\t  if(!skipClosing && !SAFE_CLOSING)return false;\n\t  var safe = false;\n\t  try {\n\t    var arr  = [7]\n\t      , iter = arr[ITERATOR]();\n\t    iter.next = function(){ return {done: safe = true}; };\n\t    arr[ITERATOR] = function(){ return iter; };\n\t    exec(arr);\n\t  } catch(e){ /* empty */ }\n\t  return safe;\n\t};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(8)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx                = __webpack_require__(23)\n\t  , invoke             = __webpack_require__(107)\n\t  , html               = __webpack_require__(66)\n\t  , cel                = __webpack_require__(43)\n\t  , global             = __webpack_require__(8)\n\t  , process            = global.process\n\t  , setTask            = global.setImmediate\n\t  , clearTask          = global.clearImmediate\n\t  , MessageChannel     = global.MessageChannel\n\t  , counter            = 0\n\t  , queue              = {}\n\t  , ONREADYSTATECHANGE = 'onreadystatechange'\n\t  , defer, channel, port;\n\tvar run = function(){\n\t  var id = +this;\n\t  if(queue.hasOwnProperty(id)){\n\t    var fn = queue[id];\n\t    delete queue[id];\n\t    fn();\n\t  }\n\t};\n\tvar listener = function(event){\n\t  run.call(event.data);\n\t};\n\t// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\tif(!setTask || !clearTask){\n\t  setTask = function setImmediate(fn){\n\t    var args = [], i = 1;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    queue[++counter] = function(){\n\t      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n\t    };\n\t    defer(counter);\n\t    return counter;\n\t  };\n\t  clearTask = function clearImmediate(id){\n\t    delete queue[id];\n\t  };\n\t  // Node.js 0.8-\n\t  if(__webpack_require__(30)(process) == 'process'){\n\t    defer = function(id){\n\t      process.nextTick(ctx(run, id, 1));\n\t    };\n\t  // Browsers with MessageChannel, includes WebWorkers\n\t  } else if(MessageChannel){\n\t    channel = new MessageChannel;\n\t    port    = channel.port2;\n\t    channel.port1.onmessage = listener;\n\t    defer = ctx(port.postMessage, port, 1);\n\t  // Browsers with postMessage, skip WebWorkers\n\t  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n\t  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n\t    defer = function(id){\n\t      global.postMessage(id + '', '*');\n\t    };\n\t    global.addEventListener('message', listener, false);\n\t  // IE8-\n\t  } else if(ONREADYSTATECHANGE in cel('script')){\n\t    defer = function(id){\n\t      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n\t        html.removeChild(this);\n\t        run.call(id);\n\t      };\n\t    };\n\t  // Rest old browsers\n\t  } else {\n\t    defer = function(id){\n\t      setTimeout(ctx(run, id, 1), 0);\n\t    };\n\t  }\n\t}\n\tmodule.exports = {\n\t  set:   setTask,\n\t  clear: clearTask\n\t};\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(42);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(63)\n\t  , ITERATOR  = __webpack_require__(7)('iterator')\n\t  , Iterators = __webpack_require__(25);\n\tmodule.exports = __webpack_require__(16).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(121)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(69)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 78 */,\n/* 79 */,\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var graphic = __webpack_require__(3);\n\t    var zrUtil = __webpack_require__(1);\n\t    var echarts = __webpack_require__(2);\n\t\n\t    __webpack_require__(82);\n\t\n\t    __webpack_require__(155);\n\t\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t\n\t        type: 'grid',\n\t\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({\n\t                        fill: gridModel.get('backgroundColor')\n\t                    }, gridModel.getItemStyle()),\n\t                    silent: true,\n\t                    z2: -1\n\t                }));\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var ComponentModel = __webpack_require__(17);\n\t    var zrUtil = __webpack_require__(1);\n\t    var axisModelCreator = __webpack_require__(173);\n\t\n\t    var AxisModel = ComponentModel.extend({\n\t\n\t        type: 'cartesian2dAxis',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        axis: null,\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function () {\n\t            AxisModel.superApply(this, 'init', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        mergeOption: function () {\n\t            AxisModel.superApply(this, 'mergeOption', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        restoreData: function () {\n\t            AxisModel.superApply(this, 'restoreData', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         * @return {module:echarts/model/Component}\n\t         */\n\t        getCoordSysModel: function () {\n\t            return this.ecModel.queryComponents({\n\t                mainType: 'grid',\n\t                index: this.option.gridIndex,\n\t                id: this.option.gridId\n\t            })[0];\n\t        }\n\t\n\t    });\n\t\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(172));\n\t\n\t    var extraOption = {\n\t        // gridIndex: 0,\n\t        // gridId: '',\n\t\n\t        // Offset is for multiple axis on the same position\n\t        offset: 0\n\t    };\n\t\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t\n\t    module.exports = AxisModel;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Grid is a region which contains at most 4 cartesian systems\n\t *\n\t * TODO Default cartesian\n\t */\n\tvar factory = exports;\n\t\n\t    var layout = __webpack_require__(20);\n\t    var axisHelper = __webpack_require__(55);\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Cartesian2D = __webpack_require__(176);\n\t    var Axis2D = __webpack_require__(174);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t\n\t    //  GridModel, AxisModel \n\t    __webpack_require__(177);\n\t\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.getCoordSysModel() === gridModel;\n\t    }\n\t\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = textStyleModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : (rect = singleRect);\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t\n\t        this._initCartesian(gridModel, ecModel, api);\n\t\n\t        this._model = gridModel;\n\t    }\n\t\n\t    var gridProto = Grid.prototype;\n\t\n\t    gridProto.type = 'grid';\n\t\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t\n\t    gridProto.update = function (ecModel, api) {\n\t\n\t        var axesMap = this._axesMap;\n\t\n\t        this._updateScale(ecModel, this._model);\n\t\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                if (axes.hasOwnProperty(idx)) {\n\t                    var axis = axes[idx];\n\t                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t\n\t        var gridRect = layout.getLayoutRect(\n\t            gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t\n\t        this._rect = gridRect;\n\t\n\t        var axesList = this._axesList;\n\t\n\t        adjustAxes();\n\t\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        }\n\t                        else if (axis.position === 'left')  {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t\n\t            adjustAxes();\n\t        }\n\t\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    if (axesMapOnDim.hasOwnProperty(name)) {\n\t                        return axesMapOnDim[name];\n\t                    }\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        }\n\t        else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex\n\t                    || coordList[i].getAxis('y').index === yAxisIndex\n\t                ) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertToPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.dataToPoint(value)\n\t            : target.axis\n\t            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertFromPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.pointToData(value)\n\t            : target.axis\n\t            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    gridProto._findConvertTarget = function (ecModel, finder) {\n\t        var seriesModel = finder.seriesModel;\n\t        var xAxisModel = finder.xAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n\t        var yAxisModel = finder.yAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n\t        var gridModel = finder.gridModel;\n\t        var coordsList = this._coordsList;\n\t        var cartesian;\n\t        var axis;\n\t\n\t        if (seriesModel) {\n\t            cartesian = seriesModel.coordinateSystem;\n\t            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n\t        }\n\t        else if (xAxisModel && yAxisModel) {\n\t            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        }\n\t        else if (xAxisModel) {\n\t            axis = this.getAxis('x', xAxisModel.componentIndex);\n\t        }\n\t        else if (yAxisModel) {\n\t            axis = this.getAxis('y', yAxisModel.componentIndex);\n\t        }\n\t        // Lowest priority.\n\t        else if (gridModel) {\n\t            var grid = gridModel.coordinateSystem;\n\t            if (grid === this) {\n\t                cartesian = this._coordsList[0];\n\t            }\n\t        }\n\t\n\t        return {cartesian: cartesian, axis: axis};\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.containPoint = function (point) {\n\t        var coord = this._coordsList[0];\n\t        if (coord) {\n\t            return coord.containPoint(point);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t            left: false,\n\t            right: false,\n\t            top: false,\n\t            bottom: false\n\t        };\n\t\n\t        var axesMap = {\n\t            x: {},\n\t            y: {}\n\t        };\n\t        var axesCount = {\n\t            x: 0,\n\t            y: 0\n\t        };\n\t\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t\n\t        this._axesMap = axesMap;\n\t\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t\n\t                cartesian.grid = this;\n\t\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t\n\t                var axis = new Axis2D(\n\t                    axisType, axisHelper.createScaleByModel(axisModel),\n\t                    [0, 0],\n\t                    axisModel.get('type'),\n\t                    axisPosition\n\t                );\n\t\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t\n\t                this._axesList.push(axis);\n\t\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n\t                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n\t                 ) {\n\t                    return;\n\t                }\n\t\n\t                var cartesian = this.getCartesian(\n\t                    xAxisModel.componentIndex, yAxisModel.componentIndex\n\t                );\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtentFromData(data, dim);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord + coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t        axis.toLocalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord - coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t    }\n\t\n\t    var axesTypes = ['xAxis', 'yAxis'];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\t\n\t            if (__DEV__) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n\t                        seriesModel.get(axisType + 'Index'),\n\t                        seriesModel.get(axisType + 'Id'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t\n\t            gridModel.coordinateSystem = grid;\n\t\n\t            grids.push(grid);\n\t        });\n\t\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            var gridModel = xAxisModel.getCoordSysModel();\n\t\n\t            if (__DEV__) {\n\t                if (!gridModel) {\n\t                    throw new Error(\n\t                        'Grid \"' + zrUtil.retrieve(\n\t                            xAxisModel.get('gridIndex'),\n\t                            xAxisModel.get('gridId'),\n\t                            0\n\t                        ) + '\" not found'\n\t                    );\n\t                }\n\t                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t\n\t            var grid = gridModel.coordinateSystem;\n\t\n\t            seriesModel.coordinateSystem = grid.getCartesian(\n\t                xAxisModel.componentIndex, yAxisModel.componentIndex\n\t            );\n\t        });\n\t\n\t        return grids;\n\t    };\n\t\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t\n\t    __webpack_require__(54).register('cartesian2d', Grid);\n\t\n\t    module.exports = Grid;\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Complete dimensions by data (guess dimension).\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} [defaultNames]    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} [extraPrefix]             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n\t                dimensions[i] = guessOrdinal(data, i)\n\t                    ? {type: 'ordinal', name: name}\n\t                    : name;\n\t            }\n\t        }\n\t\n\t        return dimensions;\n\t    }\n\t\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            var value = retrieveValue(data[i]);\n\t\n\t            if (!zrUtil.isArray(value)) {\n\t                return false;\n\t            }\n\t\n\t            var value = value[dimIndex];\n\t            if (value != null && isFinite(value)) {\n\t                return false;\n\t            }\n\t            else if (zrUtil.isString(value) && value !== '-') {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n\t    }\n\t\n\t    module.exports = completeDimensions;\n\t\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var classUtil = __webpack_require__(15);\n\t    var modelUtil = __webpack_require__(13);\n\t    var ComponentModel = __webpack_require__(17);\n\t    var colorPaletteMixin = __webpack_require__(85);\n\t    var env = __webpack_require__(10);\n\t    var layout = __webpack_require__(20);\n\t\n\t    var set = classUtil.set;\n\t    var get = classUtil.get;\n\t    var encodeHTML = formatUtil.encodeHTML;\n\t    var addCommas = formatUtil.addCommas;\n\t\n\t    var SeriesModel = ComponentModel.extend({\n\t\n\t        type: 'series.__base__',\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        seriesIndex: 0,\n\t\n\t        // coodinateSystem will be injected in the echarts/CoordinateSystem\n\t        coordinateSystem: null,\n\t\n\t        /**\n\t         * @type {Object}\n\t         * @protected\n\t         */\n\t        defaultOption: null,\n\t\n\t        /**\n\t         * Data provided for legend\n\t         * @type {Function}\n\t         */\n\t        // PENDING\n\t        legendDataProvider: null,\n\t\n\t        /**\n\t         * Access path of color for visual\n\t         */\n\t        visualColorAccessPath: 'itemStyle.normal.color',\n\t\n\t        /**\n\t         * Support merge layout params.\n\t         * Only support 'box' now (left/right/top/bottom/width/height).\n\t         * @type {string|Object} Object can be {ignoreSize: true}\n\t         * @readOnly\n\t         */\n\t        layoutMode: null,\n\t\n\t        init: function (option, parentModel, ecModel, extraOpt) {\n\t\n\t            /**\n\t             * @type {number}\n\t             * @readOnly\n\t             */\n\t            this.seriesIndex = this.componentIndex;\n\t\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            /**\n\t             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n\t             * @private\n\t             */\n\t            set(this, 'dataBeforeProcessed', this.getInitialData(option, ecModel));\n\t\n\t            // If we reverse the order (make data firstly, and then make\n\t            // dataBeforeProcessed by cloneShallow), cloneShallow will\n\t            // cause data.graph.data !== data when using\n\t            // module:echarts/data/Graph or module:echarts/data/Tree.\n\t            // See module:echarts/data/helper/linkList\n\t            this.restoreData();\n\t        },\n\t\n\t        /**\n\t         * Util for merge default and theme to option\n\t         * @param  {Object} option\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         */\n\t        mergeDefaultAndTheme: function (option, ecModel) {\n\t            var layoutMode = this.layoutMode;\n\t            var inputPositionParams = layoutMode\n\t                ? layout.getLayoutParams(option) : {};\n\t\n\t            zrUtil.merge(\n\t                option,\n\t                ecModel.getTheme().get(this.subType)\n\t            );\n\t            zrUtil.merge(option, this.getDefaultOption());\n\t\n\t            // Default label emphasis `position` and `show`\n\t            // FIXME Set label in mergeOption\n\t            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\t\n\t            this.fillDataTextStyle(option.data);\n\t\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t            }\n\t        },\n\t\n\t        mergeOption: function (newSeriesOption, ecModel) {\n\t            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n\t            this.fillDataTextStyle(newSeriesOption.data);\n\t\n\t            var layoutMode = this.layoutMode;\n\t            if (layoutMode) {\n\t                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n\t            }\n\t\n\t            var data = this.getInitialData(newSeriesOption, ecModel);\n\t            // TODO Merge data?\n\t            if (data) {\n\t                set(this, 'data', data);\n\t                set(this, 'dataBeforeProcessed', data.cloneShallow());\n\t            }\n\t        },\n\t\n\t        fillDataTextStyle: function (data) {\n\t            // Default data label emphasis `position` and `show`\n\t            // FIXME Tree structure data ?\n\t            // FIXME Performance ?\n\t            if (data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    if (data[i] && data[i].label) {\n\t                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Init a data structure from data related option in series\n\t         * Must be overwritten\n\t         */\n\t        getInitialData: function () {},\n\t\n\t        /**\n\t         * @param {string} [dataType]\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getData: function (dataType) {\n\t            var data = get(this, 'data');\n\t            return dataType == null ? data : data.getLinkedData(dataType);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/data/List} data\n\t         */\n\t        setData: function (data) {\n\t            set(this, 'data', data);\n\t        },\n\t\n\t        /**\n\t         * Get data before processed\n\t         * @return {module:echarts/data/List}\n\t         */\n\t        getRawData: function () {\n\t            return get(this, 'dataBeforeProcessed');\n\t        },\n\t\n\t        /**\n\t         * Coord dimension to data dimension.\n\t         *\n\t         * By default the result is the same as dimensions of series data.\n\t         * But in some series data dimensions are different from coord dimensions (i.e.\n\t         * candlestick and boxplot). Override this method to handle those cases.\n\t         *\n\t         * Coord dimension to data dimension can be one-to-many\n\t         *\n\t         * @param {string} coordDim\n\t         * @return {Array.<string>} dimensions on the axis.\n\t         */\n\t        coordDimToDataDim: function (coordDim) {\n\t            return [coordDim];\n\t        },\n\t\n\t        /**\n\t         * Convert data dimension to coord dimension.\n\t         *\n\t         * @param {string|number} dataDim\n\t         * @return {string}\n\t         */\n\t        dataDimToCoordDim: function (dataDim) {\n\t            return dataDim;\n\t        },\n\t\n\t        /**\n\t         * Get base axis if has coordinate system and has axis.\n\t         * By default use coordSys.getBaseAxis();\n\t         * Can be overrided for some chart.\n\t         * @return {type} description\n\t         */\n\t        getBaseAxis: function () {\n\t            var coordSys = this.coordinateSystem;\n\t            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n\t        },\n\t\n\t        // FIXME\n\t        /**\n\t         * Default tooltip formatter\n\t         *\n\t         * @param {number} dataIndex\n\t         * @param {boolean} [multipleSeries=false]\n\t         * @param {number} [dataType]\n\t         */\n\t        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n\t            function formatArrayValue(value) {\n\t                var result = [];\n\t\n\t                zrUtil.each(value, function (val, idx) {\n\t                    var dimInfo = data.getDimensionInfo(idx);\n\t                    var dimType = dimInfo && dimInfo.type;\n\t                    var valStr;\n\t\n\t                    if (dimType === 'ordinal') {\n\t                        valStr = val + '';\n\t                    }\n\t                    else if (dimType === 'time') {\n\t                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n\t                    }\n\t                    else {\n\t                        valStr = addCommas(val);\n\t                    }\n\t\n\t                    valStr && result.push(valStr);\n\t                });\n\t\n\t                return result.join(', ');\n\t            }\n\t\n\t            var data = get(this, 'data');\n\t\n\t            var value = this.getRawValue(dataIndex);\n\t            var formattedValue = encodeHTML(\n\t                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n\t            );\n\t            var name = data.getName(dataIndex);\n\t\n\t            var color = data.getItemVisual(dataIndex, 'color');\n\t            if (zrUtil.isObject(color) && color.colorStops) {\n\t                color = (color.colorStops[0] || {}).color;\n\t            }\n\t            color = color || 'transparent';\n\t\n\t            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n\t                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\t\n\t            var seriesName = this.name;\n\t            // FIXME\n\t            if (seriesName === '\\0-') {\n\t                // Not show '-'\n\t                seriesName = '';\n\t            }\n\t            return !multipleSeries\n\t                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n\t                    + (name\n\t                        ? encodeHTML(name) + ' : ' + formattedValue\n\t                        : formattedValue\n\t                    )\n\t                  )\n\t                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        isAnimationEnabled: function () {\n\t            if (env.node) {\n\t                return false;\n\t            }\n\t\n\t            var animationEnabled = this.getShallow('animation');\n\t            if (animationEnabled) {\n\t                if (this.getData().count() > this.getShallow('animationThreshold')) {\n\t                    animationEnabled = false;\n\t                }\n\t            }\n\t            return animationEnabled;\n\t        },\n\t\n\t        restoreData: function () {\n\t            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            var ecModel = this.ecModel;\n\t            // PENDING\n\t            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n\t            if (!color) {\n\t                color = ecModel.getColorFromPalette(name, scope);\n\t            }\n\t            return color;\n\t        },\n\t\n\t        /**\n\t         * Get data indices for show tooltip content. See tooltip.\n\t         * @abstract\n\t         * @param {Array.<string>|string} dim\n\t         * @param {Array.<number>} value\n\t         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n\t         * @return {Array.<number>} data indices.\n\t         */\n\t        getAxisTooltipDataIndex: null,\n\t\n\t        /**\n\t         * See tooltip.\n\t         * @abstract\n\t         * @param {number} dataIndex\n\t         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n\t         */\n\t        getTooltipPosition: null\n\t    });\n\t\n\t    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n\t    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\t\n\t    module.exports = SeriesModel;\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var classUtil = __webpack_require__(15);\n\t    var set = classUtil.set;\n\t    var get = classUtil.get;\n\t\n\t    module.exports = {\n\t        clearColorPalette: function () {\n\t            set(this, 'colorIdx', 0);\n\t            set(this, 'colorNameMap', {});\n\t        },\n\t\n\t        getColorFromPalette: function (name, scope) {\n\t            scope = scope || this;\n\t            var colorIdx = get(scope, 'colorIdx') || 0;\n\t            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n\t            if (colorNameMap[name]) {\n\t                return colorNameMap[name];\n\t            }\n\t            var colorPalette = this.get('color', true) || [];\n\t            if (!colorPalette.length) {\n\t                return;\n\t            }\n\t\n\t            var color = colorPalette[colorIdx];\n\t            if (name) {\n\t                colorNameMap[name] = color;\n\t            }\n\t            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\t\n\t            return color;\n\t        }\n\t    };\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(37);\n\t    var componentUtil = __webpack_require__(58);\n\t    var clazzUtil = __webpack_require__(15);\n\t    var modelUtil = __webpack_require__(13);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function Chart() {\n\t\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewChart');\n\t    }\n\t\n\t    Chart.prototype = {\n\t\n\t        type: 'chart',\n\t\n\t        /**\n\t         * Init the chart\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        init: function (ecModel, api) {},\n\t\n\t        /**\n\t         * Render the chart\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        render: function (seriesModel, ecModel, api, payload) {},\n\t\n\t        /**\n\t         * Highlight series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n\t        },\n\t\n\t        /**\n\t         * Downplay series or specified data item\n\t         * @param  {module:echarts/model/Series} seriesModel\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         * @param  {Object} payload\n\t         */\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            toggleHighlight(seriesModel.getData(), payload, 'normal');\n\t        },\n\t\n\t        /**\n\t         * Remove self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        remove: function (ecModel, api) {\n\t            this.group.removeAll();\n\t        },\n\t\n\t        /**\n\t         * Dispose self\n\t         * @param  {module:echarts/model/Global} ecModel\n\t         * @param  {module:echarts/ExtensionAPI} api\n\t         */\n\t        dispose: function () {}\n\t\n\t        /**\n\t         * The view contains the given point.\n\t         * @interface\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        // containPoint: function () {}\n\t\n\t    };\n\t\n\t    var chartProto = Chart.prototype;\n\t    chartProto.updateView\n\t        = chartProto.updateLayout\n\t        = chartProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            this.render(seriesModel, ecModel, api, payload);\n\t        };\n\t\n\t    /**\n\t     * Set state of single element\n\t     * @param  {module:zrender/Element} el\n\t     * @param  {string} state\n\t     */\n\t    function elSetState(el, state) {\n\t        if (el) {\n\t            el.trigger(state);\n\t            if (el.type === 'group') {\n\t                for (var i = 0; i < el.childCount(); i++) {\n\t                    elSetState(el.childAt(i), state);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {Object} payload\n\t     * @param  {string} state 'normal'|'emphasis'\n\t     * @inner\n\t     */\n\t    function toggleHighlight(data, payload, state) {\n\t        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t        if (dataIndex != null) {\n\t            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n\t                elSetState(data.getItemGraphicEl(dataIdx), state);\n\t            });\n\t        }\n\t        else {\n\t            data.eachItemGraphicEl(function (el) {\n\t                elSetState(el, state);\n\t            });\n\t        }\n\t    }\n\t\n\t    // Enable Chart.extend.\n\t    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\t\n\t    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\t\n\t    module.exports = Chart;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(91);\n\t    var Eventful = __webpack_require__(28);\n\t    var Transformable = __webpack_require__(237);\n\t    var Animatable = __webpack_require__(235);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * \n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * \n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender  element  zrender \n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * true\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * (shape) Group \n\t         * \n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // \n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(206);\n\t    var color = __webpack_require__(29);\n\t    var util = __webpack_require__(1);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @param  {Object} props key-value\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!props.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param  {string|Function} easing\n\t         *         {@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                if (!this._tracks.hasOwnProperty(propName)) {\n\t                    continue;\n\t                }\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {number} time ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * \n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(36);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>'\n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(60);\n\t    var BoundingRect = __webpack_require__(14);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var LRU = __webpack_require__(215);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // \n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // \n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // \n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * [x, y]\n\t         * @type {Array.<number>}\n\t         */\n\t        textOffset: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(224);\n\t    var smoothBezier = __webpack_require__(223);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 97 */,\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(77);\n\t__webpack_require__(124);\n\tmodule.exports = __webpack_require__(16).Array.from;\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core  = __webpack_require__(16)\n\t  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\n\tmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n\t  return $JSON.stringify.apply($JSON, arguments);\n\t};\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(126);\n\t__webpack_require__(77);\n\t__webpack_require__(128);\n\t__webpack_require__(127);\n\tmodule.exports = __webpack_require__(16).Promise;\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it, Constructor, name, forbiddenField){\n\t  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n\t    throw TypeError(name + ': incorrect invocation!');\n\t  } return it;\n\t};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(49)\n\t  , toLength  = __webpack_require__(50)\n\t  , toIndex   = __webpack_require__(122);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $defineProperty = __webpack_require__(26)\n\t  , createDesc      = __webpack_require__(45);\n\t\n\tmodule.exports = function(object, index, value){\n\t  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n\t  else object[index] = value;\n\t};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx         = __webpack_require__(23)\n\t  , call        = __webpack_require__(68)\n\t  , isArrayIter = __webpack_require__(67)\n\t  , anObject    = __webpack_require__(18)\n\t  , toLength    = __webpack_require__(50)\n\t  , getIterFn   = __webpack_require__(76)\n\t  , BREAK       = {}\n\t  , RETURN      = {};\n\tvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n\t  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n\t    , f      = ctx(fn, that, entries ? 2 : 1)\n\t    , index  = 0\n\t    , length, step, iterator, result;\n\t  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n\t  // fast case for arrays with default iterator\n\t  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n\t    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n\t    if(result === BREAK || result === RETURN)return result;\n\t  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n\t    result = call(iterator, f, step.value, entries);\n\t    if(result === BREAK || result === RETURN)return result;\n\t  }\n\t};\n\texports.BREAK  = BREAK;\n\texports.RETURN = RETURN;\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(24) && !__webpack_require__(65)(function(){\n\t  return Object.defineProperty(__webpack_require__(43)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 107 */\n/***/ function(module, exports) {\n\n\t// fast apply, http://jsperf.lnkit.com/fast-apply/5\n\tmodule.exports = function(fn, args, that){\n\t  var un = that === undefined;\n\t  switch(args.length){\n\t    case 0: return un ? fn()\n\t                      : fn.call(that);\n\t    case 1: return un ? fn(args[0])\n\t                      : fn.call(that, args[0]);\n\t    case 2: return un ? fn(args[0], args[1])\n\t                      : fn.call(that, args[0], args[1]);\n\t    case 3: return un ? fn(args[0], args[1], args[2])\n\t                      : fn.call(that, args[0], args[1], args[2]);\n\t    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n\t                      : fn.call(that, args[0], args[1], args[2], args[3]);\n\t  } return              fn.apply(that, args);\n\t};\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(30);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(112)\n\t  , descriptor     = __webpack_require__(45)\n\t  , setToStringTag = __webpack_require__(46)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(19)(IteratorPrototype, __webpack_require__(7)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 110 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(8)\n\t  , macrotask = __webpack_require__(73).set\n\t  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n\t  , process   = global.process\n\t  , Promise   = global.Promise\n\t  , isNode    = __webpack_require__(30)(process) == 'process';\n\t\n\tmodule.exports = function(){\n\t  var head, last, notify;\n\t\n\t  var flush = function(){\n\t    var parent, fn;\n\t    if(isNode && (parent = process.domain))parent.exit();\n\t    while(head){\n\t      fn   = head.fn;\n\t      head = head.next;\n\t      try {\n\t        fn();\n\t      } catch(e){\n\t        if(head)notify();\n\t        else last = undefined;\n\t        throw e;\n\t      }\n\t    } last = undefined;\n\t    if(parent)parent.enter();\n\t  };\n\t\n\t  // Node.js\n\t  if(isNode){\n\t    notify = function(){\n\t      process.nextTick(flush);\n\t    };\n\t  // browsers with MutationObserver\n\t  } else if(Observer){\n\t    var toggle = true\n\t      , node   = document.createTextNode('');\n\t    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n\t    notify = function(){\n\t      node.data = toggle = !toggle;\n\t    };\n\t  // environments with maybe non-completely correct, but existent Promise\n\t  } else if(Promise && Promise.resolve){\n\t    var promise = Promise.resolve();\n\t    notify = function(){\n\t      promise.then(flush);\n\t    };\n\t  // for other environments - macrotask based on:\n\t  // - setImmediate\n\t  // - MessageChannel\n\t  // - window.postMessag\n\t  // - onreadystatechange\n\t  // - setTimeout\n\t  } else {\n\t    notify = function(){\n\t      // strange IE + webpack dev server bug - use .call(global)\n\t      macrotask.call(global, flush);\n\t    };\n\t  }\n\t\n\t  return function(fn){\n\t    var task = {fn: fn, next: undefined};\n\t    if(last)last.next = task;\n\t    if(!head){\n\t      head = task;\n\t      notify();\n\t    } last = task;\n\t  };\n\t};\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(18)\n\t  , dPs         = __webpack_require__(113)\n\t  , enumBugKeys = __webpack_require__(64)\n\t  , IE_PROTO    = __webpack_require__(47)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(43)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(66).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(26)\n\t  , anObject = __webpack_require__(18)\n\t  , getKeys  = __webpack_require__(116);\n\t\n\tmodule.exports = __webpack_require__(24) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(31)\n\t  , toObject    = __webpack_require__(74)\n\t  , IE_PROTO    = __webpack_require__(47)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(31)\n\t  , toIObject    = __webpack_require__(49)\n\t  , arrayIndexOf = __webpack_require__(103)(false)\n\t  , IE_PROTO     = __webpack_require__(47)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(115)\n\t  , enumBugKeys = __webpack_require__(64);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar hide = __webpack_require__(19);\n\tmodule.exports = function(target, src, safe){\n\t  for(var key in src){\n\t    if(safe && target[key])target[key] = src[key];\n\t    else hide(target, key, src[key]);\n\t  } return target;\n\t};\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(19);\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar global      = __webpack_require__(8)\n\t  , core        = __webpack_require__(16)\n\t  , dP          = __webpack_require__(26)\n\t  , DESCRIPTORS = __webpack_require__(24)\n\t  , SPECIES     = __webpack_require__(7)('species');\n\t\n\tmodule.exports = function(KEY){\n\t  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n\t  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n\t    configurable: true,\n\t    get: function(){ return this; }\n\t  });\n\t};\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.3.20 SpeciesConstructor(O, defaultConstructor)\n\tvar anObject  = __webpack_require__(18)\n\t  , aFunction = __webpack_require__(41)\n\t  , SPECIES   = __webpack_require__(7)('species');\n\tmodule.exports = function(O, D){\n\t  var C = anObject(O).constructor, S;\n\t  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n\t};\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(48)\n\t  , defined   = __webpack_require__(42);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(48)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(32);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ctx            = __webpack_require__(23)\n\t  , $export        = __webpack_require__(44)\n\t  , toObject       = __webpack_require__(74)\n\t  , call           = __webpack_require__(68)\n\t  , isArrayIter    = __webpack_require__(67)\n\t  , toLength       = __webpack_require__(50)\n\t  , createProperty = __webpack_require__(104)\n\t  , getIterFn      = __webpack_require__(76);\n\t\n\t$export($export.S + $export.F * !__webpack_require__(70)(function(iter){ Array.from(iter); }), 'Array', {\n\t  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n\t  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n\t    var O       = toObject(arrayLike)\n\t      , C       = typeof this == 'function' ? this : Array\n\t      , aLen    = arguments.length\n\t      , mapfn   = aLen > 1 ? arguments[1] : undefined\n\t      , mapping = mapfn !== undefined\n\t      , index   = 0\n\t      , iterFn  = getIterFn(O)\n\t      , length, result, step, iterator;\n\t    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n\t    // if object isn't iterable or it's array with default iterator - use simple case\n\t    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n\t      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n\t        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n\t      }\n\t    } else {\n\t      length = toLength(O.length);\n\t      for(result = new C(length); length > index; index++){\n\t        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n\t      }\n\t    }\n\t    result.length = index;\n\t    return result;\n\t  }\n\t});\n\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(101)\n\t  , step             = __webpack_require__(110)\n\t  , Iterators        = __webpack_require__(25)\n\t  , toIObject        = __webpack_require__(49);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(69)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 126 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY            = __webpack_require__(71)\n\t  , global             = __webpack_require__(8)\n\t  , ctx                = __webpack_require__(23)\n\t  , classof            = __webpack_require__(63)\n\t  , $export            = __webpack_require__(44)\n\t  , isObject           = __webpack_require__(32)\n\t  , aFunction          = __webpack_require__(41)\n\t  , anInstance         = __webpack_require__(102)\n\t  , forOf              = __webpack_require__(105)\n\t  , speciesConstructor = __webpack_require__(120)\n\t  , task               = __webpack_require__(73).set\n\t  , microtask          = __webpack_require__(111)()\n\t  , PROMISE            = 'Promise'\n\t  , TypeError          = global.TypeError\n\t  , process            = global.process\n\t  , $Promise           = global[PROMISE]\n\t  , process            = global.process\n\t  , isNode             = classof(process) == 'process'\n\t  , empty              = function(){ /* empty */ }\n\t  , Internal, GenericPromiseCapability, Wrapper;\n\t\n\tvar USE_NATIVE = !!function(){\n\t  try {\n\t    // correct subclassing with @@species support\n\t    var promise     = $Promise.resolve(1)\n\t      , FakePromise = (promise.constructor = {})[__webpack_require__(7)('species')] = function(exec){ exec(empty, empty); };\n\t    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n\t    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n\t  } catch(e){ /* empty */ }\n\t}();\n\t\n\t// helpers\n\tvar sameConstructor = function(a, b){\n\t  // with library wrapper special case\n\t  return a === b || a === $Promise && b === Wrapper;\n\t};\n\tvar isThenable = function(it){\n\t  var then;\n\t  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n\t};\n\tvar newPromiseCapability = function(C){\n\t  return sameConstructor($Promise, C)\n\t    ? new PromiseCapability(C)\n\t    : new GenericPromiseCapability(C);\n\t};\n\tvar PromiseCapability = GenericPromiseCapability = function(C){\n\t  var resolve, reject;\n\t  this.promise = new C(function($$resolve, $$reject){\n\t    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n\t    resolve = $$resolve;\n\t    reject  = $$reject;\n\t  });\n\t  this.resolve = aFunction(resolve);\n\t  this.reject  = aFunction(reject);\n\t};\n\tvar perform = function(exec){\n\t  try {\n\t    exec();\n\t  } catch(e){\n\t    return {error: e};\n\t  }\n\t};\n\tvar notify = function(promise, isReject){\n\t  if(promise._n)return;\n\t  promise._n = true;\n\t  var chain = promise._c;\n\t  microtask(function(){\n\t    var value = promise._v\n\t      , ok    = promise._s == 1\n\t      , i     = 0;\n\t    var run = function(reaction){\n\t      var handler = ok ? reaction.ok : reaction.fail\n\t        , resolve = reaction.resolve\n\t        , reject  = reaction.reject\n\t        , domain  = reaction.domain\n\t        , result, then;\n\t      try {\n\t        if(handler){\n\t          if(!ok){\n\t            if(promise._h == 2)onHandleUnhandled(promise);\n\t            promise._h = 1;\n\t          }\n\t          if(handler === true)result = value;\n\t          else {\n\t            if(domain)domain.enter();\n\t            result = handler(value);\n\t            if(domain)domain.exit();\n\t          }\n\t          if(result === reaction.promise){\n\t            reject(TypeError('Promise-chain cycle'));\n\t          } else if(then = isThenable(result)){\n\t            then.call(result, resolve, reject);\n\t          } else resolve(result);\n\t        } else reject(value);\n\t      } catch(e){\n\t        reject(e);\n\t      }\n\t    };\n\t    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n\t    promise._c = [];\n\t    promise._n = false;\n\t    if(isReject && !promise._h)onUnhandled(promise);\n\t  });\n\t};\n\tvar onUnhandled = function(promise){\n\t  task.call(global, function(){\n\t    var value = promise._v\n\t      , abrupt, handler, console;\n\t    if(isUnhandled(promise)){\n\t      abrupt = perform(function(){\n\t        if(isNode){\n\t          process.emit('unhandledRejection', value, promise);\n\t        } else if(handler = global.onunhandledrejection){\n\t          handler({promise: promise, reason: value});\n\t        } else if((console = global.console) && console.error){\n\t          console.error('Unhandled promise rejection', value);\n\t        }\n\t      });\n\t      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n\t      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n\t    } promise._a = undefined;\n\t    if(abrupt)throw abrupt.error;\n\t  });\n\t};\n\tvar isUnhandled = function(promise){\n\t  if(promise._h == 1)return false;\n\t  var chain = promise._a || promise._c\n\t    , i     = 0\n\t    , reaction;\n\t  while(chain.length > i){\n\t    reaction = chain[i++];\n\t    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n\t  } return true;\n\t};\n\tvar onHandleUnhandled = function(promise){\n\t  task.call(global, function(){\n\t    var handler;\n\t    if(isNode){\n\t      process.emit('rejectionHandled', promise);\n\t    } else if(handler = global.onrejectionhandled){\n\t      handler({promise: promise, reason: promise._v});\n\t    }\n\t  });\n\t};\n\tvar $reject = function(value){\n\t  var promise = this;\n\t  if(promise._d)return;\n\t  promise._d = true;\n\t  promise = promise._w || promise; // unwrap\n\t  promise._v = value;\n\t  promise._s = 2;\n\t  if(!promise._a)promise._a = promise._c.slice();\n\t  notify(promise, true);\n\t};\n\tvar $resolve = function(value){\n\t  var promise = this\n\t    , then;\n\t  if(promise._d)return;\n\t  promise._d = true;\n\t  promise = promise._w || promise; // unwrap\n\t  try {\n\t    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n\t    if(then = isThenable(value)){\n\t      microtask(function(){\n\t        var wrapper = {_w: promise, _d: false}; // wrap\n\t        try {\n\t          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n\t        } catch(e){\n\t          $reject.call(wrapper, e);\n\t        }\n\t      });\n\t    } else {\n\t      promise._v = value;\n\t      promise._s = 1;\n\t      notify(promise, false);\n\t    }\n\t  } catch(e){\n\t    $reject.call({_w: promise, _d: false}, e); // wrap\n\t  }\n\t};\n\t\n\t// constructor polyfill\n\tif(!USE_NATIVE){\n\t  // 25.4.3.1 Promise(executor)\n\t  $Promise = function Promise(executor){\n\t    anInstance(this, $Promise, PROMISE, '_h');\n\t    aFunction(executor);\n\t    Internal.call(this);\n\t    try {\n\t      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n\t    } catch(err){\n\t      $reject.call(this, err);\n\t    }\n\t  };\n\t  Internal = function Promise(executor){\n\t    this._c = [];             // <- awaiting reactions\n\t    this._a = undefined;      // <- checked in isUnhandled reactions\n\t    this._s = 0;              // <- state\n\t    this._d = false;          // <- done\n\t    this._v = undefined;      // <- value\n\t    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n\t    this._n = false;          // <- notify\n\t  };\n\t  Internal.prototype = __webpack_require__(117)($Promise.prototype, {\n\t    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n\t    then: function then(onFulfilled, onRejected){\n\t      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n\t      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n\t      reaction.fail   = typeof onRejected == 'function' && onRejected;\n\t      reaction.domain = isNode ? process.domain : undefined;\n\t      this._c.push(reaction);\n\t      if(this._a)this._a.push(reaction);\n\t      if(this._s)notify(this, false);\n\t      return reaction.promise;\n\t    },\n\t    // 25.4.5.1 Promise.prototype.catch(onRejected)\n\t    'catch': function(onRejected){\n\t      return this.then(undefined, onRejected);\n\t    }\n\t  });\n\t  PromiseCapability = function(){\n\t    var promise  = new Internal;\n\t    this.promise = promise;\n\t    this.resolve = ctx($resolve, promise, 1);\n\t    this.reject  = ctx($reject, promise, 1);\n\t  };\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\n\t__webpack_require__(46)($Promise, PROMISE);\n\t__webpack_require__(119)(PROMISE);\n\tWrapper = __webpack_require__(16)[PROMISE];\n\t\n\t// statics\n\t$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n\t  // 25.4.4.5 Promise.reject(r)\n\t  reject: function reject(r){\n\t    var capability = newPromiseCapability(this)\n\t      , $$reject   = capability.reject;\n\t    $$reject(r);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n\t  // 25.4.4.6 Promise.resolve(x)\n\t  resolve: function resolve(x){\n\t    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n\t    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n\t    var capability = newPromiseCapability(this)\n\t      , $$resolve  = capability.resolve;\n\t    $$resolve(x);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(70)(function(iter){\n\t  $Promise.all(iter)['catch'](empty);\n\t})), PROMISE, {\n\t  // 25.4.4.1 Promise.all(iterable)\n\t  all: function all(iterable){\n\t    var C          = this\n\t      , capability = newPromiseCapability(C)\n\t      , resolve    = capability.resolve\n\t      , reject     = capability.reject;\n\t    var abrupt = perform(function(){\n\t      var values    = []\n\t        , index     = 0\n\t        , remaining = 1;\n\t      forOf(iterable, false, function(promise){\n\t        var $index        = index++\n\t          , alreadyCalled = false;\n\t        values.push(undefined);\n\t        remaining++;\n\t        C.resolve(promise).then(function(value){\n\t          if(alreadyCalled)return;\n\t          alreadyCalled  = true;\n\t          values[$index] = value;\n\t          --remaining || resolve(values);\n\t        }, reject);\n\t      });\n\t      --remaining || resolve(values);\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  },\n\t  // 25.4.4.4 Promise.race(iterable)\n\t  race: function race(iterable){\n\t    var C          = this\n\t      , capability = newPromiseCapability(C)\n\t      , reject     = capability.reject;\n\t    var abrupt = perform(function(){\n\t      forOf(iterable, false, function(promise){\n\t        C.resolve(promise).then(capability.resolve, reject);\n\t      });\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  }\n\t});\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(125);\n\tvar global        = __webpack_require__(8)\n\t  , hide          = __webpack_require__(19)\n\t  , Iterators     = __webpack_require__(25)\n\t  , TO_STRING_TAG = __webpack_require__(7)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(100), __esModule: true };\n\n/***/ },\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var echartsAPIList = [\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n\t        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n\t    ];\n\t\n\t    function ExtensionAPI(chartInstance) {\n\t        zrUtil.each(echartsAPIList, function (name) {\n\t            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n\t        }, this);\n\t    }\n\t\n\t    module.exports = ExtensionAPI;\n\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var echarts = __webpack_require__(2);\n\t    var zrUtil = __webpack_require__(1);\n\t    module.exports = function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent(\n\t                    {mainType: 'series', subType: seriesType, query: payload},\n\t                    function (seriesModel) {\n\t                        if (seriesModel[actionInfo.method]) {\n\t                            seriesModel[actionInfo.method](payload.name);\n\t                        }\n\t                        var data = seriesModel.getData();\n\t                        // Create selected map\n\t                        data.each(function (idx) {\n\t                            var name = data.getName(idx);\n\t                            selected[name] = seriesModel.isSelected(name) || false;\n\t                        });\n\t                    }\n\t                );\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\n\n/***/ },\n/* 143 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    __webpack_require__(82);\n\t\n\t    __webpack_require__(144);\n\t    __webpack_require__(145);\n\t\n\t    var barLayoutGrid = __webpack_require__(180);\n\t    var echarts = __webpack_require__(2);\n\t\n\t    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n\t    // Visual coding for legend\n\t    echarts.registerVisual(function (ecModel) {\n\t        ecModel.eachSeriesByType('bar', function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            data.setVisual('legendSymbol', 'roundRect');\n\t        });\n\t    });\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(80);\n\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(146).extend({\n\t\n\t        type: 'series.bar',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        brushSelector: 'rect'\n\t    });\n\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var graphic = __webpack_require__(3);\n\t    var helper = __webpack_require__(148);\n\t\n\t    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\t\n\t    // FIXME\n\t    // Just for compatible with ec2.\n\t    zrUtil.extend(__webpack_require__(12).prototype, __webpack_require__(147));\n\t\n\t    var BarView = __webpack_require__(2).extendChartView({\n\t\n\t        type: 'bar',\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\t\n\t            if (coordinateSystemType === 'cartesian2d') {\n\t                this._renderOnCartesian(seriesModel, ecModel, api);\n\t            }\n\t\n\t            return this.group;\n\t        },\n\t\n\t        dispose: zrUtil.noop,\n\t\n\t        _renderOnCartesian: function (seriesModel, ecModel, api) {\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var isHorizontal = baseAxis.isHorizontal();\n\t            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\t\n\t            data.diff(oldData)\n\t                .add(function (dataIndex) {\n\t                    if (!data.hasValue(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var itemModel = data.getItemModel(dataIndex);\n\t                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n\t                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n\t                    data.setItemGraphicEl(dataIndex, el);\n\t                    group.add(el);\n\t\n\t                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n\t                })\n\t                .update(function (newIndex, oldIndex) {\n\t                    var el = oldData.getItemGraphicEl(oldIndex);\n\t\n\t                    if (!data.hasValue(newIndex)) {\n\t                        group.remove(el);\n\t                        return;\n\t                    }\n\t\n\t                    var itemModel = data.getItemModel(newIndex);\n\t                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\t\n\t                    if (el) {\n\t                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n\t                    }\n\t                    else {\n\t                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n\t                    }\n\t\n\t                    data.setItemGraphicEl(newIndex, el);\n\t                    // Add back\n\t                    group.add(el);\n\t\n\t                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n\t                })\n\t                .remove(function (dataIndex) {\n\t                    var el = oldData.getItemGraphicEl(dataIndex);\n\t                    el && removeRect(dataIndex, animationModel, el);\n\t                })\n\t                .execute();\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        remove: function (ecModel, api) {\n\t            var group = this.group;\n\t            var data = this._data;\n\t            if (ecModel.get('animation')) {\n\t                if (data) {\n\t                    data.eachItemGraphicEl(function (el) {\n\t                        removeRect(el.dataIndex, ecModel, el);\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    });\n\t\n\t    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n\t        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\t\n\t        // Animation\n\t        if (animationModel) {\n\t            var rectShape = rect.shape;\n\t            var animateProperty = isHorizontal ? 'height' : 'width';\n\t            var animateTarget = {};\n\t            rectShape[animateProperty] = 0;\n\t            animateTarget[animateProperty] = layout[animateProperty];\n\t            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n\t                shape: animateTarget\n\t            }, animationModel, dataIndex);\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function removeRect(dataIndex, animationModel, el) {\n\t        // Not show text when animating\n\t        el.style.text = '';\n\t        graphic.updateProps(el, {\n\t            shape: {\n\t                width: 0\n\t            }\n\t        }, animationModel, dataIndex, function () {\n\t            el.parent && el.parent.remove(el);\n\t        });\n\t    }\n\t\n\t    function getRectItemLayout(data, dataIndex, itemModel) {\n\t        var layout = data.getItemLayout(dataIndex);\n\t        var fixedLineWidth = getLineWidth(itemModel, layout);\n\t\n\t        // fix layout with lineWidth\n\t        var signX = layout.width > 0 ? 1 : -1;\n\t        var signY = layout.height > 0 ? 1 : -1;\n\t        return {\n\t            x: layout.x + signX * fixedLineWidth / 2,\n\t            y: layout.y + signY * fixedLineWidth / 2,\n\t            width: layout.width - signX * fixedLineWidth,\n\t            height: layout.height - signY * fixedLineWidth\n\t        };\n\t    }\n\t\n\t    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n\t        var color = data.getItemVisual(dataIndex, 'color');\n\t        var opacity = data.getItemVisual(dataIndex, 'opacity');\n\t        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n\t        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\t\n\t        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\t\n\t        el.useStyle(zrUtil.defaults(\n\t            {\n\t                fill: color,\n\t                opacity: opacity\n\t            },\n\t            itemStyleModel.getBarItemStyle()\n\t        ));\n\t\n\t        var labelPositionOutside = isHorizontal\n\t            ? (layout.height > 0 ? 'bottom' : 'top')\n\t            : (layout.width > 0 ? 'left' : 'right');\n\t\n\t        helper.setLabel(\n\t            el.style, hoverStyle, itemModel, color,\n\t            seriesModel, dataIndex, labelPositionOutside\n\t        );\n\t\n\t        graphic.setHoverStyle(el, hoverStyle);\n\t    }\n\t\n\t    // In case width or height are too small.\n\t    function getLineWidth(itemModel, rawLayout) {\n\t        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n\t        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n\t    }\n\t\n\t    module.exports = BarView;\n\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var SeriesModel = __webpack_require__(84);\n\t    var createListFromArray = __webpack_require__(149);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.__base_bar__',\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (__DEV__) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'cartesian2d') {\n\t                    throw new Error('Bar only support cartesian2d coordinateSystem');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        getMarkerPosition: function (value) {\n\t            var coordSys = this.coordinateSystem;\n\t            if (coordSys) {\n\t                // PENDING if clamp ?\n\t                var pt = coordSys.dataToPoint(value, true);\n\t                var data = this.getData();\n\t                var offset = data.getLayout('offset');\n\t                var size = data.getLayout('size');\n\t                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n\t                pt[offsetIndex] += offset + size / 2;\n\t                return pt;\n\t            }\n\t            return [NaN, NaN];\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // \n\t            z: 2,                       // \n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t            // stack: null\n\t\n\t            // Cartesian coordinate system\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // 0\n\t            barMinHeight: 0,\n\t\n\t            // barMaxWidth: null,\n\t            // \n\t            // barWidth: null,\n\t            // 30%\n\t            // barGap: '30%',\n\t            // 20%\n\t            // barCategoryGap: '20%',\n\t            // label: {\n\t            //     normal: {\n\t            //         show: false\n\t            //     }\n\t            // },\n\t            itemStyle: {\n\t                normal: {\n\t                    // color: ''\n\t                },\n\t                emphasis: {}\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t\n\t    var getBarItemStyle = __webpack_require__(34)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            // Compatitable with 2\n\t            ['stroke', 'barBorderColor'],\n\t            ['lineWidth', 'barBorderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getBarItemStyle: function (excludes) {\n\t            var style = getBarItemStyle.call(this, excludes);\n\t            if (this.getBorderLineDash) {\n\t                var lineDash = this.getBorderLineDash();\n\t                lineDash && (style.lineDash = lineDash);\n\t            }\n\t            return style;\n\t        }\n\t    };\n\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var graphic = __webpack_require__(3);\n\t\n\t    var helper = {};\n\t\n\t    helper.setLabel = function (\n\t        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n\t    ) {\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\t\n\t        if (labelModel.get('show')) {\n\t            setLabel(\n\t                normalStyle, labelModel, color,\n\t                zrUtil.retrieve(\n\t                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n\t                    seriesModel.getRawValue(dataIndex)\n\t                ),\n\t                labelPositionOutside\n\t            );\n\t        }\n\t        else {\n\t            normalStyle.text = '';\n\t        }\n\t\n\t        if (hoverLabelModel.get('show')) {\n\t            setLabel(\n\t                hoverStyle, hoverLabelModel, color,\n\t                zrUtil.retrieve(\n\t                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n\t                    seriesModel.getRawValue(dataIndex)\n\t                ),\n\t                labelPositionOutside\n\t            );\n\t        }\n\t        else {\n\t            hoverStyle.text = '';\n\t        }\n\t    };\n\t\n\t    function setLabel(style, model, color, labelText, labelPositionOutside) {\n\t        graphic.setText(style, model, color);\n\t        style.text = labelText;\n\t        if (style.textPosition === 'outside') {\n\t            style.textPosition = labelPositionOutside;\n\t        }\n\t    }\n\t\n\t    module.exports = helper;\n\n\n/***/ },\n/* 149 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(56);\n\t    var completeDimensions = __webpack_require__(83);\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(13);\n\t    var CoordinateSystem = __webpack_require__(54);\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null\n\t            && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t\n\t        if (__DEV__) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t\n\t        var list = new List(dimensions, seriesModel);\n\t\n\t        var nameList = createNameList(axesInfo, data);\n\t\n\t        var categories = {};\n\t        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n\t            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex\n\t                    ? dataIndex\n\t                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            }\n\t            : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName]\n\t                            || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t\n\t        return list;\n\t    }\n\t\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category'\n\t            ? 'ordinal'\n\t            : axisType === 'time'\n\t            ? 'time'\n\t            : 'float';\n\t    }\n\t\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t\n\t        cartesian2d: function (data, seriesModel, ecModel) {\n\t\n\t            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n\t                return ecModel.queryComponents({\n\t                    mainType: name,\n\t                    index: seriesModel.get(name + 'Index'),\n\t                    id: seriesModel.get(name + 'Id')\n\t                })[0];\n\t            });\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            if (__DEV__) {\n\t                if (!xAxisModel) {\n\t                    throw new Error('xAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('xAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t                if (!yAxisModel) {\n\t                    throw new Error('yAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('yAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t\n\t            var xAxisType = xAxisModel.get('type');\n\t            var yAxisType = yAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'x',\n\t                    type: getDimTypeByAxis(xAxisType),\n\t                    stackable: isStackable(xAxisType)\n\t                },\n\t                {\n\t                    name: 'y',\n\t                    // If two category axes\n\t                    type: getDimTypeByAxis(yAxisType),\n\t                    stackable: isStackable(yAxisType)\n\t                }\n\t            ];\n\t\n\t            var isXAxisCateogry = xAxisType === 'category';\n\t            var isYAxisCategory = yAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isXAxisCateogry) {\n\t                categoryAxesModels.x = xAxisModel;\n\t            }\n\t            if (isYAxisCategory) {\n\t                categoryAxesModels.y = yAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        singleAxis: function (data, seriesModel, ecModel) {\n\t\n\t            var singleAxisModel = ecModel.queryComponents({\n\t                mainType: 'singleAxis',\n\t                index: seriesModel.get('singleAxisIndex'),\n\t                id: seriesModel.get('singleAxisId')\n\t            })[0];\n\t\n\t            if (__DEV__) {\n\t                if (!singleAxisModel) {\n\t                    throw new Error('singleAxis should be specified.');\n\t                }\n\t            }\n\t\n\t            var singleAxisType = singleAxisModel.get('type');\n\t            var isCategory = singleAxisType === 'category';\n\t\n\t            var dimensions = [{\n\t                name: 'single',\n\t                type: getDimTypeByAxis(singleAxisType),\n\t                stackable: isStackable(singleAxisType)\n\t            }];\n\t\n\t            completeDimensions(dimensions, data);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isCategory) {\n\t                categoryAxesModels.single = singleAxisModel;\n\t            }\n\t\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isCategory ? 0 : -1,\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        polar: function (data, seriesModel, ecModel) {\n\t            var polarModel = ecModel.queryComponents({\n\t                mainType: 'polar',\n\t                index: seriesModel.get('polarIndex'),\n\t                id: seriesModel.get('polarId')\n\t            })[0];\n\t\n\t            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t\n\t            if (__DEV__) {\n\t                if (!angleAxisModel) {\n\t                    throw new Error('angleAxis option not found');\n\t                }\n\t                if (!radiusAxisModel) {\n\t                    throw new Error('radiusAxis option not found');\n\t                }\n\t            }\n\t\n\t            var radiusAxisType = radiusAxisModel.get('type');\n\t            var angleAxisType = angleAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'radius',\n\t                    type: getDimTypeByAxis(radiusAxisType),\n\t                    stackable: isStackable(radiusAxisType)\n\t                },\n\t                {\n\t                    name: 'angle',\n\t                    type: getDimTypeByAxis(angleAxisType),\n\t                    stackable: isStackable(angleAxisType)\n\t                }\n\t            ];\n\t            var isAngleAxisCateogry = angleAxisType === 'category';\n\t            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isRadiusAxisCateogry) {\n\t                categoryAxesModels.radius = radiusAxisModel;\n\t            }\n\t            if (isAngleAxisCateogry) {\n\t                categoryAxesModels.angle = angleAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        geo: function (data, seriesModel, ecModel) {\n\t            // TODO Region\n\t            // \n\t            return {\n\t                dimensions: completeDimensions([\n\t                    {name: 'lng'},\n\t                    {name: 'lat'}\n\t                ], data, ['lng', 'lat', 'value'])\n\t            };\n\t        }\n\t    };\n\t\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                }\n\t                else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        return nameList;\n\t    }\n\t\n\t    module.exports = createListFromArray;\n\t\n\n\n/***/ },\n/* 150 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var echarts = __webpack_require__(2);\n\t\n\t    __webpack_require__(151);\n\t    __webpack_require__(152);\n\t\n\t    __webpack_require__(142)('pie', [{\n\t        type: 'pieToggleSelect',\n\t        event: 'pieselectchanged',\n\t        method: 'toggleSelected'\n\t    }, {\n\t        type: 'pieSelect',\n\t        event: 'pieselected',\n\t        method: 'select'\n\t    }, {\n\t        type: 'pieUnSelect',\n\t        event: 'pieunselected',\n\t        method: 'unSelect'\n\t    }]);\n\t\n\t    echarts.registerVisual(zrUtil.curry(__webpack_require__(199), 'pie'));\n\t\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(154), 'pie'\n\t    ));\n\t\n\t    echarts.registerProcessor(zrUtil.curry(__webpack_require__(192), 'pie'));\n\n\n/***/ },\n/* 151 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(56);\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(13);\n\t    var completeDimensions = __webpack_require__(83);\n\t\n\t    var dataSelectableMixin = __webpack_require__(159);\n\t\n\t    var PieSeries = __webpack_require__(2).extendSeriesModel({\n\t\n\t        type: 'series.pie',\n\t\n\t        // Overwrite\n\t        init: function (option) {\n\t            PieSeries.superApply(this, 'init', arguments);\n\t\n\t            // Enable legend selection for each data item\n\t            // Use a function instead of direct access because data reference may changed\n\t            this.legendDataProvider = function () {\n\t                return this.getRawData();\n\t            };\n\t\n\t            this.updateSelectedMap(option.data);\n\t\n\t            this._defaultLabelLine(option);\n\t        },\n\t\n\t        // Overwrite\n\t        mergeOption: function (newOption) {\n\t            PieSeries.superCall(this, 'mergeOption', newOption);\n\t            this.updateSelectedMap(this.option.data);\n\t        },\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var dimensions = completeDimensions(['value'], option.data);\n\t            var list = new List(dimensions, this);\n\t            list.initData(option.data);\n\t            return list;\n\t        },\n\t\n\t        // Overwrite\n\t        getDataParams: function (dataIndex) {\n\t            var data = this.getData();\n\t            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t            var sum = data.getSum('value');\n\t            // FIXME toFixed?\n\t            //\n\t            // Percent is 0 if sum is 0\n\t            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t\n\t            params.$vars.push('percent');\n\t            return params;\n\t        },\n\t\n\t        _defaultLabelLine: function (option) {\n\t            // Extend labelLine emphasis\n\t            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t\n\t            var labelLineNormalOpt = option.labelLine.normal;\n\t            var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t            // Not show label line if `label.normal.show = false`\n\t            labelLineNormalOpt.show = labelLineNormalOpt.show\n\t                && option.label.normal.show;\n\t            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n\t                && option.label.emphasis.show;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // \n\t            center: ['50%', '50%'],\n\t            radius: [0, '75%'],\n\t            // \n\t            clockwise: true,\n\t            startAngle: 90,\n\t            // 0\n\t            minAngle: 0,\n\t            // \n\t            selectedOffset: 10,\n\t\n\t            // If use strategy to avoid label overlapping\n\t            avoidLabelOverlap: true,\n\t            // singlemultiple\n\t            // selectedMode: false,\n\t            // 'radius' | 'area'\n\t            // roseType: null,\n\t\n\t            // If still show when all data zero.\n\t            stillShowZeroSum: true,\n\t\n\t            label: {\n\t                normal: {\n\t                    // If rotate around circle\n\t                    rotate: false,\n\t                    show: true,\n\t                    // 'outer', 'inside', 'center'\n\t                    position: 'outer'\n\t                    // formatter: Tooltip.formatter\n\t                    // textStyle: null      // TEXTSTYLE\n\t                    // distance: positioninnerlabel()\n\t                },\n\t                emphasis: {}\n\t            },\n\t            // Enabled when label.normal.position is 'outer'\n\t            labelLine: {\n\t                normal: {\n\t                    show: true,\n\t                    // \n\t                    length: 15,\n\t                    // \n\t                    length2: 15,\n\t                    smooth: false,\n\t                    lineStyle: {\n\t                        // color: ,\n\t                        width: 1,\n\t                        type: 'solid'\n\t                    }\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 1\n\t                },\n\t                emphasis: {}\n\t            },\n\t\n\t            // Animation type canbe expansion, scale\n\t            animationType: 'expansion',\n\t\n\t            animationEasing: 'cubicOut',\n\t\n\t            data: []\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t\n\t    module.exports = PieSeries;\n\n\n/***/ },\n/* 152 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(3);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t\n\t        data.each(function (idx) {\n\t            toggleItemSelected(\n\t                data.getItemGraphicEl(idx),\n\t                data.getItemLayout(idx),\n\t                seriesModel.isSelected(data.getName(idx)),\n\t                selectedOffset,\n\t                hasAnimation\n\t            );\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [dx * offset, dy * offset];\n\t\n\t        hasAnimation\n\t            // animateTo will stop revious animation like update transition\n\t            ? el.animate()\n\t                .when(200, {\n\t                    position: position\n\t                })\n\t                .start('bounceOut')\n\t            : el.attr('position', position);\n\t    }\n\t\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t\n\t        graphic.Group.call(this);\n\t\n\t        var sector = new graphic.Sector({\n\t            z2: 2\n\t        });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t\n\t        this.updateData(data, idx, true);\n\t\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis)\n\t            .on('normal', onNormal)\n\t            .on('mouseover', onEmphasis)\n\t            .on('mouseout', onNormal);\n\t    }\n\t\n\t    var piePieceProto = PiePiece.prototype;\n\t\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor()\n\t                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(\n\t                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n\t            )\n\t        };\n\t    }\n\t\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t\n\t        var sector = this.childAt(0);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t\n\t            var animationType = seriesModel.getShallow('animationType');\n\t            if (animationType === 'scale') {\n\t                sector.shape.r = layout.r0;\n\t                graphic.initProps(sector, {\n\t                    shape: {\n\t                        r: layout.r\n\t                    }\n\t                }, seriesModel, idx);\n\t            }\n\t            // Expansion\n\t            else {\n\t                sector.shape.endAngle = layout.startAngle;\n\t                graphic.updateProps(sector, {\n\t                    shape: {\n\t                        endAngle: layout.endAngle\n\t                    }\n\t                }, seriesModel, idx);\n\t            }\n\t\n\t        }\n\t        else {\n\t            graphic.updateProps(sector, {\n\t                shape: sectorShape\n\t            }, seriesModel, idx);\n\t        }\n\t\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        sector.useStyle(\n\t            zrUtil.defaults(\n\t                {\n\t                    lineJoin: 'bevel',\n\t                    fill: visualColor\n\t                },\n\t                itemStyleModel.getModel('normal').getItemStyle()\n\t            )\n\t        );\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t        // Toggle selected\n\t        toggleItemSelected(\n\t            this,\n\t            data.getItemLayout(idx),\n\t            itemModel.get('selected'),\n\t            seriesModel.get('selectedOffset'),\n\t            seriesModel.get('animation')\n\t        );\n\t\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r + 10\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n\t            sector\n\t                .on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t\n\t        this._updateLabel(data, idx);\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [labelLayout.x, labelLayout.y],\n\t            z2: 10\n\t        });\n\t\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({\n\t            smooth: smooth\n\t        });\n\t    };\n\t\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t\n\t\n\t    // Pie view\n\t    var Pie = __webpack_require__(86).extend({\n\t\n\t        type: 'pie',\n\t\n\t        init: function () {\n\t            var sectorGroup = new graphic.Group();\n\t            this._sectorGroup = sectorGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t            if (payload && (payload.from === this.uid)) {\n\t                return;\n\t            }\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var group = this.group;\n\t\n\t            var hasAnimation = ecModel.get('animation');\n\t            var isFirstRender = !oldData;\n\t            var animationType = seriesModel.get('animationType');\n\t\n\t            var onSectorClick = zrUtil.curry(\n\t                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n\t            );\n\t\n\t            var selectedMode = seriesModel.get('selectedMode');\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    // Default expansion animation\n\t                    if (isFirstRender && animationType !== 'scale') {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t\n\t                    group.add(piePiece);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    piePiece.updateData(data, newIdx);\n\t\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                })\n\t                .remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                })\n\t                .execute();\n\t\n\t            if (\n\t                hasAnimation && isFirstRender && data.count() > 0\n\t                // Default expansion animation\n\t                && animationType !== 'scale'\n\t            ) {\n\t                var shape = data.getItemLayout(0);\n\t                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t\n\t                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                group.setClipPath(this._createClipPath(\n\t                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n\t                ));\n\t            }\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _createClipPath: function (\n\t            cx, cy, r, startAngle, clockwise, cb, seriesModel\n\t        ) {\n\t            var clipPath = new graphic.Sector({\n\t                shape: {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: 0,\n\t                    r: r,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle,\n\t                    clockwise: clockwise\n\t                }\n\t            });\n\t\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n\t                }\n\t            }, seriesModel, cb);\n\t\n\t            return clipPath;\n\t        },\n\t\n\t        /**\n\t         * @implement\n\t         */\n\t        containPoint: function (point, seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var itemLayout = data.getItemLayout(0);\n\t            if (itemLayout) {\n\t                var dx = point[0] - itemLayout.cx;\n\t                var dy = point[1] - itemLayout.cy;\n\t                var radius = Math.sqrt(dx * dx + dy * dy);\n\t                return radius <= itemLayout.r && radius >= itemLayout.r0;\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = Pie;\n\n\n/***/ },\n/* 153 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME emphasis label position is not same with normal label position\n\t\n\t\n\t    var textContain = __webpack_require__(21);\n\t\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t\n\t        // \n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start\n\t                    && j + 1 < end\n\t                    && list[j + 1].y > list[j].y + list[j].height\n\t                ) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t\n\t        // \n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0\n\t                    && list[j].y > list[j - 1].y + list[j - 1].height\n\t                ) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0\n\t                ? isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0                     // \n\t                : isDownList                // \n\t                    ? Number.MAX_VALUE      // \n\t                    : 0;                    // \n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = (deltaY < r + length)\n\t                    ? Math.sqrt(\n\t                          (r + length + length2) * (r + length + length2)\n\t                          - deltaY * deltaY\n\t                      )\n\t                    : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // \n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            }\n\t            else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            }\n\t            else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                }\n\t                else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            }\n\t            else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n\t                    var y3 = y2;\n\t\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n\t                }\n\t\n\t                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t\n\t            var labelRotate = labelModel.get('rotate')\n\t                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal')\n\t                        || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(\n\t                text, font, textAlign, 'top'\n\t            );\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\n\n/***/ },\n/* 154 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO minAngle\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = __webpack_require__(153);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t\n\t    module.exports = function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [0, radius];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [center, center];\n\t            }\n\t\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t\n\t            var data = seriesModel.getData();\n\t\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t\n\t            var roseType = seriesModel.get('roseType');\n\t            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\t\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t\n\t            var currentAngle = startAngle;\n\t\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                if (isNaN(value)) {\n\t                    data.setItemLayout(idx, {\n\t                        angle: NaN,\n\t                        startAngle: NaN,\n\t                        endAngle: NaN,\n\t                        clockwise: clockwise,\n\t                        cx: cx,\n\t                        cy: cy,\n\t                        r0: r0,\n\t                        r: roseType\n\t                            ? NaN\n\t                            : r\n\t                    });\n\t                    return;\n\t                }\n\t\n\t                // FIXME  2.0  roseType  area \n\t                if (roseType !== 'area') {\n\t                    angle = (sum === 0 && stillShowZeroSum)\n\t                        ? unitRadian : (value * unitRadian);\n\t                }\n\t                else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                }\n\t                else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType\n\t                        ? numberUtil.linearMap(value, extent, [r0, r])\n\t                        : r\n\t                });\n\t\n\t                currentAngle = endAngle;\n\t            }, true);\n\t\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 1e-3) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                }\n\t                else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle\n\t                            ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += dir * angle;\n\t                    });\n\t                }\n\t            }\n\t\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\n\n/***/ },\n/* 155 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// TODO boundaryGap\n\t\n\t\n\t    __webpack_require__(81);\n\t\n\t    __webpack_require__(157);\n\n\n/***/ },\n/* 156 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var graphic = __webpack_require__(3);\n\t    var Model = __webpack_require__(12);\n\t    var numberUtil = __webpack_require__(4);\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = __webpack_require__(5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t\n\t    var PI = Math.PI;\n\t\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = {\n\t            componentType: axisModel.mainType\n\t        };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t\n\t        // Default value\n\t        zrUtil.defaults(\n\t            opt,\n\t            {\n\t                labelOffset: 0,\n\t                nameDirection: 1,\n\t                tickDirection: 1,\n\t                labelDirection: 1,\n\t                silent: true\n\t            }\n\t        );\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t            position: opt.position.slice(),\n\t            rotation: opt.rotation\n\t        });\n\t\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t\n\t    AxisBuilder.prototype = {\n\t\n\t        constructor: AxisBuilder,\n\t\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t\n\t    };\n\t\n\t    var builders = {\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisLine: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisLine.show')) {\n\t                return;\n\t            }\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t\n\t            var matrix = this._transform;\n\t            var pt1 = [extent[0], 0];\n\t            var pt2 = [extent[1], 0];\n\t            if (matrix) {\n\t                v2ApplyTransform(pt1, pt1, matrix);\n\t                v2ApplyTransform(pt2, pt2, matrix);\n\t            }\n\t\n\t            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                // Id for animation\n\t                anid: 'line',\n\t\n\t                shape: {\n\t                    x1: pt1[0],\n\t                    y1: pt1[1],\n\t                    x2: pt2[0],\n\t                    y2: pt2[1]\n\t                },\n\t                style: zrUtil.extend(\n\t                    {lineCap: 'round'},\n\t                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n\t                ),\n\t                strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                silent: true,\n\t                z2: 1\n\t            })));\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisTick: function () {\n\t            var axisModel = this.axisModel;\n\t            var axis = axisModel.axis;\n\t\n\t            if (!axisModel.get('axisTick.show') || axis.isBlank()) {\n\t                return;\n\t            }\n\t\n\t            var tickModel = axisModel.getModel('axisTick');\n\t            var opt = this.opt;\n\t\n\t            var lineStyleModel = tickModel.getModel('lineStyle');\n\t            var tickLen = tickModel.get('length');\n\t\n\t            var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var pt1 = [];\n\t            var pt2 = [];\n\t            var matrix = this._transform;\n\t\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                // Only ordinal scale support tick interval\n\t                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var tickCoord = ticksCoords[i];\n\t\n\t                pt1[0] = tickCoord;\n\t                pt1[1] = 0;\n\t                pt2[0] = tickCoord;\n\t                pt2[1] = opt.tickDirection * tickLen;\n\t\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                // Tick line, Not use group transform to have better line draw\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                    // Id for animation\n\t                    anid: 'tick_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.defaults(\n\t                        lineStyleModel.getLineStyle(),\n\t                        {\n\t                            stroke: axisModel.get('axisLine.lineStyle.color')\n\t                        }\n\t                    ),\n\t                    z2: 2,\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @private\n\t         */\n\t        axisLabel: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var axis = axisModel.axis;\n\t            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t\n\t            if (!show || axis.isBlank()) {\n\t                return;\n\t            }\n\t\n\t            var labelModel = axisModel.getModel('axisLabel');\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t            var labelMargin = labelModel.get('margin');\n\t            var ticks = axis.scale.getTicks();\n\t            var labels = axisModel.getFormattedLabels();\n\t\n\t            // Special label rotate.\n\t            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t            // To radian.\n\t            labelRotation = labelRotation * PI / 180;\n\t\n\t            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t            var categoryData = axisModel.get('data');\n\t\n\t            var textEls = [];\n\t            var silent = isSilent(axisModel);\n\t            var triggerEvent = axisModel.get('triggerEvent');\n\t\n\t            zrUtil.each(ticks, function (tickVal, index) {\n\t                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n\t                     return;\n\t                }\n\t\n\t                var itemTextStyleModel = textStyleModel;\n\t                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n\t                    itemTextStyleModel = new Model(\n\t                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n\t                    );\n\t                }\n\t                var textColor = itemTextStyleModel.getTextColor()\n\t                    || axisModel.get('axisLine.lineStyle.color');\n\t\n\t                var tickCoord = axis.dataToCoord(tickVal);\n\t                var pos = [\n\t                    tickCoord,\n\t                    opt.labelOffset + opt.labelDirection * labelMargin\n\t                ];\n\t                var labelBeforeFormat = axis.scale.getLabel(tickVal);\n\t\n\t                var textEl = new graphic.Text({\n\t\n\t                    // Id for animation\n\t                    anid: 'label_' + tickVal,\n\t\n\t                    style: {\n\t                        text: labels[index],\n\t                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                        textFont: itemTextStyleModel.getFont(),\n\t                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                    },\n\t                    position: pos,\n\t                    rotation: labelLayout.rotation,\n\t                    silent: silent,\n\t                    z2: 10\n\t                });\n\t\n\t                // Pack data for mouse event\n\t                if (triggerEvent) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisLabel';\n\t                    textEl.eventData.value = labelBeforeFormat;\n\t                }\n\t\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t\n\t                textEls.push(textEl);\n\t                this.group.add(textEl);\n\t\n\t                textEl.decomposeTransform();\n\t\n\t            }, this);\n\t\n\t            function isTwoLabelOverlapped(current, next) {\n\t                var firstRect = current && current.getBoundingRect().clone();\n\t                var nextRect = next && next.getBoundingRect().clone();\n\t                if (firstRect && nextRect) {\n\t                    firstRect.applyTransform(current.getLocalTransform());\n\t                    nextRect.applyTransform(next.getLocalTransform());\n\t                    return firstRect.intersect(nextRect);\n\t                }\n\t            }\n\t\n\t            // If min or max are user set, we need to check\n\t            // If the tick on min(max) are overlap on their neighbour tick\n\t            // If they are overlapped, we need to hide the min(max) tick label\n\t            if (axisModel.getMin() != null) {\n\t                var firstLabel = textEls[0];\n\t                var nextLabel = textEls[1];\n\t                if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                    firstLabel.ignore = true;\n\t                }\n\t            }\n\t            if (axisModel.getMax() != null) {\n\t                var lastLabel = textEls[textEls.length - 1];\n\t                var prevLabel = textEls[textEls.length - 2];\n\t                if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                    lastLabel.ignore = true;\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisName: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var name = retrieve(opt.axisName, axisModel.get('name'));\n\t\n\t            if (!name) {\n\t                return;\n\t            }\n\t\n\t            var nameLocation = axisModel.get('nameLocation');\n\t            var nameDirection = opt.nameDirection;\n\t            var textStyleModel = axisModel.getModel('nameTextStyle');\n\t            var gap = axisModel.get('nameGap') || 0;\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t            var pos = [\n\t                nameLocation === 'start'\n\t                    ? extent[0] - gapSignal * gap\n\t                    : nameLocation === 'end'\n\t                    ? extent[1] + gapSignal * gap\n\t                    : (extent[0] + extent[1]) / 2, // 'middle'\n\t                // Reuse labelOffset.\n\t                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t            ];\n\t\n\t            var labelLayout;\n\t\n\t            var nameRotation = axisModel.get('nameRotate');\n\t            if (nameRotation != null) {\n\t                nameRotation = nameRotation * PI / 180; // To radian.\n\t            }\n\t\n\t            var axisNameAvailableWidth;\n\t\n\t            if (nameLocation === 'middle') {\n\t                labelLayout = innerTextLayout(\n\t                    opt,\n\t                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n\t                    nameDirection\n\t                );\n\t            }\n\t            else {\n\t                labelLayout = endTextLayout(\n\t                    opt, nameLocation, nameRotation || 0, extent\n\t                );\n\t\n\t                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                if (axisNameAvailableWidth != null) {\n\t                    axisNameAvailableWidth = Math.abs(\n\t                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n\t                    );\n\t                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                }\n\t            }\n\t\n\t            var textFont = textStyleModel.getFont();\n\t\n\t            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t            var ellipsis = truncateOpt.ellipsis;\n\t            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t            var truncatedText = (ellipsis != null && maxWidth != null)\n\t                ? formatUtil.truncateText(\n\t                    name, maxWidth, textFont, ellipsis,\n\t                    {minChar: 2, placeholder: truncateOpt.placeholder}\n\t                )\n\t                : name;\n\t\n\t            var tooltipOpt = axisModel.get('tooltip', true);\n\t\n\t            var mainType = axisModel.mainType;\n\t            var formatterParams = {\n\t                componentType: mainType,\n\t                name: name,\n\t                $vars: ['name']\n\t            };\n\t            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t\n\t            var textEl = new graphic.Text({\n\t\n\t                // Id for animation\n\t                anid: 'name',\n\t\n\t                __fullText: name,\n\t                __truncatedText: truncatedText,\n\t\n\t                style: {\n\t                    text: truncatedText,\n\t                    textFont: textFont,\n\t                    fill: textStyleModel.getTextColor()\n\t                        || axisModel.get('axisLine.lineStyle.color'),\n\t                    textAlign: labelLayout.textAlign,\n\t                    textVerticalAlign: labelLayout.verticalAlign\n\t                },\n\t                position: pos,\n\t                rotation: labelLayout.rotation,\n\t                silent: isSilent(axisModel),\n\t                z2: 1,\n\t                tooltip: (tooltipOpt && tooltipOpt.show)\n\t                    ? zrUtil.extend({\n\t                        content: name,\n\t                        formatter: function () {\n\t                            return name;\n\t                        },\n\t                        formatterParams: formatterParams\n\t                    }, tooltipOpt)\n\t                    : null\n\t            });\n\t\n\t            if (axisModel.get('triggerEvent')) {\n\t                textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                textEl.eventData.targetType = 'axisName';\n\t                textEl.eventData.name = name;\n\t            }\n\t\n\t            // FIXME\n\t            this._dumbGroup.add(textEl);\n\t            textEl.updateTransform();\n\t\n\t            this.group.add(textEl);\n\t\n\t            textEl.decomposeTransform();\n\t        }\n\t\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t\n\t        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            }\n\t            else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = (textPosition === 'start' && !inverse)\n\t            || (textPosition !== 'start' && inverse);\n\t\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            }\n\t            else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent')\n\t            // Consider mouse cursor, add these restrictions.\n\t            || !(\n\t                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n\t            );\n\t    }\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t        var rawTick;\n\t        var scale = axis.scale;\n\t        return scale.type === 'ordinal'\n\t            && (\n\t                typeof interval === 'function'\n\t                    ? (\n\t                        rawTick = scale.getTicks()[i],\n\t                        !interval(rawTick, scale.getLabel(rawTick))\n\t                    )\n\t                    : i % (interval + 1)\n\t            );\n\t    };\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t        var interval = model.get('interval');\n\t        if (interval == null || interval == 'auto') {\n\t            interval = labelInterval;\n\t        }\n\t        return interval;\n\t    };\n\t\n\t    module.exports = AxisBuilder;\n\t\n\n\n/***/ },\n/* 157 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var graphic = __webpack_require__(3);\n\t    var AxisBuilder = __webpack_require__(156);\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t\n\t    var axisBuilderAttrs = [\n\t        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n\t    ];\n\t    var selfBuilderAttrs = [\n\t        'splitArea', 'splitLine'\n\t    ];\n\t\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t\n\t    var AxisView = __webpack_require__(2).extendComponentView({\n\t\n\t        type: 'axis',\n\t\n\t        render: function (axisModel, ecModel) {\n\t\n\t            this.group.removeAll();\n\t\n\t            var oldAxisGroup = this._axisGroup;\n\t            this._axisGroup = new graphic.Group();\n\t\n\t            this.group.add(this._axisGroup);\n\t\n\t            if (!axisModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var gridModel = axisModel.getCoordSysModel();\n\t\n\t            var layout = layoutAxis(gridModel, axisModel);\n\t\n\t            var axisBuilder = new AxisBuilder(axisModel, layout);\n\t\n\t            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t\n\t            this._axisGroup.add(axisBuilder.getGroup());\n\t\n\t            zrUtil.each(selfBuilderAttrs, function (name) {\n\t                if (axisModel.get(name + '.show')) {\n\t                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                }\n\t            }, this);\n\t\n\t            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitLine: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            if (axis.isBlank()) {\n\t                return;\n\t            }\n\t\n\t            var splitLineModel = axisModel.getModel('splitLine');\n\t            var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t            var lineColors = lineStyleModel.get('color');\n\t\n\t            var lineInterval = getInterval(splitLineModel, labelInterval);\n\t\n\t            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t            var isHorizontal = axis.isHorizontal();\n\t\n\t            var lineCount = 0;\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitLineModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var p1 = [];\n\t            var p2 = [];\n\t            // Simple optimization\n\t            // Batching the lines if color are the same\n\t            var lineStyle = lineStyleModel.getLineStyle();\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                if (isHorizontal) {\n\t                    p1[0] = tickCoord;\n\t                    p1[1] = gridRect.y;\n\t                    p2[0] = tickCoord;\n\t                    p2[1] = gridRect.y + gridRect.height;\n\t                }\n\t                else {\n\t                    p1[0] = gridRect.x;\n\t                    p1[1] = tickCoord;\n\t                    p2[0] = gridRect.x + gridRect.width;\n\t                    p2[1] = tickCoord;\n\t                }\n\t\n\t                var colorIndex = (lineCount++) % lineColors.length;\n\t                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: p1[0],\n\t                        y1: p1[1],\n\t                        x2: p2[0],\n\t                        y2: p2[1]\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        stroke: lineColors[colorIndex]\n\t                    }, lineStyle),\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitArea: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            if (axis.isBlank()) {\n\t                return;\n\t            }\n\t\n\t            var splitAreaModel = axisModel.getModel('splitArea');\n\t            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t            var areaColors = areaStyleModel.get('color');\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitAreaModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t\n\t            var count = 0;\n\t\n\t            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t\n\t            var areaStyle = areaStyleModel.getAreaStyle();\n\t            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t\n\t            for (var i = 1; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t                if (axis.isHorizontal()) {\n\t                    x = prevX;\n\t                    y = gridRect.y;\n\t                    width = tickCoord - x;\n\t                    height = gridRect.height;\n\t                }\n\t                else {\n\t                    x = gridRect.x;\n\t                    y = prevY;\n\t                    width = gridRect.width;\n\t                    height = tickCoord - y;\n\t                }\n\t\n\t                var colorIndex = (count++) % areaColors.length;\n\t                this._axisGroup.add(new graphic.Rect({\n\t                    anid: 'area_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x: x,\n\t                        y: y,\n\t                        width: width,\n\t                        height: height\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        fill: areaColors[colorIndex]\n\t                    }, areaStyle),\n\t                    silent: true\n\t                }));\n\t\n\t                prevX = x + width;\n\t                prevY = y + height;\n\t            }\n\t        }\n\t    });\n\t\n\t    AxisView.extend({\n\t        type: 'xAxis'\n\t    });\n\t    AxisView.extend({\n\t        type: 'yAxis'\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\t\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t\n\t        var posMap = {\n\t            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n\t            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n\t        };\n\t\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\t\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t\n\t        return layout;\n\t    }\n\n\n/***/ },\n/* 158 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    // List layout\n\t    var layout = __webpack_require__(20);\n\t    var formatUtil = __webpack_require__(9);\n\t    var graphic = __webpack_require__(3);\n\t\n\t    function positionGroup(group, model, api) {\n\t        layout.positionElement(\n\t            group, model.getBoxLayoutParams(),\n\t            {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            },\n\t            model.get('padding')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Layout list like component.\n\t         * It will box layout each items in group of component and then position the whole group in the viewport\n\t         * @param {module:zrender/group/Group} group\n\t         * @param {module:echarts/model/Component} componentModel\n\t         * @param {module:echarts/ExtensionAPI}\n\t         */\n\t        layout: function (group, componentModel, api) {\n\t            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            }, componentModel.get('padding'));\n\t            layout.box(\n\t                componentModel.get('orient'),\n\t                group,\n\t                componentModel.get('itemGap'),\n\t                rect.width,\n\t                rect.height\n\t            );\n\t\n\t            positionGroup(group, componentModel, api);\n\t        },\n\t\n\t        addBackground: function (group, componentModel) {\n\t            var padding = formatUtil.normalizeCssArray(\n\t                componentModel.get('padding')\n\t            );\n\t            var boundingRect = group.getBoundingRect();\n\t            var style = componentModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = componentModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: boundingRect.x - padding[3],\n\t                    y: boundingRect.y - padding[0],\n\t                    width: boundingRect.width + padding[1] + padding[3],\n\t                    height: boundingRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true,\n\t                z2: -1\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    };\n\n\n/***/ },\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Data selectable mixin for chart series.\n\t * To eanble data select, option of series must have `selectedMode`.\n\t * And each data item will use `selected` to toggle itself selected status\n\t *\n\t * @module echarts/chart/helper/DataSelectable\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    module.exports = {\n\t\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        // PENGING If selectedMode is null ?\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\n\n/***/ },\n/* 160 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Legend component entry file8\n\t */\n\t\n\t\n\t    __webpack_require__(161);\n\t    __webpack_require__(163);\n\t    __webpack_require__(162);\n\t\n\t    var echarts = __webpack_require__(2);\n\t    // Series Filter\n\t    echarts.registerProcessor(__webpack_require__(164));\n\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Model = __webpack_require__(12);\n\t\n\t    var LegendModel = __webpack_require__(2).extendComponentModel({\n\t\n\t        type: 'legend',\n\t\n\t        dependencies: ['series'],\n\t\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t\n\t        init: function (option, parentModel, ecModel) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            option.selected = option.selected || {};\n\t        },\n\t\n\t        mergeOption: function (option) {\n\t            LegendModel.superCall(this, 'mergeOption', option);\n\t        },\n\t\n\t        optionUpdated: function () {\n\t            this._updateData(this.ecModel);\n\t\n\t            var legendData = this._data;\n\t\n\t            // If selectedMode is single, try to select one\n\t            if (legendData[0] && this.get('selectedMode') === 'single') {\n\t                var hasSelected = false;\n\t                // If has any selected in option.selected\n\t                for (var i = 0; i < legendData.length; i++) {\n\t                    var name = legendData[i].get('name');\n\t                    if (this.isSelected(name)) {\n\t                        // Force to unselect others\n\t                        this.select(name);\n\t                        hasSelected = true;\n\t                        break;\n\t                    }\n\t                }\n\t                // Try select the first if selectedMode is single\n\t                !hasSelected && this.select(legendData[0].get('name'));\n\t            }\n\t        },\n\t\n\t        _updateData: function (ecModel) {\n\t            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n\t                // Can be string or number\n\t                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n\t                    dataItem = {\n\t                        name: dataItem\n\t                    };\n\t                }\n\t                return new Model(dataItem, this, this.ecModel);\n\t            }, this);\n\t            this._data = legendData;\n\t\n\t            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n\t                return series.name;\n\t            });\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (seriesModel.legendDataProvider) {\n\t                    var data = seriesModel.legendDataProvider();\n\t                    availableNames = availableNames.concat(data.mapArray(data.getName));\n\t                }\n\t            });\n\t            /**\n\t             * @type {Array.<string>}\n\t             * @private\n\t             */\n\t            this._availableNames = availableNames;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Model>}\n\t         */\n\t        getData: function () {\n\t            return this._data;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        select: function (name) {\n\t            var selected = this.option.selected;\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                var data = this._data;\n\t                zrUtil.each(data, function (dataItem) {\n\t                    selected[dataItem.get('name')] = false;\n\t                });\n\t            }\n\t            selected[name] = true;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            if (this.get('selectedMode') !== 'single') {\n\t                this.option.selected[name] = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            // Default is true\n\t            if (!selected.hasOwnProperty(name)) {\n\t                selected[name] = true;\n\t            }\n\t            this[selected[name] ? 'unSelect' : 'select'](name);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            return !(selected.hasOwnProperty(name) && !selected[name])\n\t                && zrUtil.indexOf(this._availableNames, name) >= 0;\n\t        },\n\t\n\t        defaultOption: {\n\t            // \n\t            zlevel: 0,\n\t            // \n\t            z: 4,\n\t            show: true,\n\t\n\t            // \n\t            // 'horizontal' | 'vertical'\n\t            orient: 'horizontal',\n\t\n\t            left: 'center',\n\t            // right: 'center',\n\t\n\t            top: 'top',\n\t            // bottom: 'top',\n\t\n\t            // \n\t            // 'auto' | 'left' | 'right'\n\t            //  'auto',  x \n\t            align: 'auto',\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            // \n\t            borderColor: '#ccc',\n\t            // px0\n\t            borderWidth: 0,\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t            // itempx10\n\t            // \n\t            itemGap: 10,\n\t            // \n\t            itemWidth: 25,\n\t            // \n\t            itemHeight: 14,\n\t\n\t            // \n\t            inactiveColor: '#ccc',\n\t\n\t            textStyle: {\n\t                // \n\t                color: '#333'\n\t            },\n\t            // formatter: '',\n\t            // \n\t            selectedMode: true,\n\t            // LEGEND.SELECTED\n\t            // selected: null,\n\t            // legend.dataitem\n\t            // data: [],\n\t\n\t            // Tooltip \n\t            tooltip: {\n\t                show: false\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = LegendModel;\n\n\n/***/ },\n/* 162 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var symbolCreator = __webpack_require__(196);\n\t    var graphic = __webpack_require__(3);\n\t    var listComponentHelper = __webpack_require__(158);\n\t\n\t    var curry = zrUtil.curry;\n\t\n\t    function dispatchSelectAction(name, api) {\n\t        api.dispatchAction({\n\t            type: 'legendToggleSelect',\n\t            name: name\n\t        });\n\t    }\n\t\n\t    function dispatchHighlightAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'highlight',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    function dispatchDownplayAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'downplay',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = __webpack_require__(2).extendComponentView({\n\t\n\t        type: 'legend',\n\t\n\t        init: function () {\n\t            this._symbolTypeStore = {};\n\t        },\n\t\n\t        render: function (legendModel, ecModel, api) {\n\t            var group = this.group;\n\t            group.removeAll();\n\t\n\t            if (!legendModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var selectMode = legendModel.get('selectedMode');\n\t            var itemAlign = legendModel.get('align');\n\t\n\t            if (itemAlign === 'auto') {\n\t                itemAlign = (legendModel.get('left') === 'right'\n\t                    && legendModel.get('orient') === 'vertical')\n\t                    ? 'right' : 'left';\n\t            }\n\t\n\t            var legendDrawedMap = {};\n\t\n\t            zrUtil.each(legendModel.getData(), function (itemModel) {\n\t                var name = itemModel.get('name');\n\t\n\t                // Use empty string or \\n as a newline string\n\t                if (name === '' || name === '\\n') {\n\t                    group.add(new graphic.Group({\n\t                        newline: true\n\t                    }));\n\t                    return;\n\t                }\n\t\n\t                var seriesModel = ecModel.getSeriesByName(name)[0];\n\t\n\t                if (legendDrawedMap[name]) {\n\t                    // Have been drawed\n\t                    return;\n\t                }\n\t\n\t                // Series legend\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var color = data.getVisual('color');\n\t\n\t                    // If color is a callback function\n\t                    if (typeof color === 'function') {\n\t                        // Use the first data\n\t                        color = color(seriesModel.getDataParams(0));\n\t                    }\n\t\n\t                    // Using rect symbol defaultly\n\t                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n\t                    var symbolType = data.getVisual('symbol');\n\t\n\t                    var itemGroup = this._createItem(\n\t                        name, itemModel, legendModel,\n\t                        legendSymbolType, symbolType,\n\t                        itemAlign, color,\n\t                        selectMode\n\t                    );\n\t\n\t                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n\t                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\t\n\t                    legendDrawedMap[name] = true;\n\t                }\n\t                else {\n\t                    // Data legend of pie, funnel\n\t                    ecModel.eachRawSeries(function (seriesModel) {\n\t                        // In case multiple series has same data name\n\t                        if (legendDrawedMap[name]) {\n\t                            return;\n\t                        }\n\t                        if (seriesModel.legendDataProvider) {\n\t                            var data = seriesModel.legendDataProvider();\n\t                            var idx = data.indexOfName(name);\n\t                            if (idx < 0) {\n\t                                return;\n\t                            }\n\t\n\t                            var color = data.getItemVisual(idx, 'color');\n\t\n\t                            var legendSymbolType = 'roundRect';\n\t\n\t                            var itemGroup = this._createItem(\n\t                                name, itemModel, legendModel,\n\t                                legendSymbolType, null,\n\t                                itemAlign, color,\n\t                                selectMode\n\t                            );\n\t\n\t                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                                // FIXME Should not specify the series name\n\t                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n\t                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\t\n\t                            legendDrawedMap[name] = true;\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                if (__DEV__) {\n\t                    if (!legendDrawedMap[name]) {\n\t                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            listComponentHelper.layout(group, legendModel, api);\n\t            // Render background after group is layout\n\t            // FIXME\n\t            listComponentHelper.addBackground(group, legendModel);\n\t        },\n\t\n\t        _createItem: function (\n\t            name, itemModel, legendModel,\n\t            legendSymbolType, symbolType,\n\t            itemAlign, color, selectMode\n\t        ) {\n\t            var itemWidth = legendModel.get('itemWidth');\n\t            var itemHeight = legendModel.get('itemHeight');\n\t            var inactiveColor = legendModel.get('inactiveColor');\n\t\n\t            var isSelected = legendModel.isSelected(name);\n\t            var itemGroup = new graphic.Group();\n\t\n\t            var textStyleModel = itemModel.getModel('textStyle');\n\t\n\t            var itemIcon = itemModel.get('icon');\n\t\n\t            var tooltipModel = itemModel.getModel('tooltip');\n\t            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\t\n\t            // Use user given icon first\n\t            legendSymbolType = itemIcon || legendSymbolType;\n\t            itemGroup.add(symbolCreator.createSymbol(\n\t                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n\t            ));\n\t\n\t            // Compose symbols\n\t            // PENDING\n\t            if (!itemIcon && symbolType\n\t                // At least show one symbol, can't be all none\n\t                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n\t            ) {\n\t                var size = itemHeight * 0.8;\n\t                if (symbolType === 'none') {\n\t                    symbolType = 'circle';\n\t                }\n\t                // Put symbol in the center\n\t                itemGroup.add(symbolCreator.createSymbol(\n\t                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n\t                    isSelected ? color : inactiveColor\n\t                ));\n\t            }\n\t\n\t            // Text\n\t            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n\t            var textAlign = itemAlign;\n\t\n\t            var formatter = legendModel.get('formatter');\n\t            var content = name;\n\t            if (typeof formatter === 'string' && formatter) {\n\t                content = formatter.replace('{name}', name != null ? name : '');\n\t            }\n\t            else if (typeof formatter === 'function') {\n\t                content = formatter(name);\n\t            }\n\t\n\t            var text = new graphic.Text({\n\t                style: {\n\t                    text: content,\n\t                    x: textX,\n\t                    y: itemHeight / 2,\n\t                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n\t                    textFont: textStyleModel.getFont(),\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: 'middle'\n\t                }\n\t            });\n\t            itemGroup.add(text);\n\t\n\t            // Add a invisible rect to increase the area of mouse hover\n\t            var hitRect = new graphic.Rect({\n\t                shape: itemGroup.getBoundingRect(),\n\t                invisible: true,\n\t                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n\t                    content: name,\n\t                    // Defaul formatter\n\t                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n\t                        return name;\n\t                    },\n\t                    formatterParams: {\n\t                        componentType: 'legend',\n\t                        legendIndex: legendModel.componentIndex,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    }\n\t                }, tooltipModel.option) : null\n\t            });\n\t            itemGroup.add(hitRect);\n\t\n\t            itemGroup.eachChild(function (child) {\n\t                child.silent = true;\n\t            });\n\t\n\t            hitRect.silent = !selectMode;\n\t\n\t\n\t\n\t            this.group.add(itemGroup);\n\t\n\t            graphic.setHoverStyle(itemGroup);\n\t\n\t            return itemGroup;\n\t        }\n\t    });\n\n\n/***/ },\n/* 163 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Legend action\n\t */\n\t\n\t\n\t    var echarts = __webpack_require__(2);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function legendSelectActionHandler(methodName, payload, ecModel) {\n\t        var selectedMap = {};\n\t        var isToggleSelect = methodName === 'toggleSelected';\n\t        var isSelected;\n\t        // Update all legend components\n\t        ecModel.eachComponent('legend', function (legendModel) {\n\t            if (isToggleSelect && isSelected != null) {\n\t                // Force other legend has same selected status\n\t                // Or the first is toggled to true and other are toggled to false\n\t                // In the case one legend has some item unSelected in option. And if other legend\n\t                // doesn't has the item, they will assume it is selected.\n\t                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n\t            }\n\t            else {\n\t                legendModel[methodName](payload.name);\n\t                isSelected = legendModel.isSelected(payload.name);\n\t            }\n\t            var legendData = legendModel.getData();\n\t            zrUtil.each(legendData, function (model) {\n\t                var name = model.get('name');\n\t                // Wrap element\n\t                if (name === '\\n' || name === '') {\n\t                    return;\n\t                }\n\t                var isItemSelected = legendModel.isSelected(name);\n\t                if (name in selectedMap) {\n\t                    // Unselected if any legend is unselected\n\t                    selectedMap[name] = selectedMap[name] && isItemSelected;\n\t                }\n\t                else {\n\t                    selectedMap[name] = isItemSelected;\n\t                }\n\t            });\n\t        });\n\t        // Return the event explicitly\n\t        return {\n\t            name: payload.name,\n\t            selected: selectedMap\n\t        };\n\t    }\n\t    /**\n\t     * @event legendToggleSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendToggleSelect'\n\t     * @property {string} [from]\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendToggleSelect', 'legendselectchanged',\n\t        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n\t    );\n\t\n\t    /**\n\t     * @event legendSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendSelect', 'legendselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'select')\n\t    );\n\t\n\t    /**\n\t     * @event legendUnSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendUnSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendUnSelect', 'legendunselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n\t    );\n\n\n/***/ },\n/* 164 */\n/***/ function(module, exports) {\n\n\t\n\t   module.exports = function (ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (legendModels && legendModels.length) {\n\t            ecModel.filterSeries(function (series) {\n\t                // If in any legend component the status is not selected.\n\t                // Because in legend series is assumed selected when it is not in the legend data.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(series.name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    };\n\n\n/***/ },\n/* 165 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var echarts = __webpack_require__(2);\n\t    var graphic = __webpack_require__(3);\n\t    var layout = __webpack_require__(20);\n\t\n\t    // Model\n\t    echarts.extendComponentModel({\n\t\n\t        type: 'title',\n\t\n\t        layoutMode: {type: 'box', ignoreSize: true},\n\t\n\t        defaultOption: {\n\t            // \n\t            zlevel: 0,\n\t            // \n\t            z: 6,\n\t            show: true,\n\t\n\t            text: '',\n\t            // \n\t            // link: null,\n\t            // self | blank\n\t            target: 'blank',\n\t            subtext: '',\n\t\n\t            // \n\t            // sublink: null,\n\t            // self | blank\n\t            subtarget: 'blank',\n\t\n\t            // 'center'  'left'  'right'\n\t            //  {number}xpx\n\t            left: 0,\n\t            // 'top'  'bottom'  'center'\n\t            //  {number}ypx\n\t            top: 0,\n\t\n\t            // \n\t            // 'auto' | 'left' | 'right' | 'center'\n\t            //  left \n\t            // textAlign: null\n\t            //\n\t            // \n\t            // 'auto' | 'top' | 'bottom' | 'middle'\n\t            //  top \n\t            // textBaseline: null\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t            // \n\t            borderColor: '#ccc',\n\t\n\t            // px0\n\t            borderWidth: 0,\n\t\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t\n\t            // px10\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: {\n\t                color: '#aaa'\n\t            }\n\t        }\n\t    });\n\t\n\t    // View\n\t    echarts.extendComponentView({\n\t\n\t        type: 'title',\n\t\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var group = this.group;\n\t\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t\n\t            var textEl = new graphic.Text({\n\t                style: {\n\t                    text: titleModel.get('text'),\n\t                    textFont: textStyleModel.getFont(),\n\t                    fill: textStyleModel.getTextColor()\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var textRect = textEl.getBoundingRect();\n\t\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                style: {\n\t                    text: subText,\n\t                    textFont: subtextStyleModel.getFont(),\n\t                    fill: subtextStyleModel.getTextColor(),\n\t                    y: textRect.height + titleModel.get('itemGap'),\n\t                    textBaseline: 'top'\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(\n\t                layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding')\n\t            );\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                }\n\t                else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                }\n\t                else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t\n\t            group.attr('position', [layoutRect.x, layoutRect.y]);\n\t            var alignStyle = {\n\t                textAlign: textAlign,\n\t                textVerticalAlign: textBaseline\n\t            };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: groupRect.x - padding[3],\n\t                    y: groupRect.y - padding[0],\n\t                    width: groupRect.width + padding[1] + padding[3],\n\t                    height: groupRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    });\n\n\n/***/ },\n/* 166 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// FIXME Better way to pack data in graphic element\n\t\n\t\n\t    __webpack_require__(168);\n\t\n\t    __webpack_require__(169);\n\t\n\t    // Show tip action\n\t    /**\n\t     * @action\n\t     * @property {string} type\n\t     * @property {number} seriesIndex\n\t     * @property {number} dataIndex\n\t     * @property {number} [x]\n\t     * @property {number} [y]\n\t     */\n\t    __webpack_require__(2).registerAction(\n\t        {\n\t            type: 'showTip',\n\t            event: 'showTip',\n\t            update: 'tooltip:manuallyShowTip'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\t    // Hide tip action\n\t    __webpack_require__(2).registerAction(\n\t        {\n\t            type: 'hideTip',\n\t            event: 'hideTip',\n\t            update: 'tooltip:manuallyHideTip'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\n\n/***/ },\n/* 167 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/tooltip/TooltipContent\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var zrColor = __webpack_require__(29);\n\t    var eventUtil = __webpack_require__(39);\n\t    var formatUtil = __webpack_require__(9);\n\t    var each = zrUtil.each;\n\t    var toCamelCase = formatUtil.toCamelCase;\n\t    var env = __webpack_require__(10);\n\t\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\t\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\t\n\t    /**\n\t     * @param {number} duration\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleTransition(duration) {\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n\t                            + 'top ' + duration + 's ' + transitionCurve;\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\n\t            return vendorPrefix + 'transition:' + transitionText;\n\t        }).join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} textStyle\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleFont(textStyleModel) {\n\t        var cssText = [];\n\t\n\t        var fontSize = textStyleModel.get('fontSize');\n\t        var color = textStyleModel.getTextColor();\n\t\n\t        color && cssText.push('color:' + color);\n\t\n\t        cssText.push('font:' + textStyleModel.getFont());\n\t\n\t        fontSize &&\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\t\n\t        each(['decoration', 'align'], function (name) {\n\t            var val = textStyleModel.get(name);\n\t            val && cssText.push('text-' + name + ':' + val);\n\t        });\n\t\n\t        return cssText.join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} tooltipModel\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleCssText(tooltipModel) {\n\t\n\t        tooltipModel = tooltipModel;\n\t\n\t        var cssText = [];\n\t\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\n\t        var padding = tooltipModel.get('padding');\n\t\n\t        // Animation transition\n\t        transitionDuration &&\n\t            cssText.push(assembleTransition(transitionDuration));\n\t\n\t        if (backgroundColor) {\n\t            if (env.canvasSupported) {\n\t                cssText.push('background-Color:' + backgroundColor);\n\t            }\n\t            else {\n\t                // for ie\n\t                cssText.push(\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\n\t                );\n\t                cssText.push('filter:alpha(opacity=70)');\n\t            }\n\t        }\n\t\n\t        // Border style\n\t        each(['width', 'color', 'radius'], function (name) {\n\t            var borderName = 'border-' + name;\n\t            var camelCase = toCamelCase(borderName);\n\t            var val = tooltipModel.get(camelCase);\n\t            val != null &&\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n\t        });\n\t\n\t        // Text style\n\t        cssText.push(assembleFont(textStyleModel));\n\t\n\t        // Padding\n\t        if (padding != null) {\n\t            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n\t        }\n\t\n\t        return cssText.join(';') + ';';\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/component/tooltip/TooltipContent\n\t     * @constructor\n\t     */\n\t    function TooltipContent(container, api) {\n\t        var el = document.createElement('div');\n\t        var zr = api.getZr();\n\t\n\t        this.el = el;\n\t\n\t        this._x = api.getWidth() / 2;\n\t        this._y = api.getHeight() / 2;\n\t\n\t        container.appendChild(el);\n\t\n\t        this._container = container;\n\t\n\t        this._show = false;\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        this._hideTimeout;\n\t\n\t        var self = this;\n\t        el.onmouseenter = function () {\n\t            // clear the timeout in hideLater and keep showing tooltip\n\t            if (self.enterable) {\n\t                clearTimeout(self._hideTimeout);\n\t                self._show = true;\n\t            }\n\t            self._inContent = true;\n\t        };\n\t        el.onmousemove = function (e) {\n\t            e = e || window.event;\n\t            if (!self.enterable) {\n\t                // Try trigger zrender event to avoid mouse\n\t                // in and out shape too frequently\n\t                var handler = zr.handler;\n\t                eventUtil.normalizeEvent(container, e, true);\n\t                handler.dispatch('mousemove', e);\n\t            }\n\t        };\n\t        el.onmouseleave = function () {\n\t            if (self.enterable) {\n\t                if (self._show) {\n\t                    self.hideLater(self._hideDelay);\n\t                }\n\t            }\n\t            self._inContent = false;\n\t        };\n\t    }\n\t\n\t    TooltipContent.prototype = {\n\t\n\t        constructor: TooltipContent,\n\t\n\t        enterable: true,\n\t\n\t        /**\n\t         * Update when tooltip is rendered\n\t         */\n\t        update: function () {\n\t            var container = this._container;\n\t            var stl = container.currentStyle\n\t                || document.defaultView.getComputedStyle(container);\n\t            var domStyle = container.style;\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n\t                domStyle.position = 'relative';\n\t            }\n\t            // Hide the tooltip\n\t            // PENDING\n\t            // this.hide();\n\t        },\n\t\n\t        show: function (tooltipModel) {\n\t            clearTimeout(this._hideTimeout);\n\t            var el = this.el;\n\t\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n\t                + (tooltipModel.get('extraCssText') || '');\n\t\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\n\t\n\t            this._show = true;\n\t        },\n\t\n\t        setContent: function (content) {\n\t            var el = this.el;\n\t            el.innerHTML = content;\n\t            el.style.display = content ? 'block' : 'none';\n\t        },\n\t\n\t        moveTo: function (x, y) {\n\t            var style = this.el.style;\n\t            style.left = x + 'px';\n\t            style.top = y + 'px';\n\t\n\t            this._x = x;\n\t            this._y = y;\n\t        },\n\t\n\t        hide: function () {\n\t            this.el.style.display = 'none';\n\t            this._show = false;\n\t        },\n\t\n\t        // showLater: function ()\n\t\n\t        hideLater: function (time) {\n\t            if (this._show && !(this._inContent && this.enterable)) {\n\t                if (time) {\n\t                    this._hideDelay = time;\n\t                    // Set show false to avoid invoke hideLater mutiple times\n\t                    this._show = false;\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n\t                }\n\t                else {\n\t                    this.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        isShow: function () {\n\t            return this._show;\n\t        }\n\t    };\n\t\n\t    module.exports = TooltipContent;\n\n\n/***/ },\n/* 168 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(2).extendComponentModel({\n\t\n\t        type: 'tooltip',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t\n\t            z: 8,\n\t\n\t            show: true,\n\t\n\t            // tooltip\n\t            showContent: true,\n\t\n\t            // 'item'  'axis'\n\t            trigger: 'item',\n\t\n\t            //  'click' | 'mousemove' | 'none'\n\t            triggerOn: 'mousemove',\n\t\n\t            //  content\n\t            alwaysShowContent: false,\n\t\n\t            //  {Array} | {Function}\n\t            // position: null\n\t\n\t            //  content  viewRect  false \n\t            confine: false,\n\t\n\t            // {string}Template  {Function}\n\t            // formatter: null\n\t\n\t            showDelay: 0,\n\t\n\t            // ms\n\t            hideDelay: 100,\n\t\n\t            // s\n\t            transitionDuration: 0.4,\n\t\n\t            enterable: false,\n\t\n\t            // 0.7\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\n\t\n\t            // \n\t            borderColor: '#333',\n\t\n\t            // px4\n\t            borderRadius: 4,\n\t\n\t            // px0\n\t            borderWidth: 0,\n\t\n\t            // px5\n\t            // css\n\t            padding: 5,\n\t\n\t            // Extra css text\n\t            extraCssText: '',\n\t\n\t            // \n\t            axisPointer: {\n\t                // \n\t                // 'line' | 'shadow' | 'cross'\n\t                type: 'line',\n\t\n\t                // type  line  tooltip line \n\t                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n\t                //  'auto' cateogry  x \n\t                //  angle \n\t                axis: 'auto',\n\t\n\t                animation: true,\n\t                animationDurationUpdate: 200,\n\t                animationEasingUpdate: 'exponentialOut',\n\t\n\t                // \n\t                lineStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                },\n\t\n\t                crossStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'dashed',\n\t\n\t                    // TODO formatter\n\t                    textStyle: {}\n\t                },\n\t\n\t                // \n\t                shadowStyle: {\n\t                    color: 'rgba(150,150,150,0.3)'\n\t                }\n\t            },\n\t            textStyle: {\n\t                color: '#fff',\n\t                fontSize: 14\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n/* 169 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var TooltipContent = __webpack_require__(167);\n\t    var graphic = __webpack_require__(3);\n\t    var zrUtil = __webpack_require__(1);\n\t    var formatUtil = __webpack_require__(9);\n\t    var numberUtil = __webpack_require__(4);\n\t    var modelUtil = __webpack_require__(13);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var env = __webpack_require__(10);\n\t    var Model = __webpack_require__(12);\n\t\n\t    function dataEqual(a, b) {\n\t        if (!a || !b) {\n\t            return false;\n\t        }\n\t        var round = numberUtil.round;\n\t        return round(a[0]) === round(b[0])\n\t            && round(a[1]) === round(b[1]);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeLineShape(x1, y1, x2, y2) {\n\t        return {\n\t            x1: x1,\n\t            y1: y1,\n\t            x2: x2,\n\t            y2: y2\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeRectShape(x, y, width, height) {\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n\t        return {\n\t            cx: cx,\n\t            cy: cy,\n\t            r0: r0,\n\t            r: r,\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            clockwise: true\n\t        };\n\t    }\n\t\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t        var gap = 20;\n\t\n\t        if (x + width + gap > viewWidth) {\n\t            x -= width + gap;\n\t        }\n\t        else {\n\t            x += gap;\n\t        }\n\t        if (y + height + gap > viewHeight) {\n\t            y -= height + gap;\n\t        }\n\t        else {\n\t            y += gap;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t\n\t        x = Math.min(x + width, viewWidth) - width;\n\t        y = Math.min(y + height, viewHeight) - height;\n\t        x = Math.max(x, 0);\n\t        y = Math.max(y, 0);\n\t\n\t        return [x, y];\n\t    }\n\t\n\t    function calcTooltipPosition(position, rect, dom) {\n\t        var domWidth = dom.clientWidth;\n\t        var domHeight = dom.clientHeight;\n\t        var gap = 5;\n\t        var x = 0;\n\t        var y = 0;\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t        switch (position) {\n\t            case 'inside':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'top':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y - domHeight - gap;\n\t                break;\n\t            case 'bottom':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight + gap;\n\t                break;\n\t            case 'left':\n\t                x = rect.x - domWidth - gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'right':\n\t                x = rect.x + rectWidth + gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    /**\n\t     * @param  {string|Function|Array.<number>} positionExpr\n\t     * @param  {number} x Mouse x\n\t     * @param  {number} y Mouse y\n\t     * @param  {boolean} confine Whether confine tooltip content in view rect.\n\t     * @param  {module:echarts/component/tooltip/TooltipContent} content\n\t     * @param  {Object|<Array.<Object>} params\n\t     * @param  {module:zrender/Element} el target element\n\t     * @param  {module:echarts/ExtensionAPI} api\n\t     * @return {Array.<number>}\n\t     */\n\t    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n\t        var viewWidth = api.getWidth();\n\t        var viewHeight = api.getHeight();\n\t\n\t        var rect = el && el.getBoundingRect().clone();\n\t        el && rect.applyTransform(el.transform);\n\t        if (typeof positionExpr === 'function') {\n\t            // Callback of position can be an array or a string specify the position\n\t            positionExpr = positionExpr([x, y], params, content.el, rect);\n\t        }\n\t\n\t        if (zrUtil.isArray(positionExpr)) {\n\t            x = parsePercent(positionExpr[0], viewWidth);\n\t            y = parsePercent(positionExpr[1], viewHeight);\n\t        }\n\t        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n\t        else if (typeof positionExpr === 'string' && el) {\n\t            var pos = calcTooltipPosition(\n\t                positionExpr, rect, content.el\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t        else {\n\t            var pos = refixTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        if (confine) {\n\t            var pos = confineTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        content.moveTo(x, y);\n\t    }\n\t\n\t    function ifSeriesSupportAxisTrigger(seriesModel) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var trigger = seriesModel.get('tooltip.trigger', true);\n\t        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n\t        return !(!coordSys\n\t            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n\t            || trigger === 'item');\n\t    }\n\t\n\t    __webpack_require__(2).extendComponentView({\n\t\n\t        type: 'tooltip',\n\t\n\t        _axisPointers: {},\n\t\n\t        init: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var tooltipContent = new TooltipContent(api.getDom(), api);\n\t            this._tooltipContent = tooltipContent;\n\t        },\n\t\n\t        render: function (tooltipModel, ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t\n\t            // Reset\n\t            this.group.removeAll();\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._axisPointers = {};\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/component/tooltip/TooltipModel}\n\t             */\n\t            this._tooltipModel = tooltipModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/model/Global}\n\t             */\n\t            this._ecModel = ecModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/ExtensionAPI}\n\t             */\n\t            this._api = api;\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._lastHover = {\n\t                // data\n\t                // payloadBatch\n\t            };\n\t\n\t            var tooltipContent = this._tooltipContent;\n\t            tooltipContent.update();\n\t            tooltipContent.enterable = tooltipModel.get('enterable');\n\t            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\t\n\t            /**\n\t             * @type {Object.<string, Array>}\n\t             */\n\t            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n\t                tooltipModel, ecModel\n\t            );\n\t\n\t            var crossText = this._crossText;\n\t            if (crossText) {\n\t                this.group.add(crossText);\n\t            }\n\t\n\t            var triggerOn = tooltipModel.get('triggerOn');\n\t\n\t            // Try to keep the tooltip show when refreshing\n\t            if (this._lastX != null\n\t                && this._lastY != null\n\t                // When user is willing to control tooltip totally using API,\n\t                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n\t                // which is not expected.\n\t                && triggerOn !== 'none'\n\t            ) {\n\t                var self = this;\n\t                clearTimeout(this._refreshUpdateTimeout);\n\t                this._refreshUpdateTimeout = setTimeout(function () {\n\t                    // Show tip next tick after other charts are rendered\n\t                    // In case highlight action has wrong result\n\t                    // FIXME\n\t                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n\t                        x: self._lastX,\n\t                        y: self._lastY\n\t                    });\n\t                });\n\t            }\n\t\n\t            var zr = this._api.getZr();\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            if (triggerOn === 'click') {\n\t                zr.on('click', this._tryShow, this);\n\t            }\n\t            else if (triggerOn === 'mousemove') {\n\t                zr.on('mousemove', this._mousemove, this);\n\t                zr.on('mouseout', this._hide, this);\n\t                zr.on('globalout', this._hide, this);\n\t            }\n\t            // else triggerOn is 'none', which enable user\n\t            // to control tooltip totally using API.\n\t        },\n\t\n\t        _mousemove: function (e) {\n\t            var showDelay = this._tooltipModel.get('showDelay');\n\t            var self = this;\n\t            clearTimeout(this._showTimeout);\n\t            if (showDelay > 0) {\n\t                this._showTimeout = setTimeout(function () {\n\t                    self._tryShow(e);\n\t                }, showDelay);\n\t            }\n\t            else {\n\t                this._tryShow(e);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tip manually by\n\t         * dispatchAction({\n\t         *     type: 'showTip',\n\t         *     x: 10,\n\t         *     y: 10\n\t         * });\n\t         * Or\n\t         * dispatchAction({\n\t         *      type: 'showTip',\n\t         *      seriesIndex: 0,\n\t         *      dataIndex or dataIndexInside or name\n\t         * });\n\t         *\n\t         *  TODO Batch\n\t         */\n\t        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n\t            // From self\n\t            if (payload.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            var ecModel = this._ecModel;\n\t            var seriesIndex = payload.seriesIndex;\n\t            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\t            var api = this._api;\n\t\n\t            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n\t            function seriesHaveDataOnIndex(_series) {\n\t                var data = _series.getData();\n\t                var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t                // Have single dataIndex\n\t                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n\t                    && data.hasValue(dataIndex)\n\t                ) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            if (payload.x == null || payload.y == null) {\n\t                if (isTriggerAxis) {\n\t                    // Find another series.\n\t                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n\t                        seriesModel = null;\n\t                    }\n\t                    if (!seriesModel) {\n\t                        // Find the first series can use axis trigger And data is not null\n\t                        ecModel.eachSeries(function (_series) {\n\t                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n\t                                if (seriesHaveDataOnIndex(_series)) {\n\t                                    seriesModel = _series;\n\t                                }\n\t                            }\n\t                        });\n\t                    }\n\t                }\n\t                else {\n\t                    // Use the first series by default.\n\t                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n\t                }\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var el = data.getItemGraphicEl(dataIndex);\n\t                    var cx;\n\t                    var cy;\n\t                    // Try to get the point in coordinate system\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    if (seriesModel.getTooltipPosition) {\n\t                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n\t                        cx = point[0];\n\t                        cy = point[1];\n\t                    }\n\t                    else if (coordSys && coordSys.dataToPoint) {\n\t                        var point = coordSys.dataToPoint(\n\t                            data.getValues(\n\t                                zrUtil.map(coordSys.dimensions, function (dim) {\n\t                                    return seriesModel.coordDimToDataDim(dim)[0];\n\t                                }), dataIndex, true\n\t                            )\n\t                        );\n\t                        cx = point && point[0];\n\t                        cy = point && point[1];\n\t                    }\n\t                    else if (el) {\n\t                        // Use graphic bounding rect\n\t                        var rect = el.getBoundingRect().clone();\n\t                        rect.applyTransform(el.transform);\n\t                        cx = rect.x + rect.width / 2;\n\t                        cy = rect.y + rect.height / 2;\n\t                    }\n\t\n\t                    if (cx != null && cy != null) {\n\t                        this._tryShow({\n\t                            offsetX: cx,\n\t                            offsetY: cy,\n\t                            position: payload.position,\n\t                            target: el,\n\t                            event: {}\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                var el = api.getZr().handler.findHover(payload.x, payload.y);\n\t                this._tryShow({\n\t                    offsetX: payload.x,\n\t                    offsetY: payload.y,\n\t                    position: payload.position,\n\t                    target: el,\n\t                    event: {}\n\t                });\n\t            }\n\t        },\n\t\n\t        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n\t            if (payload.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            this._hide();\n\t        },\n\t\n\t        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n\t            // Prepare data for axis trigger\n\t            var seriesGroupByAxis = {};\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    var baseAxis;\n\t                    var key;\n\t\n\t                    // Only cartesian2d, polar and single support axis trigger\n\t                    if (coordSys.type === 'cartesian2d') {\n\t                        // FIXME `axisPointer.axis` is not baseAxis\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + baseAxis.index;\n\t                    }\n\t                    else if (coordSys.type === 'singleAxis') {\n\t                        baseAxis = coordSys.getAxis();\n\t                        key = baseAxis.dim + baseAxis.type;\n\t                    }\n\t                    else {\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + coordSys.name;\n\t                    }\n\t\n\t                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n\t                        coordSys: [],\n\t                        series: []\n\t                    };\n\t                    seriesGroupByAxis[key].coordSys.push(coordSys);\n\t                    seriesGroupByAxis[key].series.push(seriesModel);\n\t                }\n\t            }, this);\n\t\n\t            return seriesGroupByAxis;\n\t        },\n\t\n\t        /**\n\t         * mousemove handler\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _tryShow: function (e) {\n\t            var el = e.target;\n\t            var tooltipModel = this._tooltipModel;\n\t            var globalTrigger = tooltipModel.get('trigger');\n\t            var ecModel = this._ecModel;\n\t            var api = this._api;\n\t\n\t            if (!tooltipModel) {\n\t                return;\n\t            }\n\t\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\t            this._lastX = e.offsetX;\n\t            this._lastY = e.offsetY;\n\t\n\t            // Always show item tooltip if mouse is on the element with dataIndex\n\t            if (el && el.dataIndex != null) {\n\t                // Use dataModel in element if possible\n\t                // Used when mouseover on a element like markPoint or edge\n\t                // In which case, the data is not main data in series.\n\t                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                var dataIndex = el.dataIndex;\n\t                var data = dataModel.getData();\n\t                var itemModel = data.getItemModel(dataIndex);\n\t                // Series or single data may use item trigger when global is axis trigger\n\t                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t                else {\n\t                    // Reset ticket\n\t                    this._ticket = '';\n\t                    // If either single data or series use item trigger\n\t                    this._hideAxisPointer();\n\t                    // Reset last hover and dispatch downplay action\n\t                    this._resetLastHover();\n\t\n\t                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n\t                }\n\t\n\t                api.dispatchAction({\n\t                    type: 'showTip',\n\t                    from: this.uid,\n\t                    dataIndexInside: dataIndex,\n\t                    dataIndex: data.getRawIndex(dataIndex), // expose to user.\n\t                    seriesIndex: el.seriesIndex\n\t                });\n\t            }\n\t            // Tooltip provided directly. Like legend\n\t            else if (el && el.tooltip) {\n\t                var tooltipOpt = el.tooltip;\n\t                if (typeof tooltipOpt === 'string') {\n\t                    var content = tooltipOpt;\n\t                    tooltipOpt = {\n\t                        content: content,\n\t                        // Fixed formatter\n\t                        formatter: content\n\t                    };\n\t                }\n\t                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n\t                var defaultHtml = subTooltipModel.get('content');\n\t                var asyncTicket = Math.random();\n\t                this._showTooltipContent(\n\t                    // TODO params\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n\t                );\n\t            }\n\t            else {\n\t                if (globalTrigger === 'item') {\n\t                    this._hide();\n\t                }\n\t                else {\n\t                    // Try show axis tooltip\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t\n\t                // Action of cross pointer\n\t                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n\t                if (tooltipModel.get('axisPointer.type') === 'cross') {\n\t                    api.dispatchAction({\n\t                        type: 'showTip',\n\t                        from: this.uid,\n\t                        x: e.offsetX,\n\t                        y: e.offsetY\n\t                    });\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis\n\t         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n\t            var axisPointerModel = tooltipModel.getModel('axisPointer');\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            if (axisPointerType === 'cross') {\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var dataIndex = el.dataIndex;\n\t                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n\t                }\n\t            }\n\t\n\t            this._showAxisPointer();\n\t            var allNotShow = true;\n\t            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n\t                // Try show the axis pointer\n\t                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n\t                var coordSys = allCoordSys[0];\n\t\n\t                // If mouse position is not in the grid or polar\n\t                var point = [e.offsetX, e.offsetY];\n\t\n\t                if (!coordSys.containPoint(point)) {\n\t                    // Hide axis pointer\n\t                    this._hideAxisPointer(coordSys.name);\n\t                    return;\n\t                }\n\t\n\t                allNotShow = false;\n\t                // Make sure point is discrete on cateogry axis\n\t                var dimensions = coordSys.dimensions;\n\t                var value = coordSys.pointToData(point, true);\n\t                point = coordSys.dataToPoint(value);\n\t\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var axisType = axisPointerModel.get('axis');\n\t                if (axisType === 'auto') {\n\t                    axisType = baseAxis.dim;\n\t                }\n\t\n\t                if (baseAxis.isBlank() || zrUtil.eqNaN(point[0]) || zrUtil.eqNaN(point[1])) {\n\t                    this._hideAxisPointer(coordSys.name);\n\t                    return;\n\t                }\n\t\n\t                var contentNotChange = false;\n\t                var lastHover = this._lastHover;\n\t                if (axisPointerType === 'cross') {\n\t                    // If hover data not changed\n\t                    // Possible when two axes are all category\n\t                    if (dataEqual(lastHover.data, value)) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value;\n\t                }\n\t                else {\n\t                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\t\n\t                    // If hover data not changed on the axis dimension\n\t                    if (lastHover.data === value[valIndex]) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value[valIndex];\n\t                }\n\t\n\t                var enableAnimation = tooltipModel.get('animation');\n\t\n\t                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n\t                    this._showCartesianPointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'polar' && !contentNotChange) {\n\t                    this._showPolarPointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n\t                    this._showSinglePointer(\n\t                        axisPointerModel, coordSys, axisType, point, enableAnimation\n\t                    );\n\t                }\n\t\n\t                if (axisPointerType !== 'cross') {\n\t                    this._dispatchAndShowSeriesTooltipContent(\n\t                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n\t                    );\n\t                }\n\t            }, this);\n\t\n\t            if (!this._tooltipModel.get('show')) {\n\t                this._hideAxisPointer();\n\t            }\n\t\n\t            if (allNotShow) {\n\t                this._hide();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of cartesian coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         * @private\n\t         */\n\t        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var moveAnimation = enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && baseAxis.type === 'category'\n\t                && baseAxis.getBandWidth() > 20;\n\t\n\t            if (axisPointerType === 'cross') {\n\t                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n\t                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\t\n\t                this._updateCrossText(cartesian, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n\t                var otherExtent = otherAxis.getGlobalExtent();\n\t\n\t                if (cartesian.type === 'cartesian2d') {\n\t                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n\t                        axisType, point, otherExtent\n\t                    );\n\t                }\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridLine(axisType, point, otherExtent) {\n\t                var targetShape = axisType === 'x'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                graphic.subPixelOptimizeLine({\n\t                    shape: targetShape,\n\t                    style: pointerEl.style\n\t                });\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridShadow(axisType, point, otherExtent) {\n\t                var axis = cartesian.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t                var span = otherExtent[1] - otherExtent[0];\n\t                var targetShape = axisType === 'x'\n\t                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n\t                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n\t            var self = this;\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var moveAnimation =\n\t                enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && single.getBaseAxis().type === 'category';\n\t            var rect = single.getRect();\n\t            var otherExtent = [rect.y, rect.y + rect.height];\n\t\n\t            moveSingleLine(axisType, point, otherExtent);\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveSingleLine(axisType, point, otherExtent) {\n\t                var axis = single.getAxis();\n\t                var orient = axis.orient;\n\t\n\t                var targetShape = orient === 'horizontal'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    single, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of polar coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         */\n\t        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            var angleAxis = polar.getAngleAxis();\n\t            var radiusAxis = polar.getRadiusAxis();\n\t\n\t            var moveAnimation = enableAnimation\n\t                && axisPointerType !== 'cross'\n\t                && polar.getBaseAxis().type === 'category';\n\t\n\t            if (axisPointerType === 'cross') {\n\t                movePolarLine('angle', point, radiusAxis.getExtent());\n\t                movePolarLine('radius', point, angleAxis.getExtent());\n\t\n\t                this._updateCrossText(polar, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n\t                var otherExtent = otherAxis.getExtent();\n\t\n\t                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n\t                    axisType, point, otherExtent\n\t                );\n\t            }\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarLine(axisType, point, otherExtent) {\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                if (axisType === 'angle') {\n\t                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n\t                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n\t                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n\t                }\n\t                else {\n\t                    targetShape = {\n\t                        cx: polar.cx,\n\t                        cy: polar.cy,\n\t                        r: mouseCoord[0]\n\t                    };\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarShadow(axisType, point, otherExtent) {\n\t                var axis = polar.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                var radian = Math.PI / 180;\n\t\n\t                if (axisType === 'angle') {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        otherExtent[0], otherExtent[1],\n\t                        // In ECharts y is negative if angle is positive\n\t                        (-mouseCoord[1] - bandWidth / 2) * radian,\n\t                        (-mouseCoord[1] + bandWidth / 2) * radian\n\t                    );\n\t                }\n\t                else {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        mouseCoord[0] - bandWidth / 2,\n\t                        mouseCoord[0] + bandWidth / 2,\n\t                        0, Math.PI * 2\n\t                    );\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _updateCrossText: function (coordSys, point, axisPointerModel) {\n\t            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n\t            var textStyleModel = crossStyleModel.getModel('textStyle');\n\t\n\t            var tooltipModel = this._tooltipModel;\n\t\n\t            var text = this._crossText;\n\t            if (!text) {\n\t                text = this._crossText = new graphic.Text({\n\t                    style: {\n\t                        textAlign: 'left',\n\t                        textVerticalAlign: 'bottom'\n\t                    }\n\t                });\n\t                this.group.add(text);\n\t            }\n\t\n\t            var value = coordSys.pointToData(point);\n\t\n\t            var dims = coordSys.dimensions;\n\t            value = zrUtil.map(value, function (val, idx) {\n\t                var axis = coordSys.getAxis(dims[idx]);\n\t                if (axis.type === 'category' || axis.type === 'time') {\n\t                    val = axis.scale.getLabel(val);\n\t                }\n\t                else {\n\t                    val = formatUtil.addCommas(\n\t                        val.toFixed(axis.getPixelPrecision())\n\t                    );\n\t                }\n\t                return val;\n\t            });\n\t\n\t            text.setStyle({\n\t                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n\t                textFont: textStyleModel.getFont(),\n\t                text: value.join(', '),\n\t                x: point[0] + 5,\n\t                y: point[1] - 5\n\t            });\n\t            text.z = tooltipModel.get('z');\n\t            text.zlevel = tooltipModel.get('zlevel');\n\t        },\n\t\n\t        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n\t            var tooltipModel = this._tooltipModel;\n\t            var z = tooltipModel.get('z');\n\t            var zlevel = tooltipModel.get('zlevel');\n\t            var axisPointers = this._axisPointers;\n\t            var coordSysName = coordSys.name;\n\t            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n\t            if (axisPointers[coordSysName][axisType]) {\n\t                return axisPointers[coordSysName][axisType];\n\t            }\n\t\n\t            // Create if not exists\n\t            var pointerType = pointerModel.get('type');\n\t            var styleModel = pointerModel.getModel(pointerType + 'Style');\n\t            var isShadow = pointerType === 'shadow';\n\t            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\t\n\t            var elementType = coordSys.type === 'polar'\n\t                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n\t                : (isShadow ? 'Rect' : 'Line');\n\t\n\t            isShadow ? (style.stroke = null) : (style.fill = null);\n\t\n\t            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n\t                style: style,\n\t                z: z,\n\t                zlevel: zlevel,\n\t                silent: true,\n\t                shape: initShape\n\t            });\n\t\n\t            this.group.add(el);\n\t            return el;\n\t        },\n\t\n\t        /**\n\t         * Dispatch actions and show tooltip on series\n\t         * @param {Array.<module:echarts/model/Series>} seriesList\n\t         * @param {Array.<number>} point\n\t         * @param {Array.<number>} value\n\t         * @param {boolean} contentNotChange\n\t         * @param {Array.<number>|string|Function} [positionExpr]\n\t         */\n\t        _dispatchAndShowSeriesTooltipContent: function (\n\t            coordSys, seriesList, point, value, contentNotChange, positionExpr\n\t        ) {\n\t\n\t            var rootTooltipModel = this._tooltipModel;\n\t\n\t            var baseAxis = coordSys.getBaseAxis();\n\t            var baseDimIndex = ({x: 1, radius: 1, single: 1})[baseAxis.dim] ? 0 : 1;\n\t\n\t            if (!seriesList.length) {\n\t                return;\n\t            }\n\t\n\t            var payloadBatch = zrUtil.map(seriesList, function (series) {\n\t                return {\n\t                    seriesIndex: series.seriesIndex,\n\t                    dataIndexInside: series.getAxisTooltipDataIndex\n\t                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n\t                        : series.getData().indexOfNearest(\n\t                            series.coordDimToDataDim(baseAxis.dim)[0],\n\t                            value[baseDimIndex],\n\t                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n\t                            false, baseAxis.type === 'category' ? 0.5 : null\n\t                        )\n\t                };\n\t            });\n\t            var sampleSeriesIndex;\n\t            zrUtil.each(payloadBatch, function (payload, idx) {\n\t                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n\t                    sampleSeriesIndex = idx;\n\t                }\n\t            });\n\t            // Fallback to 0.\n\t            sampleSeriesIndex = sampleSeriesIndex || 0;\n\t\n\t            var lastHover = this._lastHover;\n\t            var api = this._api;\n\t            // Dispatch downplay action\n\t            if (lastHover.payloadBatch && !contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Dispatch highlight action\n\t            if (!contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'highlight',\n\t                    batch: payloadBatch\n\t                });\n\t                lastHover.payloadBatch = payloadBatch;\n\t            }\n\t            // Dispatch showTip action\n\t            var dataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\t            api.dispatchAction({\n\t                type: 'showTip',\n\t                dataIndexInside: dataIndex,\n\t                // expose to user.\n\t                dataIndex: seriesList[sampleSeriesIndex].getData().getRawIndex(dataIndex),\n\t                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n\t                from: this.uid\n\t            });\n\t\n\t            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n\t                var paramsList = zrUtil.map(seriesList, function (series, index) {\n\t                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n\t                });\n\t\n\t                if (!contentNotChange) {\n\t                    // Update html content\n\t                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\t\n\t                    // Default tooltip content\n\t                    // FIXME\n\t                    // (1) shold be the first data which has name?\n\t                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\t                    var firstLine = baseAxis.type === 'time'\n\t                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n\t                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n\t                    var defaultHtml = (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n\t                        + zrUtil.map(seriesList, function (series, index) {\n\t                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n\t                        }).join('<br />');\n\t\n\t                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\t\n\t                    this._showTooltipContent(\n\t                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n\t                        point[0], point[1], positionExpr, null, api\n\t                    );\n\t                }\n\t                else {\n\t                    updatePosition(\n\t                        positionExpr || rootTooltipModel.get('position'),\n\t                        point[0], point[1],\n\t                        rootTooltipModel.get('confine'),\n\t                        this._tooltipContent, paramsList, null, api\n\t                    );\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on item\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         * @param {number} dataIndex\n\t         * @param {string} dataType\n\t         * @param {Object} e\n\t         */\n\t        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n\t            // FIXME Graph data\n\t            var api = this._api;\n\t            var data = seriesModel.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var tooltipOpt = itemModel.get('tooltip', true);\n\t            if (typeof tooltipOpt === 'string') {\n\t                // In each data item tooltip can be simply write:\n\t                // {\n\t                //  value: 10,\n\t                //  tooltip: 'Something you need to know'\n\t                // }\n\t                var tooltipContent = tooltipOpt;\n\t                tooltipOpt = {\n\t                    formatter: tooltipContent\n\t                };\n\t            }\n\t            var rootTooltipModel = this._tooltipModel;\n\t            var seriesTooltipModel = seriesModel.getModel(\n\t                'tooltip', rootTooltipModel\n\t            );\n\t            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\t\n\t            var params = seriesModel.getDataParams(dataIndex, dataType);\n\t            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\t\n\t            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\t\n\t            this._showTooltipContent(\n\t                tooltipModel, defaultHtml, params, asyncTicket,\n\t                e.offsetX, e.offsetY, e.position, e.target, api\n\t            );\n\t        },\n\t\n\t        _showTooltipContent: function (\n\t            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n\t        ) {\n\t            // Reset ticket\n\t            this._ticket = '';\n\t\n\t            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n\t                var tooltipContent = this._tooltipContent;\n\t                var confine = tooltipModel.get('confine');\n\t\n\t                var formatter = tooltipModel.get('formatter');\n\t                positionExpr = positionExpr || tooltipModel.get('position');\n\t                var html = defaultHtml;\n\t\n\t                if (formatter) {\n\t                    if (typeof formatter === 'string') {\n\t                        html = formatUtil.formatTpl(formatter, params, true);\n\t                    }\n\t                    else if (typeof formatter === 'function') {\n\t                        var self = this;\n\t                        var ticket = asyncTicket;\n\t                        var callback = function (cbTicket, html) {\n\t                            if (cbTicket === self._ticket) {\n\t                                tooltipContent.setContent(html);\n\t\n\t                                updatePosition(\n\t                                    positionExpr, x, y, confine,\n\t                                    tooltipContent, params, target, api\n\t                                );\n\t                            }\n\t                        };\n\t                        self._ticket = ticket;\n\t                        html = formatter(params, ticket, callback);\n\t                    }\n\t                }\n\t\n\t                tooltipContent.show(tooltipModel);\n\t                tooltipContent.setContent(html);\n\t\n\t                updatePosition(\n\t                    positionExpr, x, y, confine,\n\t                    tooltipContent, params, target, api\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _showAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.show();\n\t                });\n\t            }\n\t            else {\n\t                this.group.eachChild(function (child) {\n\t                    child.show();\n\t                });\n\t                this.group.show();\n\t            }\n\t        },\n\t\n\t        _resetLastHover: function () {\n\t            var lastHover = this._lastHover;\n\t            if (lastHover.payloadBatch) {\n\t                this._api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Reset lastHover\n\t            this._lastHover = {};\n\t        },\n\t        /**\n\t         * Hide axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _hideAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.hide();\n\t                });\n\t            }\n\t            else {\n\t                if (this.group.children().length) {\n\t                    this.group.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        _hide: function () {\n\t            clearTimeout(this._showTimeout);\n\t\n\t            this._hideAxisPointer();\n\t            this._resetLastHover();\n\t            if (!this._alwaysShowContent) {\n\t                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n\t            }\n\t\n\t            this._api.dispatchAction({\n\t                type: 'hideTip',\n\t                from: this.uid\n\t            });\n\t\n\t            this._lastX = this._lastY = null;\n\t        },\n\t\n\t        dispose: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var zr = api.getZr();\n\t            this._tooltipContent.hide();\n\t\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t        }\n\t    });\n\n\n/***/ },\n/* 170 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var numberUtil = __webpack_require__(4);\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t\n\t    var normalizedExtent = [0, 1];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [0, 0];\n\t\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t\n\t    Axis.prototype = {\n\t\n\t        constructor: Axis,\n\t\n\t        /**\n\t         * If axis extent contain given coord\n\t         * @param {number} coord\n\t         * @return {boolean}\n\t         */\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t\n\t        /**\n\t         * If axis extent contain given data\n\t         * @param {number} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t\n\t        /**\n\t         * Get coord extent.\n\t         * @return {Array.<number>}\n\t         */\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * Get precision used for formatting\n\t         * @param {Array.<number>} [dataExtent]\n\t         * @return {number}\n\t         */\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(\n\t                dataExtent || this.scale.getExtent(),\n\t                this._extent\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Set coord extent\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord. Data is the rank if it has a ordinal scale\n\t         * @param {number} data\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t\n\t        /**\n\t         * Convert coord to data. Data is the rank if it has a ordinal scale\n\t         * @param {number} coord\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t\n\t            return this.scale.scale(t);\n\t        },\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            }\n\t            else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Coords of labels are on the ticks or on the middle of bands\n\t         * @return {Array.<number>}\n\t         */\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t\n\t        /**\n\t         * Get bands.\n\t         *\n\t         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n\t         * |---1---|---2---|---3---|---4---|.\n\t         *\n\t         * @return {Array}\n\t         */\n\t         // FIXME Situation when labels is on ticks\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t\n\t        /**\n\t         * Get width of band\n\t         * @return {number}\n\t         */\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t\n\t            return Math.abs(size) / len;\n\t        },\n\t\n\t        /**\n\t         * When axis extent depends on data and no data exists,\n\t         * axis ticks should not be drawn, which is named 'blank'.\n\t         */\n\t        isBlank: function () {\n\t            return this._isBlank;\n\t        },\n\t\n\t        /**\n\t         * When axis extent depends on data and no data exists,\n\t         * axis ticks should not be drawn, which is named 'blank'.\n\t         */\n\t        setBlank: function (isBlank) {\n\t            this._isBlank = isBlank;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Axis;\n\n\n/***/ },\n/* 171 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var defaultOption = {\n\t        show: true,\n\t        zlevel: 0,                  // \n\t        z: 0,                       // \n\t        // \n\t        inverse: false,\n\t\n\t        // \n\t        name: '',\n\t        // 'start' | 'middle' | 'end'\n\t        nameLocation: 'end',\n\t        // degree\n\t        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n\t        nameTruncate: {\n\t            maxWidth: null,\n\t            ellipsis: '...',\n\t            placeholder: '.'\n\t        },\n\t        // \n\t        nameTextStyle: {},\n\t        // \n\t        nameGap: 15,\n\t\n\t        silent: false, // Default false to support tooltip.\n\t        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\t\n\t        tooltip: {\n\t            show: false\n\t        },\n\t\n\t        // \n\t        axisLine: {\n\t            // show\n\t            show: true,\n\t            onZero: true,\n\t            // lineStyle\n\t            lineStyle: {\n\t                color: '#333',\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        axisTick: {\n\t            // show\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            // length\n\t            length: 5,\n\t            // lineStyle\n\t            lineStyle: {\n\t                width: 1\n\t            }\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            show: true,\n\t            // grid\n\t            inside: false,\n\t            rotate: 0,\n\t            margin: 8,\n\t            // formatter: null,\n\t            // TEXTSTYLE\n\t            textStyle: {\n\t                fontSize: 12\n\t            }\n\t        },\n\t        // \n\t        splitLine: {\n\t            // show\n\t            show: true,\n\t            // lineStylelineStyle\n\t            lineStyle: {\n\t                color: ['#ccc'],\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // \n\t        splitArea: {\n\t            // show\n\t            show: false,\n\t            // areaStyleareaStyle\n\t            areaStyle: {\n\t                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n\t            }\n\t        }\n\t    };\n\t\n\t    var categoryAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: true,\n\t        // splitArea: {\n\t            // show: false\n\t        // },\n\t        splitLine: {\n\t            show: false\n\t        },\n\t        // \n\t        axisTick: {\n\t            // If tick is align with label when boundaryGap is true\n\t            // Default with axisTick\n\t            alignWithLabel: false,\n\t            interval: 'auto'\n\t        },\n\t        // axis.axisLabel\n\t        axisLabel: {\n\t            interval: 'auto'\n\t        }\n\t    }, defaultOption);\n\t\n\t    var valueAxis = zrUtil.merge({\n\t        // \n\t        boundaryGap: [0, 0],\n\t        // ,  'dataMin' \n\t        // min: null,\n\t        //  'dataMax' \n\t        // max: null,\n\t        // Readonly prop, specifies start value of the range when using data zoom.\n\t        // rangeStart: null\n\t        // Readonly prop, specifies end value of the range when using data zoom.\n\t        // rangeEnd: null\n\t        // 0_min_max\n\t        // scale: false,\n\t        // 5\n\t        splitNumber: 5\n\t        // Minimum interval\n\t        // minInterval: null\n\t    }, defaultOption);\n\t\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t        scale: true,\n\t        min: 'dataMin',\n\t        max: 'dataMax'\n\t    }, valueAxis);\n\t    var logAxis = zrUtil.defaults({\n\t        logBase: 10\n\t    }, valueAxis);\n\t    logAxis.scale = true;\n\t\n\t    module.exports = {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\n\n/***/ },\n/* 172 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var axisHelper = __webpack_require__(55);\n\t\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        }\n\t        else {\n\t            return obj;\n\t        }\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        /**\n\t         * Format labels\n\t         * @return {Array.<string>}\n\t         */\n\t        getFormattedLabels: function () {\n\t            return axisHelper.getFormattedLabels(\n\t                this.axis,\n\t                this.get('axisLabel.formatter')\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Get categories\n\t         */\n\t        getCategories: function () {\n\t            return this.get('type') === 'category'\n\t                && zrUtil.map(this.get('data'), getName);\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} origin\n\t         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n\t         */\n\t        getMin: function (origin) {\n\t            var option = this.option;\n\t            var min = (!origin && option.rangeStart != null)\n\t                ? option.rangeStart : option.min;\n\t\n\t            if (min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n\t                min = this.axis.scale.parse(min);\n\t            }\n\t            return min;\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} origin\n\t         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n\t         */\n\t        getMax: function (origin) {\n\t            var option = this.option;\n\t            var max = (!origin && option.rangeEnd != null)\n\t                ? option.rangeEnd : option.max;\n\t\n\t            if (max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n\t                max = this.axis.scale.parse(max);\n\t            }\n\t            return max;\n\t        },\n\t\n\t        /**\n\t         * @return {boolean}\n\t         */\n\t        getNeedCrossZero: function () {\n\t            var option = this.option;\n\t            return (option.rangeStart != null || option.rangeEnd != null)\n\t                ? false : !option.scale;\n\t        },\n\t\n\t        /**\n\t         * Should be implemented by each axis model if necessary.\n\t         * @return {module:echarts/model/Component} coordinate system model\n\t         */\n\t        getCoordSysModel: zrUtil.noop,\n\t\n\t        /**\n\t         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n\t         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n\t         */\n\t        setRange: function (rangeStart, rangeEnd) {\n\t            this.option.rangeStart = rangeStart;\n\t            this.option.rangeEnd = rangeEnd;\n\t        },\n\t\n\t        /**\n\t         * Reset range\n\t         */\n\t        resetRange: function () {\n\t            // rangeStart and rangeEnd is readonly.\n\t            this.option.rangeStart = this.option.rangeEnd = null;\n\t        }\n\t    };\n\n\n/***/ },\n/* 173 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var axisDefault = __webpack_require__(171);\n\t    var zrUtil = __webpack_require__(1);\n\t    var ComponentModel = __webpack_require__(17);\n\t    var layout = __webpack_require__(20);\n\t\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\t\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t\n\t            BaseAxisModelClass.extend({\n\t\n\t                type: axisName + 'Axis.' + axisType,\n\t\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode\n\t                        ? layout.getLayoutParams(option) : {};\n\t\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t\n\t                defaultOption: zrUtil.mergeAll(\n\t                    [\n\t                        {},\n\t                        axisDefault[axisType + 'Axis'],\n\t                        extraDefaultOption\n\t                    ],\n\t                    true\n\t                )\n\t            });\n\t        });\n\t\n\t        ComponentModel.registerSubTypeDefaulter(\n\t            axisName + 'Axis',\n\t            zrUtil.curry(axisTypeDefaulter, axisName)\n\t        );\n\t    };\n\n\n/***/ },\n/* 174 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Axis = __webpack_require__(170);\n\t    var axisLabelInterval = __webpack_require__(178);\n\t\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t\n\t    Axis2D.prototype = {\n\t\n\t        constructor: Axis2D,\n\t\n\t        /**\n\t         * Index of axis, can be used as key\n\t         */\n\t        index: 0,\n\t        /**\n\t         * If axis is on the zero position of the other axis\n\t         * @type {boolean}\n\t         */\n\t        onZero: false,\n\t\n\t        /**\n\t         * Axis model\n\t         * @param {module:echarts/coord/cartesian/AxisModel}\n\t         */\n\t        model: null,\n\t\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t\n\t        /**\n\t         * If label is ignored.\n\t         * Automatically used when axis is category and label can not be all shown\n\t         * @param  {number}  idx\n\t         * @return {boolean}\n\t         */\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return ((typeof labelInterval === 'function')\n\t                    && !labelInterval(idx, this.scale.getLabel(idx)))\n\t                    || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var localCoord = axis.toLocalCoord(80);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toLocalCoord: null,\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var globalCoord = axis.toLocalCoord(40);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toGlobalCoord: null\n\t\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t\n\t    module.exports = Axis2D;\n\n\n/***/ },\n/* 175 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Cartesian coordinate system\n\t * @module  echarts/coord/Cartesian\n\t *\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t\n\t        this._dimList = [];\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t\n\t    Cartesian.prototype = {\n\t\n\t        constructor: Cartesian,\n\t\n\t        type: 'cartesian',\n\t\n\t        /**\n\t         * Get axis\n\t         * @param  {number|string} dim\n\t         * @return {module:echarts/coord/Cartesian~Axis}\n\t         */\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t\n\t        /**\n\t         * Get axes list\n\t         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n\t         */\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t\n\t        /**\n\t         * Get axes list by given scale type\n\t         */\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(\n\t                this.getAxes(),\n\t                function (axis) {\n\t                    return axis.scale.type === scaleType;\n\t                }\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Add axis\n\t         * @param {module:echarts/coord/Cartesian.Axis}\n\t         */\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t\n\t            this._axes[dim] = axis;\n\t\n\t            this._dimList.push(dim);\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord in nd space\n\t         * @param {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t\n\t        /**\n\t         * Convert coord in nd space to data\n\t         * @param  {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t\n\t            var output = input instanceof Array ? [] : {};\n\t\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t\n\t            return output;\n\t        }\n\t    };\n\t\n\t    module.exports = Cartesian;\n\n\n/***/ },\n/* 176 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Cartesian = __webpack_require__(175);\n\t\n\t    function Cartesian2D(name) {\n\t\n\t        Cartesian.call(this, name);\n\t    }\n\t\n\t    Cartesian2D.prototype = {\n\t\n\t        constructor: Cartesian2D,\n\t\n\t        type: 'cartesian2d',\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         * @readOnly\n\t         */\n\t        dimensions: ['x', 'y'],\n\t\n\t        /**\n\t         * Base axis will be used on stacking.\n\t         *\n\t         * @return {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0]\n\t                || this.getAxesByScale('time')[0]\n\t                || this.getAxis('x');\n\t        },\n\t\n\t        /**\n\t         * If contain point\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0]))\n\t                && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t\n\t        /**\n\t         * If contain data\n\t         * @param {Array.<number>} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0])\n\t                && this.getAxis('y').containData(data[1]);\n\t        },\n\t\n\t        /**\n\t         * Convert series data to an array of points\n\t         * @param {module:echarts/data/List} data\n\t         * @param {boolean} stack\n\t         * @return {Array}\n\t         *  Return array of points. For example:\n\t         *  `[[10, 10], [20, 20], [30, 30]]`\n\t         */\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray(['x', 'y'], function (x, y) {\n\t                return this.dataToPoint([x, y]);\n\t            }, stack, this);\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} data\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} point\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * Get other axis\n\t         * @param {module:echarts/coord/cartesian/Axis2D} axis\n\t         */\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t\n\t    module.exports = Cartesian2D;\n\n\n/***/ },\n/* 177 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Grid \n\t//  Cartesian2D \n\t\n\t\n\t    __webpack_require__(81);\n\t    var ComponentModel = __webpack_require__(17);\n\t\n\t    module.exports = ComponentModel.extend({\n\t\n\t        type: 'grid',\n\t\n\t        dependencies: ['xAxis', 'yAxis'],\n\t\n\t        layoutMode: 'box',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Grid}\n\t         */\n\t        coordinateSystem: null,\n\t\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            // If grid size contain label\n\t            containLabel: false,\n\t            // width: {totalWidth} - left - right,\n\t            // height: {totalHeight} - top - bottom,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\n\n/***/ },\n/* 178 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Helper function for axisLabelInterval calculation\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var axisHelper = __webpack_require__(55);\n\t\n\t    module.exports = function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t\n\t        return axisHelper.getAxisLabelInterval(\n\t            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n\t            axisModel.getFormattedLabels(),\n\t            labelModel.getModel('textStyle').getFont(),\n\t            axis.isHorizontal()\n\t        );\n\t    };\n\n\n/***/ },\n/* 179 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\t    function defaultKeyGetter(item) {\n\t        return item;\n\t    }\n\t\n\t    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n\t        this._old = oldArr;\n\t        this._new = newArr;\n\t\n\t        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n\t        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\t    }\n\t\n\t    DataDiffer.prototype = {\n\t\n\t        constructor: DataDiffer,\n\t\n\t        /**\n\t         * Callback function when add a data\n\t         */\n\t        add: function (func) {\n\t            this._add = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when update a data\n\t         */\n\t        update: function (func) {\n\t            this._update = func;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Callback function when remove a data\n\t         */\n\t        remove: function (func) {\n\t            this._remove = func;\n\t            return this;\n\t        },\n\t\n\t        execute: function () {\n\t            var oldArr = this._old;\n\t            var newArr = this._new;\n\t            var oldKeyGetter = this._oldKeyGetter;\n\t            var newKeyGetter = this._newKeyGetter;\n\t\n\t            var oldDataIndexMap = {};\n\t            var newDataIndexMap = {};\n\t            var oldDataKeyArr = [];\n\t            var newDataKeyArr = [];\n\t            var i;\n\t\n\t            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n\t            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\t\n\t            // Travel by inverted order to make sure order consistency\n\t            // when duplicate keys exists (consider newDataIndex.pop() below).\n\t            // For performance consideration, these code below do not look neat.\n\t            for (i = 0; i < oldArr.length; i++) {\n\t                var key = oldDataKeyArr[i];\n\t                var idx = newDataIndexMap[key];\n\t\n\t                // idx can never be empty array here. see 'set null' logic below.\n\t                if (idx != null) {\n\t                    // Consider there is duplicate key (for example, use dataItem.name as key).\n\t                    // We should make sure every item in newArr and oldArr can be visited.\n\t                    var len = idx.length;\n\t                    if (len) {\n\t                        len === 1 && (newDataIndexMap[key] = null);\n\t                        idx = idx.unshift();\n\t                    }\n\t                    else {\n\t                        newDataIndexMap[key] = null;\n\t                    }\n\t                    this._update && this._update(idx, i);\n\t                }\n\t                else {\n\t                    this._remove && this._remove(i);\n\t                }\n\t            }\n\t\n\t            for (var i = 0; i < newDataKeyArr.length; i++) {\n\t                var key = newDataKeyArr[i];\n\t                if (newDataIndexMap.hasOwnProperty(key)) {\n\t                    var idx = newDataIndexMap[key];\n\t                    if (idx == null) {\n\t                        continue;\n\t                    }\n\t                    // idx can never be empty array here. see 'set null' logic above.\n\t                    if (!idx.length) {\n\t                        this._add && this._add(idx);\n\t                    }\n\t                    else {\n\t                        for (var j = 0, len = idx.length; j < len; j++) {\n\t                            this._add && this._add(idx[j]);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function initIndexMap(arr, map, keyArr, keyGetter) {\n\t        for (var i = 0; i < arr.length; i++) {\n\t            var key = keyGetter(arr[i], i);\n\t            var existence = map[key];\n\t            if (existence == null) {\n\t                keyArr.push(key);\n\t                map[key] = i;\n\t            }\n\t            else {\n\t                if (!existence.length) {\n\t                    map[key] = existence = [existence];\n\t                }\n\t                existence.push(i);\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = DataDiffer;\n\n\n/***/ },\n/* 180 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var numberUtil = __webpack_require__(4);\n\t    var parsePercent = numberUtil.parsePercent;\n\t\n\t    function getSeriesStackId(seriesModel) {\n\t        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n\t    }\n\t\n\t    function getAxisKey(axis) {\n\t        return axis.dim + axis.index;\n\t    }\n\t\n\t    function calBarWidthAndOffset(barSeries, api) {\n\t        // Columns info on each category axis. Key is cartesian name\n\t        var columnsMap = {};\n\t\n\t        zrUtil.each(barSeries, function (seriesModel, idx) {\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var axisExtent = baseAxis.getExtent();\n\t            var bandWidth = baseAxis.type === 'category'\n\t                ? baseAxis.getBandWidth()\n\t                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\t\n\t            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n\t                bandWidth: bandWidth,\n\t                remainedWidth: bandWidth,\n\t                autoWidthCount: 0,\n\t                categoryGap: '20%',\n\t                gap: '30%',\n\t                stacks: {}\n\t            };\n\t            var stacks = columnsOnAxis.stacks;\n\t            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t\n\t            if (!stacks[stackId]) {\n\t                columnsOnAxis.autoWidthCount++;\n\t            }\n\t            stacks[stackId] = stacks[stackId] || {\n\t                width: 0,\n\t                maxWidth: 0\n\t            };\n\t\n\t            var barWidth = parsePercent(\n\t                seriesModel.get('barWidth'), bandWidth\n\t            );\n\t            var barMaxWidth = parsePercent(\n\t                seriesModel.get('barMaxWidth'), bandWidth\n\t            );\n\t            var barGap = seriesModel.get('barGap');\n\t            var barCategoryGap = seriesModel.get('barCategoryGap');\n\t\n\t            // Caution: In a single coordinate system, these barGrid attributes\n\t            // will be shared by series. Consider that they have default values,\n\t            // only the attributes set on the last series will work.\n\t            // Do not change this fact unless there will be a break change.\n\t\n\t            // TODO\n\t            if (barWidth && !stacks[stackId].width) {\n\t                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n\t                stacks[stackId].width = barWidth;\n\t                columnsOnAxis.remainedWidth -= barWidth;\n\t            }\n\t\n\t            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n\t            (barGap != null) && (columnsOnAxis.gap = barGap);\n\t            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n\t        });\n\t\n\t        var result = {};\n\t\n\t        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\t\n\t            result[coordSysName] = {};\n\t\n\t            var stacks = columnsOnAxis.stacks;\n\t            var bandWidth = columnsOnAxis.bandWidth;\n\t            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n\t            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\t\n\t            var remainedWidth = columnsOnAxis.remainedWidth;\n\t            var autoWidthCount = columnsOnAxis.autoWidthCount;\n\t            var autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            // Find if any auto calculated bar exceeded maxBarWidth\n\t            zrUtil.each(stacks, function (column, stack) {\n\t                var maxWidth = column.maxWidth;\n\t                if (!column.width && maxWidth && maxWidth < autoWidth) {\n\t                    maxWidth = Math.min(maxWidth, remainedWidth);\n\t                    remainedWidth -= maxWidth;\n\t                    column.width = maxWidth;\n\t                    autoWidthCount--;\n\t                }\n\t            });\n\t\n\t            // Recalculate width again\n\t            autoWidth = (remainedWidth - categoryGap)\n\t                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n\t            autoWidth = Math.max(autoWidth, 0);\n\t\n\t            var widthSum = 0;\n\t            var lastColumn;\n\t            zrUtil.each(stacks, function (column, idx) {\n\t                if (!column.width) {\n\t                    column.width = autoWidth;\n\t                }\n\t                lastColumn = column;\n\t                widthSum += column.width * (1 + barGapPercent);\n\t            });\n\t            if (lastColumn) {\n\t                widthSum -= lastColumn.width * barGapPercent;\n\t            }\n\t\n\t            var offset = -widthSum / 2;\n\t            zrUtil.each(stacks, function (column, stackId) {\n\t                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n\t                    offset: offset,\n\t                    width: column.width\n\t                };\n\t\n\t                offset += column.width * (1 + barGapPercent);\n\t            });\n\t        });\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {string} seriesType\n\t     * @param {module:echarts/model/Global} ecModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function barLayoutGrid(seriesType, ecModel, api) {\n\t\n\t        var barWidthAndOffset = calBarWidthAndOffset(\n\t            zrUtil.filter(\n\t                ecModel.getSeriesByType(seriesType),\n\t                function (seriesModel) {\n\t                    return !ecModel.isSeriesFiltered(seriesModel)\n\t                        && seriesModel.coordinateSystem\n\t                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n\t                }\n\t            )\n\t        );\n\t\n\t        var lastStackCoords = {};\n\t        var lastStackCoordsOrigin = {};\n\t\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t\n\t            var data = seriesModel.getData();\n\t            var cartesian = seriesModel.coordinateSystem;\n\t            var baseAxis = cartesian.getBaseAxis();\n\t\n\t            var stackId = getSeriesStackId(seriesModel);\n\t            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n\t            var columnOffset = columnLayoutInfo.offset;\n\t            var columnWidth = columnLayoutInfo.width;\n\t            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\t\n\t            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\t\n\t            var valueAxisStart = baseAxis.onZero\n\t                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n\t                : valueAxis.getGlobalExtent()[0];\n\t\n\t            var coords = cartesian.dataToPoints(data, true);\n\t            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n\t            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\t\n\t            data.setLayout({\n\t                offset: columnOffset,\n\t                size: columnWidth\n\t            });\n\t\n\t            data.each(valueAxis.dim, function (value, idx) {\n\t                if (isNaN(value)) {\n\t                    return;\n\t                }\n\t\n\t                if (!lastStackCoords[stackId][idx]) {\n\t                    lastStackCoords[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                    lastStackCoordsOrigin[stackId][idx] = {\n\t                        p: valueAxisStart, // Positive stack\n\t                        n: valueAxisStart  // Negative stack\n\t                    };\n\t                }\n\t                var sign = value >= 0 ? 'p' : 'n';\n\t                var coord = coords[idx];\n\t                var lastCoord = lastStackCoords[stackId][idx][sign];\n\t                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t\n\t                if (valueAxis.isHorizontal()) {\n\t                    x = lastCoord;\n\t                    y = coord[1] + columnOffset;\n\t                    width = coord[0] - lastCoordOrigin;\n\t                    height = columnWidth;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n\t                    if (Math.abs(width) < barMinHeight) {\n\t                        width = (width < 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += width;\n\t                }\n\t                else {\n\t                    x = coord[0] + columnOffset;\n\t                    y = lastCoord;\n\t                    width = columnWidth;\n\t                    height = coord[1] - lastCoordOrigin;\n\t\n\t                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n\t                    if (Math.abs(height) < barMinHeight) {\n\t                        // Include zero to has a positive bar\n\t                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n\t                    }\n\t                    lastStackCoords[stackId][idx][sign] += height;\n\t                }\n\t\n\t                data.setItemLayout(idx, {\n\t                    x: x,\n\t                    y: y,\n\t                    width: width,\n\t                    height: height\n\t                });\n\t            }, true);\n\t\n\t        }, this);\n\t    }\n\t\n\t    module.exports = barLayoutGrid;\n\n\n/***/ },\n/* 181 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(3);\n\t    var zrUtil = __webpack_require__(1);\n\t    var PI = Math.PI;\n\t    /**\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     * @param {Object} [opts]\n\t     * @param {string} [opts.text]\n\t     * @param {string} [opts.color]\n\t     * @param {string} [opts.textColor]\n\t     * @return {module:zrender/Element}\n\t     */\n\t    module.exports = function (api, opts) {\n\t        opts = opts || {};\n\t        zrUtil.defaults(opts, {\n\t            text: 'loading',\n\t            color: '#c23531',\n\t            textColor: '#000',\n\t            maskColor: 'rgba(255, 255, 255, 0.8)',\n\t            zlevel: 0\n\t        });\n\t        var mask = new graphic.Rect({\n\t            style: {\n\t                fill: opts.maskColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10000\n\t        });\n\t        var arc = new graphic.Arc({\n\t            shape: {\n\t                startAngle: -PI / 2,\n\t                endAngle: -PI / 2 + 0.1,\n\t                r: 10\n\t            },\n\t            style: {\n\t                stroke: opts.color,\n\t                lineCap: 'round',\n\t                lineWidth: 5\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t        var labelRect = new graphic.Rect({\n\t            style: {\n\t                fill: 'none',\n\t                text: opts.text,\n\t                textPosition: 'right',\n\t                textDistance: 10,\n\t                textFill: opts.textColor\n\t            },\n\t            zlevel: opts.zlevel,\n\t            z: 10001\n\t        });\n\t\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                endAngle: PI * 3 / 2\n\t            })\n\t            .start('circularInOut');\n\t        arc.animateShape(true)\n\t            .when(1000, {\n\t                startAngle: PI * 3 / 2\n\t            })\n\t            .delay(300)\n\t            .start('circularInOut');\n\t\n\t        var group = new graphic.Group();\n\t        group.add(arc);\n\t        group.add(labelRect);\n\t        group.add(mask);\n\t        // Inject resize\n\t        group.resize = function () {\n\t            var cx = api.getWidth() / 2;\n\t            var cy = api.getHeight() / 2;\n\t            arc.setShape({\n\t                cx: cx,\n\t                cy: cy\n\t            });\n\t            var r = arc.shape.r;\n\t            labelRect.setShape({\n\t                x: cx - r,\n\t                y: cy - r,\n\t                width: r * 2,\n\t                height: r * 2\n\t            });\n\t\n\t            mask.setShape({\n\t                x: 0,\n\t                y: 0,\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t        };\n\t        group.resize();\n\t        return group;\n\t    };\n\n\n/***/ },\n/* 182 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts global model\n\t *\n\t * @module {echarts/model/Global}\n\t */\n\t\n\t\n\t\n\t    /**\n\t     * Caution: If the mechanism should be changed some day, these cases\n\t     * should be considered:\n\t     *\n\t     * (1) In `merge option` mode, if using the same option to call `setOption`\n\t     * many times, the result should be the same (try our best to ensure that).\n\t     * (2) In `merge option` mode, if a component has no id/name specified, it\n\t     * will be merged by index, and the result sequence of the components is\n\t     * consistent to the original sequence.\n\t     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n\t     * `mergeOption` in module:echarts/model/OptionManager.\n\t     */\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(13);\n\t    var Model = __webpack_require__(12);\n\t    var each = zrUtil.each;\n\t    var filter = zrUtil.filter;\n\t    var map = zrUtil.map;\n\t    var isArray = zrUtil.isArray;\n\t    var indexOf = zrUtil.indexOf;\n\t    var isObject = zrUtil.isObject;\n\t\n\t    var ComponentModel = __webpack_require__(17);\n\t\n\t    var globalDefault = __webpack_require__(184);\n\t\n\t    var OPTION_INNER_KEY = '\\0_ec_inner';\n\t\n\t    /**\n\t     * @alias module:echarts/model/Global\n\t     *\n\t     * @param {Object} option\n\t     * @param {module:echarts/model/Model} parentModel\n\t     * @param {Object} theme\n\t     */\n\t    var GlobalModel = Model.extend({\n\t\n\t        constructor: GlobalModel,\n\t\n\t        init: function (option, parentModel, theme, optionManager) {\n\t            theme = theme || {};\n\t\n\t            this.option = null; // Mark as not initialized.\n\t\n\t            /**\n\t             * @type {module:echarts/model/Model}\n\t             * @private\n\t             */\n\t            this._theme = new Model(theme);\n\t\n\t            /**\n\t             * @type {module:echarts/model/OptionManager}\n\t             */\n\t            this._optionManager = optionManager;\n\t        },\n\t\n\t        setOption: function (option, optionPreprocessorFuncs) {\n\t            zrUtil.assert(\n\t                !(OPTION_INNER_KEY in option),\n\t                'please use chart.getOption()'\n\t            );\n\t\n\t            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\t\n\t            this.resetOption();\n\t        },\n\t\n\t        /**\n\t         * @param {string} type null/undefined: reset all.\n\t         *                      'recreate': force recreate all.\n\t         *                      'timeline': only reset timeline option\n\t         *                      'media': only reset media query option\n\t         * @return {boolean} Whether option changed.\n\t         */\n\t        resetOption: function (type) {\n\t            var optionChanged = false;\n\t            var optionManager = this._optionManager;\n\t\n\t            if (!type || type === 'recreate') {\n\t                var baseOption = optionManager.mountOption(type === 'recreate');\n\t\n\t                if (!this.option || type === 'recreate') {\n\t                    initBase.call(this, baseOption);\n\t                }\n\t                else {\n\t                    this.restoreData();\n\t                    this.mergeOption(baseOption);\n\t                }\n\t                optionChanged = true;\n\t            }\n\t\n\t            if (type === 'timeline' || type === 'media') {\n\t                this.restoreData();\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'timeline') {\n\t                var timelineOption = optionManager.getTimelineOption(this);\n\t                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n\t            }\n\t\n\t            if (!type || type === 'recreate' || type === 'media') {\n\t                var mediaOptions = optionManager.getMediaOption(this, this._api);\n\t                if (mediaOptions.length) {\n\t                    each(mediaOptions, function (mediaOption) {\n\t                        this.mergeOption(mediaOption, optionChanged = true);\n\t                    }, this);\n\t                }\n\t            }\n\t\n\t            return optionChanged;\n\t        },\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        mergeOption: function (newOption) {\n\t            var option = this.option;\n\t            var componentsMap = this._componentsMap;\n\t            var newCptTypes = [];\n\t\n\t            //  component model  merge\n\t            each(newOption, function (componentOption, mainType) {\n\t                if (componentOption == null) {\n\t                    return;\n\t                }\n\t\n\t                if (!ComponentModel.hasClass(mainType)) {\n\t                    option[mainType] = option[mainType] == null\n\t                        ? zrUtil.clone(componentOption)\n\t                        : zrUtil.merge(option[mainType], componentOption, true);\n\t                }\n\t                else {\n\t                    newCptTypes.push(mainType);\n\t                }\n\t            });\n\t\n\t            // FIXME OPTION \n\t            ComponentModel.topologicalTravel(\n\t                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n\t            );\n\t\n\t            this._seriesIndices = this._seriesIndices || [];\n\t\n\t            function visitComponent(mainType, dependencies) {\n\t                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\t\n\t                var mapResult = modelUtil.mappingToExists(\n\t                    componentsMap[mainType], newCptOptionList\n\t                );\n\t\n\t                modelUtil.makeIdAndName(mapResult);\n\t\n\t                // Set mainType and complete subType.\n\t                each(mapResult, function (item, index) {\n\t                    var opt = item.option;\n\t                    if (isObject(opt)) {\n\t                        item.keyInfo.mainType = mainType;\n\t                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n\t                    }\n\t                });\n\t\n\t                var dependentModels = getComponentsByTypes(\n\t                    componentsMap, dependencies\n\t                );\n\t\n\t                option[mainType] = [];\n\t                componentsMap[mainType] = [];\n\t\n\t                each(mapResult, function (resultItem, index) {\n\t                    var componentModel = resultItem.exist;\n\t                    var newCptOption = resultItem.option;\n\t\n\t                    zrUtil.assert(\n\t                        isObject(newCptOption) || componentModel,\n\t                        'Empty component definition'\n\t                    );\n\t\n\t                    // Consider where is no new option and should be merged using {},\n\t                    // see removeEdgeAndAdd in topologicalTravel and\n\t                    // ComponentModel.getAllClassMainTypes.\n\t                    if (!newCptOption) {\n\t                        componentModel.mergeOption({}, this);\n\t                        componentModel.optionUpdated({}, false);\n\t                    }\n\t                    else {\n\t                        var ComponentModelClass = ComponentModel.getClass(\n\t                            mainType, resultItem.keyInfo.subType, true\n\t                        );\n\t\n\t                        if (componentModel && componentModel instanceof ComponentModelClass) {\n\t                            componentModel.name = resultItem.keyInfo.name;\n\t                            componentModel.mergeOption(newCptOption, this);\n\t                            componentModel.optionUpdated(newCptOption, false);\n\t                        }\n\t                        else {\n\t                            // PENDING Global as parent ?\n\t                            var extraOpt = zrUtil.extend(\n\t                                {\n\t                                    dependentModels: dependentModels,\n\t                                    componentIndex: index\n\t                                },\n\t                                resultItem.keyInfo\n\t                            );\n\t                            componentModel = new ComponentModelClass(\n\t                                newCptOption, this, this, extraOpt\n\t                            );\n\t                            zrUtil.extend(componentModel, extraOpt);\n\t                            componentModel.init(newCptOption, this, this, extraOpt);\n\t                            // Call optionUpdated after init.\n\t                            // newCptOption has been used as componentModel.option\n\t                            // and may be merged with theme and default, so pass null\n\t                            // to avoid confusion.\n\t                            componentModel.optionUpdated(null, true);\n\t                        }\n\t                    }\n\t\n\t                    componentsMap[mainType][index] = componentModel;\n\t                    option[mainType][index] = componentModel.option;\n\t                }, this);\n\t\n\t                // Backup series for filtering.\n\t                if (mainType === 'series') {\n\t                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get option for output (cloned option and inner info removed)\n\t         * @public\n\t         * @return {Object}\n\t         */\n\t        getOption: function () {\n\t            var option = zrUtil.clone(this.option);\n\t\n\t            each(option, function (opts, mainType) {\n\t                if (ComponentModel.hasClass(mainType)) {\n\t                    var opts = modelUtil.normalizeToArray(opts);\n\t                    for (var i = opts.length - 1; i >= 0; i--) {\n\t                        // Remove options with inner id.\n\t                        if (modelUtil.isIdInner(opts[i])) {\n\t                            opts.splice(i, 1);\n\t                        }\n\t                    }\n\t                    option[mainType] = opts;\n\t                }\n\t            });\n\t\n\t            delete option[OPTION_INNER_KEY];\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        getTheme: function () {\n\t            return this._theme;\n\t        },\n\t\n\t        /**\n\t         * @param {string} mainType\n\t         * @param {number} [idx=0]\n\t         * @return {module:echarts/model/Component}\n\t         */\n\t        getComponent: function (mainType, idx) {\n\t            var list = this._componentsMap[mainType];\n\t            if (list) {\n\t                return list[idx || 0];\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If none of index and id and name used, return all components with mainType.\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType\n\t         * @param {string} [condition.subType] If ignore, only query by mainType\n\t         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n\t         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        queryComponents: function (condition) {\n\t            var mainType = condition.mainType;\n\t            if (!mainType) {\n\t                return [];\n\t            }\n\t\n\t            var index = condition.index;\n\t            var id = condition.id;\n\t            var name = condition.name;\n\t\n\t            var cpts = this._componentsMap[mainType];\n\t\n\t            if (!cpts || !cpts.length) {\n\t                return [];\n\t            }\n\t\n\t            var result;\n\t\n\t            if (index != null) {\n\t                if (!isArray(index)) {\n\t                    index = [index];\n\t                }\n\t                result = filter(map(index, function (idx) {\n\t                    return cpts[idx];\n\t                }), function (val) {\n\t                    return !!val;\n\t                });\n\t            }\n\t            else if (id != null) {\n\t                var isIdArray = isArray(id);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n\t                        || (!isIdArray && cpt.id === id);\n\t                });\n\t            }\n\t            else if (name != null) {\n\t                var isNameArray = isArray(name);\n\t                result = filter(cpts, function (cpt) {\n\t                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n\t                        || (!isNameArray && cpt.name === name);\n\t                });\n\t            }\n\t            else {\n\t                // Return all components with mainType\n\t                result = cpts;\n\t            }\n\t\n\t            return filterBySubType(result, condition);\n\t        },\n\t\n\t        /**\n\t         * The interface is different from queryComponents,\n\t         * which is convenient for inner usage.\n\t         *\n\t         * @usage\n\t         * var result = findComponents(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n\t         * );\n\t         * var result = findComponents(\n\t         *     {mainType: 'series'},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * // result like [component0, componnet1, ...]\n\t         *\n\t         * @param {Object} condition\n\t         * @param {string} condition.mainType Mandatory.\n\t         * @param {string} [condition.subType] Optional.\n\t         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n\t         *        where xxx is mainType.\n\t         *        If query attribute is null/undefined or has no index/id/name,\n\t         *        do not filtering by query conditions, which is convenient for\n\t         *        no-payload situations or when target of action is global.\n\t         * @param {Function} [condition.filter] parameter: component, return boolean.\n\t         * @return {Array.<module:echarts/model/Component>}\n\t         */\n\t        findComponents: function (condition) {\n\t            var query = condition.query;\n\t            var mainType = condition.mainType;\n\t\n\t            var queryCond = getQueryCond(query);\n\t            var result = queryCond\n\t                ? this.queryComponents(queryCond)\n\t                : this._componentsMap[mainType];\n\t\n\t            return doFilter(filterBySubType(result, condition));\n\t\n\t            function getQueryCond(q) {\n\t                var indexAttr = mainType + 'Index';\n\t                var idAttr = mainType + 'Id';\n\t                var nameAttr = mainType + 'Name';\n\t                return q && (\n\t                        q[indexAttr] != null\n\t                        || q[idAttr] != null\n\t                        || q[nameAttr] != null\n\t                    )\n\t                    ? {\n\t                        mainType: mainType,\n\t                        // subType will be filtered finally.\n\t                        index: q[indexAttr],\n\t                        id: q[idAttr],\n\t                        name: q[nameAttr]\n\t                    }\n\t                    : null;\n\t            }\n\t\n\t            function doFilter(res) {\n\t                return condition.filter\n\t                     ? filter(res, condition.filter)\n\t                     : res;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @usage\n\t         * eachComponent('legend', function (legendModel, index) {\n\t         *     ...\n\t         * });\n\t         * eachComponent(function (componentType, model, index) {\n\t         *     // componentType does not include subType\n\t         *     // (componentType is 'xxx' but not 'xxx.aa')\n\t         * });\n\t         * eachComponent(\n\t         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         * eachComponent(\n\t         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n\t         *     function (model, index) {...}\n\t         * );\n\t         *\n\t         * @param {string|Object=} mainType When mainType is object, the definition\n\t         *                                  is the same as the method 'findComponents'.\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachComponent: function (mainType, cb, context) {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            if (typeof mainType === 'function') {\n\t                context = cb;\n\t                cb = mainType;\n\t                each(componentsMap, function (components, componentType) {\n\t                    each(components, function (component, index) {\n\t                        cb.call(context, componentType, component, index);\n\t                    });\n\t                });\n\t            }\n\t            else if (zrUtil.isString(mainType)) {\n\t                each(componentsMap[mainType], cb, context);\n\t            }\n\t            else if (isObject(mainType)) {\n\t                var queryResult = this.findComponents(mainType);\n\t                each(queryResult, cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByName: function (name) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.name === name;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @param {number} seriesIndex\n\t         * @return {module:echarts/model/Series}\n\t         */\n\t        getSeriesByIndex: function (seriesIndex) {\n\t            return this._componentsMap.series[seriesIndex];\n\t        },\n\t\n\t        /**\n\t         * @param {string} subType\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeriesByType: function (subType) {\n\t            var series = this._componentsMap.series;\n\t            return filter(series, function (oneSeries) {\n\t                return oneSeries.subType === subType;\n\t            });\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Series>}\n\t         */\n\t        getSeries: function () {\n\t            return this._componentsMap.series.slice();\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different\n\t         * frome raw series.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                cb.call(context, series, rawSeriesIndex);\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered.\n\t         *\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeries: function (cb, context) {\n\t            each(this._componentsMap.series, cb, context);\n\t        },\n\t\n\t        /**\n\t         * After filtering, series may be different.\n\t         * frome raw series.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachSeriesByType: function (subType, cb, context) {\n\t            assertSeriesInitialized(this);\n\t            each(this._seriesIndices, function (rawSeriesIndex) {\n\t                var series = this._componentsMap.series[rawSeriesIndex];\n\t                if (series.subType === subType) {\n\t                    cb.call(context, series, rawSeriesIndex);\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * Iterate raw series before filtered of given type.\n\t         *\n\t         * @parma {string} subType\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        eachRawSeriesByType: function (subType, cb, context) {\n\t            return each(this.getSeriesByType(subType), cb, context);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         */\n\t        isSeriesFiltered: function (seriesModel) {\n\t            assertSeriesInitialized(this);\n\t            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n\t        },\n\t\n\t        /**\n\t         * @param {Function} cb\n\t         * @param {*} context\n\t         */\n\t        filterSeries: function (cb, context) {\n\t            assertSeriesInitialized(this);\n\t            var filteredSeries = filter(\n\t                this._componentsMap.series, cb, context\n\t            );\n\t            this._seriesIndices = createSeriesIndices(filteredSeries);\n\t        },\n\t\n\t        restoreData: function () {\n\t            var componentsMap = this._componentsMap;\n\t\n\t            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\t\n\t            var componentTypes = [];\n\t            each(componentsMap, function (components, componentType) {\n\t                componentTypes.push(componentType);\n\t            });\n\t\n\t            ComponentModel.topologicalTravel(\n\t                componentTypes,\n\t                ComponentModel.getAllClassMainTypes(),\n\t                function (componentType, dependencies) {\n\t                    each(componentsMap[componentType], function (component) {\n\t                        component.restoreData();\n\t                    });\n\t                }\n\t            );\n\t        }\n\t\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function mergeTheme(option, theme) {\n\t        zrUtil.each(theme, function (themeItem, name) {\n\t            //  component model  merge  model \n\t            if (!ComponentModel.hasClass(name)) {\n\t                if (typeof themeItem === 'object') {\n\t                    option[name] = !option[name]\n\t                        ? zrUtil.clone(themeItem)\n\t                        : zrUtil.merge(option[name], themeItem, false);\n\t                }\n\t                else {\n\t                    if (option[name] == null) {\n\t                        option[name] = themeItem;\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    }\n\t\n\t    function initBase(baseOption) {\n\t        baseOption = baseOption;\n\t\n\t        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n\t        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\t        this.option = {};\n\t        this.option[OPTION_INNER_KEY] = 1;\n\t\n\t        /**\n\t         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n\t         * @private\n\t         */\n\t        this._componentsMap = {};\n\t\n\t        /**\n\t         * Mapping between filtered series list and raw series list.\n\t         * key: filtered series indices, value: raw series indices.\n\t         * @type {Array.<nubmer>}\n\t         * @private\n\t         */\n\t        this._seriesIndices = null;\n\t\n\t        mergeTheme(baseOption, this._theme.option);\n\t\n\t        // TODO Needs clone when merging to the unexisted property\n\t        zrUtil.merge(baseOption, globalDefault, false);\n\t\n\t        this.mergeOption(baseOption);\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     * @param {Array.<string>|string} types model types\n\t     * @return {Object} key: {string} type, value: {Array.<Object>} models\n\t     */\n\t    function getComponentsByTypes(componentsMap, types) {\n\t        if (!zrUtil.isArray(types)) {\n\t            types = types ? [types] : [];\n\t        }\n\t\n\t        var ret = {};\n\t        each(types, function (type) {\n\t            ret[type] = (componentsMap[type] || []).slice();\n\t        });\n\t\n\t        return ret;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function determineSubType(mainType, newCptOption, existComponent) {\n\t        var subType = newCptOption.type\n\t            ? newCptOption.type\n\t            : existComponent\n\t            ? existComponent.subType\n\t            // Use determineSubType only when there is no existComponent.\n\t            : ComponentModel.determineSubType(mainType, newCptOption);\n\t\n\t        // tooltip, markline, markpoint may always has no subType\n\t        return subType;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function createSeriesIndices(seriesModels) {\n\t        return map(seriesModels, function (series) {\n\t            return series.componentIndex;\n\t        }) || [];\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function filterBySubType(components, condition) {\n\t        // Using hasOwnProperty for restrict. Consider\n\t        // subType is undefined in user payload.\n\t        return condition.hasOwnProperty('subType')\n\t            ? filter(components, function (cpt) {\n\t                return cpt.subType === condition.subType;\n\t            })\n\t            : components;\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function assertSeriesInitialized(ecModel) {\n\t        // Components that use _seriesIndices should depends on series component,\n\t        // which make sure that their initialization is after series.\n\t        if (__DEV__) {\n\t            if (!ecModel._seriesIndices) {\n\t                throw new Error('Series has not been initialized yet.');\n\t            }\n\t        }\n\t    }\n\t\n\t    zrUtil.mixin(GlobalModel, __webpack_require__(85));\n\t\n\t    module.exports = GlobalModel;\n\n\n/***/ },\n/* 183 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * ECharts option manager\n\t *\n\t * @module {echarts/model/OptionManager}\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var modelUtil = __webpack_require__(13);\n\t    var ComponentModel = __webpack_require__(17);\n\t    var each = zrUtil.each;\n\t    var clone = zrUtil.clone;\n\t    var map = zrUtil.map;\n\t    var merge = zrUtil.merge;\n\t\n\t    var QUERY_REG = /^(min|max)?(.+)$/;\n\t\n\t    /**\n\t     * TERM EXPLANATIONS:\n\t     *\n\t     * [option]:\n\t     *\n\t     *     An object that contains definitions of components. For example:\n\t     *     var option = {\n\t     *         title: {...},\n\t     *         legend: {...},\n\t     *         visualMap: {...},\n\t     *         series: [\n\t     *             {data: [...]},\n\t     *             {data: [...]},\n\t     *             ...\n\t     *         ]\n\t     *     };\n\t     *\n\t     * [rawOption]:\n\t     *\n\t     *     An object input to echarts.setOption. 'rawOption' may be an\n\t     *     'option', or may be an object contains multi-options. For example:\n\t     *     var option = {\n\t     *         baseOption: {\n\t     *             title: {...},\n\t     *             legend: {...},\n\t     *             series: [\n\t     *                 {data: [...]},\n\t     *                 {data: [...]},\n\t     *                 ...\n\t     *             ]\n\t     *         },\n\t     *         timeline: {...},\n\t     *         options: [\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             {title: {...}, series: {data: [...]}},\n\t     *             ...\n\t     *         ],\n\t     *         media: [\n\t     *             {\n\t     *                 query: {maxWidth: 320},\n\t     *                 option: {series: {x: 20}, visualMap: {show: false}}\n\t     *             },\n\t     *             {\n\t     *                 query: {minWidth: 320, maxWidth: 720},\n\t     *                 option: {series: {x: 500}, visualMap: {show: true}}\n\t     *             },\n\t     *             {\n\t     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n\t     *             }\n\t     *         ]\n\t     *     };\n\t     *\n\t     * @alias module:echarts/model/OptionManager\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    function OptionManager(api) {\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:echarts/ExtensionAPI}\n\t         */\n\t        this._api = api;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._timelineOptions = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._mediaList = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._mediaDefault;\n\t\n\t        /**\n\t         * -1, means default.\n\t         * empty means no media.\n\t         * @private\n\t         * @type {Array.<number>}\n\t         */\n\t        this._currentMediaIndices = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._optionBackup;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Object}\n\t         */\n\t        this._newBaseOption;\n\t    }\n\t\n\t    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n\t    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n\t    // rawOption cloned and backuped when timeline changed, which does no\n\t    // good to performance. What's more, that both timeline and setOption\n\t    // method supply 'notMerge' brings complex and some problems.\n\t    // Consider this case:\n\t    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n\t    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\t\n\t    OptionManager.prototype = {\n\t\n\t        constructor: OptionManager,\n\t\n\t        /**\n\t         * @public\n\t         * @param {Object} rawOption Raw option.\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Array.<Function>} optionPreprocessorFuncs\n\t         * @return {Object} Init option\n\t         */\n\t        setOption: function (rawOption, optionPreprocessorFuncs) {\n\t            rawOption = clone(rawOption, true);\n\t\n\t            // FIXME\n\t            //  timeline options  media baseOption\n\t\n\t            var oldOptionBackup = this._optionBackup;\n\t            var newParsedOption = parseRawOption.call(\n\t                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n\t            );\n\t            this._newBaseOption = newParsedOption.baseOption;\n\t\n\t            // For setOption at second time (using merge mode);\n\t            if (oldOptionBackup) {\n\t                // Only baseOption can be merged.\n\t                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\t\n\t                // For simplicity, timeline options and media options do not support merge,\n\t                // that is, if you `setOption` twice and both has timeline options, the latter\n\t                // timeline opitons will not be merged to the formers, but just substitude them.\n\t                if (newParsedOption.timelineOptions.length) {\n\t                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n\t                }\n\t                if (newParsedOption.mediaList.length) {\n\t                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n\t                }\n\t                if (newParsedOption.mediaDefault) {\n\t                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n\t                }\n\t            }\n\t            else {\n\t                this._optionBackup = newParsedOption;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {boolean} isRecreate\n\t         * @return {Object}\n\t         */\n\t        mountOption: function (isRecreate) {\n\t            var optionBackup = this._optionBackup;\n\t\n\t            // TODO\n\t            // resetclone\n\t\n\t            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n\t            this._mediaList = map(optionBackup.mediaList, clone);\n\t            this._mediaDefault = clone(optionBackup.mediaDefault);\n\t            this._currentMediaIndices = [];\n\t\n\t            return clone(isRecreate\n\t                // this._optionBackup.baseOption, which is created at the first `setOption`\n\t                // called, and is merged into every new option by inner method `mergeOption`\n\t                // each time `setOption` called, can be only used in `isRecreate`, because\n\t                // its reliability is under suspicion. In other cases option merge is\n\t                // performed by `model.mergeOption`.\n\t                ? optionBackup.baseOption : this._newBaseOption\n\t            );\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Object}\n\t         */\n\t        getTimelineOption: function (ecModel) {\n\t            var option;\n\t            var timelineOptions = this._timelineOptions;\n\t\n\t            if (timelineOptions.length) {\n\t                // getTimelineOption can only be called after ecModel inited,\n\t                // so we can get currentIndex from timelineModel.\n\t                var timelineModel = ecModel.getComponent('timeline');\n\t                if (timelineModel) {\n\t                    option = clone(\n\t                        timelineOptions[timelineModel.getCurrentIndex()],\n\t                        true\n\t                    );\n\t                }\n\t            }\n\t\n\t            return option;\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @return {Array.<Object>}\n\t         */\n\t        getMediaOption: function (ecModel) {\n\t            var ecWidth = this._api.getWidth();\n\t            var ecHeight = this._api.getHeight();\n\t            var mediaList = this._mediaList;\n\t            var mediaDefault = this._mediaDefault;\n\t            var indices = [];\n\t            var result = [];\n\t\n\t            // No media defined.\n\t            if (!mediaList.length && !mediaDefault) {\n\t                return result;\n\t            }\n\t\n\t            // Multi media may be applied, the latter defined media has higher priority.\n\t            for (var i = 0, len = mediaList.length; i < len; i++) {\n\t                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n\t                    indices.push(i);\n\t                }\n\t            }\n\t\n\t            // FIXME\n\t            // mediaDefault\n\t            if (!indices.length && mediaDefault) {\n\t                indices = [-1];\n\t            }\n\t\n\t            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n\t                result = map(indices, function (index) {\n\t                    return clone(\n\t                        index === -1 ? mediaDefault.option : mediaList[index].option\n\t                    );\n\t                });\n\t            }\n\t            // Otherwise return nothing.\n\t\n\t            this._currentMediaIndices = indices;\n\t\n\t            return result;\n\t        }\n\t    };\n\t\n\t    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n\t        var timelineOptions = [];\n\t        var mediaList = [];\n\t        var mediaDefault;\n\t        var baseOption;\n\t\n\t        // Compatible with ec2.\n\t        var timelineOpt = rawOption.timeline;\n\t\n\t        if (rawOption.baseOption) {\n\t            baseOption = rawOption.baseOption;\n\t        }\n\t\n\t        // For timeline\n\t        if (timelineOpt || rawOption.options) {\n\t            baseOption = baseOption || {};\n\t            timelineOptions = (rawOption.options || []).slice();\n\t        }\n\t\n\t        // For media query\n\t        if (rawOption.media) {\n\t            baseOption = baseOption || {};\n\t            var media = rawOption.media;\n\t            each(media, function (singleMedia) {\n\t                if (singleMedia && singleMedia.option) {\n\t                    if (singleMedia.query) {\n\t                        mediaList.push(singleMedia);\n\t                    }\n\t                    else if (!mediaDefault) {\n\t                        // Use the first media default.\n\t                        mediaDefault = singleMedia;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t\n\t        // For normal option\n\t        if (!baseOption) {\n\t            baseOption = rawOption;\n\t        }\n\t\n\t        // Set timelineOpt to baseOption in ec3,\n\t        // which is convenient for merge option.\n\t        if (!baseOption.timeline) {\n\t            baseOption.timeline = timelineOpt;\n\t        }\n\t\n\t        // Preprocess.\n\t        each([baseOption].concat(timelineOptions)\n\t            .concat(zrUtil.map(mediaList, function (media) {\n\t                return media.option;\n\t            })),\n\t            function (option) {\n\t                each(optionPreprocessorFuncs, function (preProcess) {\n\t                    preProcess(option, isNew);\n\t                });\n\t            }\n\t        );\n\t\n\t        return {\n\t            baseOption: baseOption,\n\t            timelineOptions: timelineOptions,\n\t            mediaDefault: mediaDefault,\n\t            mediaList: mediaList\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n\t     * Support: width, height, aspectRatio\n\t     * Can use max or min as prefix.\n\t     */\n\t    function applyMediaQuery(query, ecWidth, ecHeight) {\n\t        var realMap = {\n\t            width: ecWidth,\n\t            height: ecHeight,\n\t            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\t        };\n\t\n\t        var applicatable = true;\n\t\n\t        zrUtil.each(query, function (value, attr) {\n\t            var matched = attr.match(QUERY_REG);\n\t\n\t            if (!matched || !matched[1] || !matched[2]) {\n\t                return;\n\t            }\n\t\n\t            var operator = matched[1];\n\t            var realAttr = matched[2].toLowerCase();\n\t\n\t            if (!compare(realMap[realAttr], value, operator)) {\n\t                applicatable = false;\n\t            }\n\t        });\n\t\n\t        return applicatable;\n\t    }\n\t\n\t    function compare(real, expect, operator) {\n\t        if (operator === 'min') {\n\t            return real >= expect;\n\t        }\n\t        else if (operator === 'max') {\n\t            return real <= expect;\n\t        }\n\t        else { // Equals\n\t            return real === expect;\n\t        }\n\t    }\n\t\n\t    function indicesEquals(indices1, indices2) {\n\t        // indices is always order by asc and has only finite number.\n\t        return indices1.join(',') === indices2.join(',');\n\t    }\n\t\n\t    /**\n\t     * Consider case:\n\t     * `chart.setOption(opt1);`\n\t     * Then user do some interaction like dataZoom, dataView changing.\n\t     * `chart.setOption(opt2);`\n\t     * Then user press 'reset button' in toolbox.\n\t     *\n\t     * After doing that all of the interaction effects should be reset, the\n\t     * chart should be the same as the result of invoke\n\t     * `chart.setOption(opt1); chart.setOption(opt2);`.\n\t     *\n\t     * Although it is not able ensure that\n\t     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n\t     * `chart.setOption(merge(opt1, opt2));` exactly,\n\t     * this might be the only simple way to implement that feature.\n\t     *\n\t     * MEMO: We've considered some other approaches:\n\t     * 1. Each model handle its self restoration but not uniform treatment.\n\t     *     (Too complex in logic and error-prone)\n\t     * 2. Use a shadow ecModel. (Performace expensive)\n\t     */\n\t    function mergeOption(oldOption, newOption) {\n\t        newOption = newOption || {};\n\t\n\t        each(newOption, function (newCptOpt, mainType) {\n\t            if (newCptOpt == null) {\n\t                return;\n\t            }\n\t\n\t            var oldCptOpt = oldOption[mainType];\n\t\n\t            if (!ComponentModel.hasClass(mainType)) {\n\t                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n\t            }\n\t            else {\n\t                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n\t                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\t\n\t                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\t\n\t                oldOption[mainType] = map(mapResult, function (item) {\n\t                    return (item.option && item.exist)\n\t                        ? merge(item.exist, item.option, true)\n\t                        : (item.exist || item.option);\n\t                });\n\t            }\n\t        });\n\t    }\n\t\n\t    module.exports = OptionManager;\n\n\n/***/ },\n/* 184 */\n/***/ function(module, exports) {\n\n\t\n\t    var platform = '';\n\t    // Navigator not exists in node\n\t    if (typeof navigator !== 'undefined') {\n\t        platform = navigator.platform || '';\n\t    }\n\t    module.exports = {\n\t        // \n\t        // backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n\t        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n\t        // \n\t        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n\t        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n\t        // \n\t        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\t\n\t        //  Grid \n\t        // grid: {},\n\t        // \n\t        textStyle: {\n\t            // color: '#000',\n\t            // decoration: 'none',\n\t            // PENDING\n\t            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n\t            // fontFamily: 'Arial, Verdana, sans-serif',\n\t            fontSize: 12,\n\t            fontStyle: 'normal',\n\t            fontWeight: 'normal'\n\t        },\n\t\n\t        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n\t        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t        // Default is source-over\n\t        blendMode: null,\n\t\n\t        animation: true,\n\t        animationDuration: 1000,\n\t        animationDurationUpdate: 300,\n\t        animationEasing: 'exponentialOut',\n\t        animationEasingUpdate: 'cubicOut',\n\t\n\t        animationThreshold: 2000,\n\t        // Configuration for progressive/incremental rendering\n\t        progressiveThreshold: 3000,\n\t        progressive: 400,\n\t\n\t        // Threshold of if use single hover layer to optimize.\n\t        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n\t        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n\t        // which is unexpected.\n\t        // see example <echarts/test/heatmap-large.html>.\n\t        hoverLayerThreshold: 3000\n\t    };\n\n\n/***/ },\n/* 185 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    module.exports = {\n\t        getAreaStyle: __webpack_require__(34)(\n\t            [\n\t                ['fill', 'color'],\n\t                ['shadowBlur'],\n\t                ['shadowOffsetX'],\n\t                ['shadowOffsetY'],\n\t                ['opacity'],\n\t                ['shadowColor']\n\t            ]\n\t        )\n\t    };\n\n\n/***/ },\n/* 186 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        getBoxLayoutParams: function () {\n\t            return {\n\t                left: this.get('left'),\n\t                top: this.get('top'),\n\t                right: this.get('right'),\n\t                bottom: this.get('bottom'),\n\t                width: this.get('width'),\n\t                height: this.get('height')\n\t            };\n\t        }\n\t    };\n\n\n/***/ },\n/* 187 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getItemStyle = __webpack_require__(34)(\n\t        [\n\t            ['fill', 'color'],\n\t            ['stroke', 'borderColor'],\n\t            ['lineWidth', 'borderWidth'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor'],\n\t            ['textPosition'],\n\t            ['textAlign']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getItemStyle: function (excludes) {\n\t            var style = getItemStyle.call(this, excludes);\n\t            var lineDash = this.getBorderLineDash();\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getBorderLineDash: function () {\n\t            var lineType = this.get('borderType');\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 188 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var getLineStyle = __webpack_require__(34)(\n\t        [\n\t            ['lineWidth', 'width'],\n\t            ['stroke', 'color'],\n\t            ['opacity'],\n\t            ['shadowBlur'],\n\t            ['shadowOffsetX'],\n\t            ['shadowOffsetY'],\n\t            ['shadowColor']\n\t        ]\n\t    );\n\t    module.exports = {\n\t        getLineStyle: function (excludes) {\n\t            var style = getLineStyle.call(this, excludes);\n\t            var lineDash = this.getLineDash(style.lineWidth);\n\t            lineDash && (style.lineDash = lineDash);\n\t            return style;\n\t        },\n\t\n\t        getLineDash: function (lineWidth) {\n\t            if (lineWidth == null) {\n\t                lineWidth = 1;\n\t            }\n\t            var lineType = this.get('type');\n\t            var dotSize = Math.max(lineWidth, 2);\n\t            var dashSize = lineWidth * 4;\n\t            return (lineType === 'solid' || lineType == null) ? null\n\t                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n\t        }\n\t    };\n\n\n/***/ },\n/* 189 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textContain = __webpack_require__(21);\n\t\n\t    function getShallow(model, path) {\n\t        return model && model.getShallow(path);\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Get color property or get color from option.textStyle.color\n\t         * @return {string}\n\t         */\n\t        getTextColor: function () {\n\t            var ecModel = this.ecModel;\n\t            return this.getShallow('color')\n\t                || (ecModel && ecModel.get('textStyle.color'));\n\t        },\n\t\n\t        /**\n\t         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n\t         * @return {string}\n\t         */\n\t        getFont: function () {\n\t            var ecModel = this.ecModel;\n\t            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n\t            return [\n\t                // FIXME in node-canvas fontWeight is before fontStyle\n\t                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n\t                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n\t                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n\t                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n\t            ].join(' ');\n\t        },\n\t\n\t        getTextRect: function (text) {\n\t            return textContain.getBoundingRect(\n\t                text,\n\t                this.getFont(),\n\t                this.getShallow('align'),\n\t                this.getShallow('baseline')\n\t            );\n\t        },\n\t\n\t        truncateText: function (text, containerWidth, ellipsis, options) {\n\t            return textContain.truncateText(\n\t                text, containerWidth, this.getFont(), ellipsis, options\n\t            );\n\t        }\n\t    };\n\n\n/***/ },\n/* 190 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Compatitable with 2.0\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var compatStyle = __webpack_require__(191);\n\t\n\t    function get(opt, path) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        for (var i = 0; i < path.length; i++) {\n\t            obj = obj && obj[path[i]];\n\t            if (obj == null) {\n\t                break;\n\t            }\n\t        }\n\t        return obj;\n\t    }\n\t\n\t    function set(opt, path, val, overwrite) {\n\t        path = path.split(',');\n\t        var obj = opt;\n\t        var key;\n\t        for (var i = 0; i < path.length - 1; i++) {\n\t            key = path[i];\n\t            if (obj[key] == null) {\n\t                obj[key] = {};\n\t            }\n\t            obj = obj[key];\n\t        }\n\t        if (overwrite || obj[path[i]] == null) {\n\t            obj[path[i]] = val;\n\t        }\n\t    }\n\t\n\t    function compatLayoutProperties(option) {\n\t        each(LAYOUT_PROPERTIES, function (prop) {\n\t            if (prop[0] in option && !(prop[1] in option)) {\n\t                option[prop[1]] = option[prop[0]];\n\t            }\n\t        });\n\t    }\n\t\n\t    var LAYOUT_PROPERTIES = [\n\t        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n\t    ];\n\t\n\t    var COMPATITABLE_COMPONENTS = [\n\t        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n\t    ];\n\t\n\t    var COMPATITABLE_SERIES = [\n\t        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n\t        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n\t        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n\t    ];\n\t\n\t    var each = zrUtil.each;\n\t\n\t    module.exports = function (option) {\n\t        each(option.series, function (seriesOpt) {\n\t            if (!zrUtil.isObject(seriesOpt)) {\n\t                return;\n\t            }\n\t\n\t            var seriesType = seriesOpt.type;\n\t\n\t            compatStyle(seriesOpt);\n\t\n\t            if (seriesType === 'pie' || seriesType === 'gauge') {\n\t                if (seriesOpt.clockWise != null) {\n\t                    seriesOpt.clockwise = seriesOpt.clockWise;\n\t                }\n\t            }\n\t            if (seriesType === 'gauge') {\n\t                var pointerColor = get(seriesOpt, 'pointer.color');\n\t                pointerColor != null\n\t                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n\t            }\n\t\n\t            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n\t                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n\t                    compatLayoutProperties(seriesOpt);\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t\n\t        // dataRange has changed to visualMap\n\t        if (option.dataRange) {\n\t            option.visualMap = option.dataRange;\n\t        }\n\t\n\t        each(COMPATITABLE_COMPONENTS, function (componentName) {\n\t            var options = option[componentName];\n\t            if (options) {\n\t                if (!zrUtil.isArray(options)) {\n\t                    options = [options];\n\t                }\n\t                each(options, function (option) {\n\t                    compatLayoutProperties(option);\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 191 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var POSSIBLE_STYLES = [\n\t        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n\t        'chordStyle', 'label', 'labelLine'\n\t    ];\n\t\n\t    function compatItemStyle(opt) {\n\t        var itemStyleOpt = opt && opt.itemStyle;\n\t        if (itemStyleOpt) {\n\t            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n\t                var normalItemStyleOpt = itemStyleOpt.normal;\n\t                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\t                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].normal) {\n\t                        opt[styleName].normal = normalItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n\t                    }\n\t                    normalItemStyleOpt[styleName] = null;\n\t                }\n\t                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n\t                    opt[styleName] = opt[styleName] || {};\n\t                    if (!opt[styleName].emphasis) {\n\t                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n\t                    }\n\t                    else {\n\t                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n\t                    }\n\t                    emphasisItemStyleOpt[styleName] = null;\n\t                }\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesOpt) {\n\t        if (!seriesOpt) {\n\t            return;\n\t        }\n\t        compatItemStyle(seriesOpt);\n\t        compatItemStyle(seriesOpt.markPoint);\n\t        compatItemStyle(seriesOpt.markLine);\n\t        var data = seriesOpt.data;\n\t        if (data) {\n\t            for (var i = 0; i < data.length; i++) {\n\t                compatItemStyle(data[i]);\n\t            }\n\t            // mark point data\n\t            var markPoint = seriesOpt.markPoint;\n\t            if (markPoint && markPoint.data) {\n\t                var mpData = markPoint.data;\n\t                for (var i = 0; i < mpData.length; i++) {\n\t                    compatItemStyle(mpData[i]);\n\t                }\n\t            }\n\t            // mark line data\n\t            var markLine = seriesOpt.markLine;\n\t            if (markLine && markLine.data) {\n\t                var mlData = markLine.data;\n\t                for (var i = 0; i < mlData.length; i++) {\n\t                    if (zrUtil.isArray(mlData[i])) {\n\t                        compatItemStyle(mlData[i][0]);\n\t                        compatItemStyle(mlData[i][1]);\n\t                    }\n\t                    else {\n\t                        compatItemStyle(mlData[i]);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 192 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\n\n/***/ },\n/* 193 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Log scale\n\t * @module echarts/scale/Log\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Scale = __webpack_require__(35);\n\t    var numberUtil = __webpack_require__(4);\n\t\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = __webpack_require__(57);\n\t\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t\n\t    var mathLog = Math.log;\n\t\n\t    var LogScale = Scale.extend({\n\t\n\t        type: 'log',\n\t\n\t        base: 10,\n\t\n\t        $constructor: function () {\n\t            Scale.apply(this, arguments);\n\t            this._originalScale = new IntervalScale();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            var originalScale = this._originalScale;\n\t            var extent = this._extent;\n\t            var originalExtent = originalScale.getExtent();\n\t\n\t            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                var powVal = numberUtil.round(mathPow(this.base, val));\n\t\n\t                // Fix #4158\n\t                powVal = (val === extent[0] && originalScale.__fixMin)\n\t                    ? fixRoundingError(powVal, originalExtent[0])\n\t                    : powVal;\n\t                powVal = (val === extent[1] && originalScale.__fixMax)\n\t                    ? fixRoundingError(powVal, originalExtent[1])\n\t                    : powVal;\n\t\n\t                return powVal;\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @param {number} val\n\t         * @return {string}\n\t         */\n\t        getLabel: intervalScaleProto.getLabel,\n\t\n\t        /**\n\t         * @param  {number} val\n\t         * @return {number}\n\t         */\n\t        scale: function (val) {\n\t            val = scaleProto.scale.call(this, val);\n\t            return mathPow(this.base, val);\n\t        },\n\t\n\t        /**\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var base = this.base;\n\t            start = mathLog(start) / mathLog(base);\n\t            end = mathLog(end) / mathLog(base);\n\t            intervalScaleProto.setExtent.call(this, start, end);\n\t        },\n\t\n\t        /**\n\t         * @return {number} end\n\t         */\n\t        getExtent: function () {\n\t            var base = this.base;\n\t            var extent = scaleProto.getExtent.call(this);\n\t            extent[0] = mathPow(base, extent[0]);\n\t            extent[1] = mathPow(base, extent[1]);\n\t\n\t            // Fix #4158\n\t            var originalScale = this._originalScale;\n\t            var originalExtent = originalScale.getExtent();\n\t            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n\t            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\t\n\t            return extent;\n\t        },\n\t\n\t        /**\n\t         * @param  {Array.<number>} extent\n\t         */\n\t        unionExtent: function (extent) {\n\t            this._originalScale.unionExtent(extent);\n\t\n\t            var base = this.base;\n\t            extent[0] = mathLog(extent[0]) / mathLog(base);\n\t            extent[1] = mathLog(extent[1]) / mathLog(base);\n\t            scaleProto.unionExtent.call(this, extent);\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        unionExtentFromData: function (data, dim) {\n\t            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n\t                return val > 0;\n\t            }));\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         * @param  {number} [approxTickNum = 10] Given approx tick number\n\t         */\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (span === Infinity || span <= 0) {\n\t                return;\n\t            }\n\t\n\t            var interval = numberUtil.quantity(span);\n\t            var err = approxTickNum / span * interval;\n\t\n\t            // Filter ticks to get closer to the desired count.\n\t            if (err <= 0.5) {\n\t                interval *= 10;\n\t            }\n\t\n\t            // Interval should be integer\n\t            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                interval *= 10;\n\t            }\n\t\n\t            var niceExtent = [\n\t                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t            ];\n\t\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [approxTickNum = 10] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\t\n\t            var originalScale = this._originalScale;\n\t            originalScale.__fixMin = fixMin;\n\t            originalScale.__fixMax = fixMax;\n\t        }\n\t\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t\n\t    function fixRoundingError(val, originalVal) {\n\t        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n\t    }\n\t\n\t    module.exports = LogScale;\n\n\n/***/ },\n/* 194 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Linear continuous scale\n\t * @module echarts/coord/scale/Ordinal\n\t *\n\t * http://en.wikipedia.org/wiki/Level_of_measurement\n\t */\n\t\n\t// FIXME only one data\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var Scale = __webpack_require__(35);\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    var OrdinalScale = Scale.extend({\n\t\n\t        type: 'ordinal',\n\t\n\t        init: function (data, extent) {\n\t            this._data = data;\n\t            this._extent = extent || [0, data.length - 1];\n\t        },\n\t\n\t        parse: function (val) {\n\t            return typeof val === 'string'\n\t                ? zrUtil.indexOf(this._data, val)\n\t                // val might be float.\n\t                : Math.round(val);\n\t        },\n\t\n\t        contain: function (rank) {\n\t            rank = this.parse(rank);\n\t            return scaleProto.contain.call(this, rank)\n\t                && this._data[rank] != null;\n\t        },\n\t\n\t        /**\n\t         * Normalize given rank or name to linear [0, 1]\n\t         * @param {number|string} [val]\n\t         * @return {number}\n\t         */\n\t        normalize: function (val) {\n\t            return scaleProto.normalize.call(this, this.parse(val));\n\t        },\n\t\n\t        scale: function (val) {\n\t            return Math.round(scaleProto.scale.call(this, val));\n\t        },\n\t\n\t        /**\n\t         * @return {Array}\n\t         */\n\t        getTicks: function () {\n\t            var ticks = [];\n\t            var extent = this._extent;\n\t            var rank = extent[0];\n\t\n\t            while (rank <= extent[1]) {\n\t                ticks.push(rank);\n\t                rank++;\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * Get item on rank n\n\t         * @param {number} n\n\t         * @return {string}\n\t         */\n\t        getLabel: function (n) {\n\t            return this._data[n];\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        count: function () {\n\t            return this._extent[1] - this._extent[0] + 1;\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        unionExtentFromData: function (data, dim) {\n\t            this.unionExtent(data.getDataExtent(dim, false));\n\t        },\n\t\n\t        niceTicks: zrUtil.noop,\n\t        niceExtent: zrUtil.noop\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t\n\t    module.exports = OrdinalScale;\n\n\n/***/ },\n/* 195 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/coord/scale/Time\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t    var numberUtil = __webpack_require__(4);\n\t    var formatUtil = __webpack_require__(9);\n\t\n\t    var IntervalScale = __webpack_require__(57);\n\t\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t\n\t    // FIXME \n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            }\n\t            else {\n\t                hi  = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t        type: 'time',\n\t\n\t        // Overwrite\n\t        getLabel: function (val) {\n\t            var stepLvl = this._stepLvl;\n\t\n\t            var date = new Date(val);\n\t\n\t            return formatUtil.formatTime(stepLvl[0], date);\n\t        },\n\t\n\t        // Overwrite\n\t        niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                // Expand extent\n\t                extent[0] -= ONE_DAY;\n\t                extent[1] += ONE_DAY;\n\t            }\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                var d = new Date();\n\t                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                extent[0] = extent[1] - ONE_DAY;\n\t            }\n\t\n\t            this.niceTicks(approxTickNum);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        },\n\t\n\t        // Overwrite\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            var approxInterval = span / approxTickNum;\n\t            var scaleLevelsLen = scaleLevels.length;\n\t            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t\n\t            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t            var interval = level[2];\n\t            // Same with interval scale if span is much larger than 1 year\n\t            if (level[0] === 'year') {\n\t                var yearSpan = span / interval;\n\t\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t\n\t                interval *= yearStep;\n\t            }\n\t\n\t            var niceExtent = [\n\t                mathCeil(extent[0] / interval) * interval,\n\t                mathFloor(extent[1] / interval) * interval\n\t            ];\n\t\n\t            this._stepLvl = level;\n\t            // Interval will be used in getTicks\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        parse: function (val) {\n\t            // val might be float.\n\t            return +numberUtil.parseDate(val);\n\t        }\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t        // Format       step    interval\n\t        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n\t        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n\t        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n\t        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n\t        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n\t        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n\t        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n\t        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n\t        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n\t        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n\t        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n\t        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n\t        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n\t        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n\t        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n\t        ['week',        7,      ONE_DAY * 7],        // 7d\n\t        ['month',       1,      ONE_DAY * 31],       // 1M\n\t        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n\t        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n\t        ['year',        1,      ONE_DAY * 380]       // 1Y\n\t    ];\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t\n\t    module.exports = TimeScale;\n\n\n/***/ },\n/* 196 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\n\t\n\t\n\t    var graphic = __webpack_require__(3);\n\t    var BoundingRect = __webpack_require__(14);\n\t\n\t    /**\n\t     * Triangle shape\n\t     * @inner\n\t     */\n\t    var Triangle = graphic.extendShape({\n\t        type: 'triangle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy + height);\n\t            path.lineTo(cx - width, cy + height);\n\t            path.closePath();\n\t        }\n\t    });\n\t    /**\n\t     * Diamond shape\n\t     * @inner\n\t     */\n\t    var Diamond = graphic.extendShape({\n\t        type: 'diamond',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy);\n\t            path.lineTo(cx, cy + height);\n\t            path.lineTo(cx - width, cy);\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pin shape\n\t     * @inner\n\t     */\n\t    var Pin = graphic.extendShape({\n\t        type: 'pin',\n\t        shape: {\n\t            // x, y on the cusp\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (path, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var w = shape.width / 5 * 3;\n\t            // Height must be larger than width\n\t            var h = Math.max(w, shape.height);\n\t            var r = w / 2;\n\t\n\t            // Dist on y with tangent point and circle center\n\t            var dy = r * r / (h - r);\n\t            var cy = y - h + r + dy;\n\t            var angle = Math.asin(dy / r);\n\t            // Dist on x with tangent point and circle center\n\t            var dx = Math.cos(angle) * r;\n\t\n\t            var tanX = Math.sin(angle);\n\t            var tanY = Math.cos(angle);\n\t\n\t            path.arc(\n\t                x, cy, r,\n\t                Math.PI - angle,\n\t                Math.PI * 2 + angle\n\t            );\n\t\n\t            var cpLen = r * 0.6;\n\t            var cpLen2 = r * 0.7;\n\t            path.bezierCurveTo(\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x, y - cpLen2,\n\t                x, y\n\t            );\n\t            path.bezierCurveTo(\n\t                x, y - cpLen2,\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x - dx, cy + dy\n\t            );\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Arrow shape\n\t     * @inner\n\t     */\n\t    var Arrow = graphic.extendShape({\n\t\n\t        type: 'arrow',\n\t\n\t        shape: {\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var height = shape.height;\n\t            var width = shape.width;\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var dx = width / 3 * 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(x + dx, y + height);\n\t            ctx.lineTo(x, y + height / 4 * 3);\n\t            ctx.lineTo(x - dx, y + height);\n\t            ctx.lineTo(x, y);\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Map of path contructors\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\n\t     */\n\t    var symbolCtors = {\n\t        line: graphic.Line,\n\t\n\t        rect: graphic.Rect,\n\t\n\t        roundRect: graphic.Rect,\n\t\n\t        square: graphic.Rect,\n\t\n\t        circle: graphic.Circle,\n\t\n\t        diamond: Diamond,\n\t\n\t        pin: Pin,\n\t\n\t        arrow: Arrow,\n\t\n\t        triangle: Triangle\n\t    };\n\t\n\t    var symbolShapeMakers = {\n\t\n\t        line: function (x, y, w, h, shape) {\n\t            // FIXME\n\t            shape.x1 = x;\n\t            shape.y1 = y + h / 2;\n\t            shape.x2 = x + w;\n\t            shape.y2 = y + h / 2;\n\t        },\n\t\n\t        rect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        roundRect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t            shape.r = Math.min(w, h) / 4;\n\t        },\n\t\n\t        square: function (x, y, w, h, shape) {\n\t            var size = Math.min(w, h);\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = size;\n\t            shape.height = size;\n\t        },\n\t\n\t        circle: function (x, y, w, h, shape) {\n\t            // Put circle in the center of square\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.r = Math.min(w, h) / 2;\n\t        },\n\t\n\t        diamond: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        pin: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        arrow: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        triangle: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        }\n\t    };\n\t\n\t    var symbolBuildProxies = {};\n\t    for (var name in symbolCtors) {\n\t        if (symbolCtors.hasOwnProperty(name)) {\n\t            symbolBuildProxies[name] = new symbolCtors[name]();\n\t        }\n\t    }\n\t\n\t    var Symbol = graphic.extendShape({\n\t\n\t        type: 'symbol',\n\t\n\t        shape: {\n\t            symbolType: '',\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            var style = this.style;\n\t            var shape = this.shape;\n\t            // FIXME\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n\t                style.textPosition = ['50%', '40%'];\n\t                style.textAlign = 'center';\n\t                style.textVerticalAlign = 'middle';\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            var symbolType = shape.symbolType;\n\t            var proxySymbol = symbolBuildProxies[symbolType];\n\t            if (shape.symbolType !== 'none') {\n\t                if (!proxySymbol) {\n\t                    // Default rect\n\t                    symbolType = 'rect';\n\t                    proxySymbol = symbolBuildProxies[symbolType];\n\t                }\n\t                symbolShapeMakers[symbolType](\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n\t                );\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n\t            }\n\t        }\n\t    });\n\t\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\t    var symbolPathSetColor = function (color) {\n\t        if (this.type !== 'image') {\n\t            var symbolStyle = this.style;\n\t            var symbolShape = this.shape;\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\n\t                symbolStyle.stroke = color;\n\t            }\n\t            else if (this.__isEmptyBrush) {\n\t                symbolStyle.stroke = color;\n\t                symbolStyle.fill = '#fff';\n\t            }\n\t            else {\n\t                // FIXME  onlyStroke ?\n\t                symbolStyle.fill && (symbolStyle.fill = color);\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\n\t            }\n\t            this.dirty(false);\n\t        }\n\t    };\n\t\n\t    var symbolUtil = {\n\t        /**\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n\t         * @param {string} symbolType\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {number} w\n\t         * @param {number} h\n\t         * @param {string} color\n\t         */\n\t        createSymbol: function (symbolType, x, y, w, h, color) {\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\n\t            if (isEmpty) {\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n\t            }\n\t            var symbolPath;\n\t\n\t            if (symbolType.indexOf('image://') === 0) {\n\t                symbolPath = new graphic.Image({\n\t                    style: {\n\t                        image: symbolType.slice(8),\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t            else if (symbolType.indexOf('path://') === 0) {\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n\t            }\n\t            else {\n\t                symbolPath = new Symbol({\n\t                    shape: {\n\t                        symbolType: symbolType,\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t\n\t            symbolPath.__isEmptyBrush = isEmpty;\n\t\n\t            symbolPath.setColor = symbolPathSetColor;\n\t\n\t            symbolPath.setColor(color);\n\t\n\t            return symbolPath;\n\t        }\n\t    };\n\t\n\t    module.exports = symbolUtil;\n\n\n/***/ },\n/* 197 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var lib = {};\n\t\n\t    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n\t    var RATE = '\\0__throttleRate';\n\t    var THROTTLE_TYPE = '\\0__throttleType';\n\t\n\t    /**\n\t     * @public\n\t     * @param {(Function)} fn\n\t     * @param {number} [delay=0] Unit: ms.\n\t     * @param {boolean} [debounce=false]\n\t     *        true: If call interval less than `delay`, only the last call works.\n\t     *        false: If call interval less than `delay, call works on fixed rate.\n\t     * @return {(Function)} throttled fn.\n\t     */\n\t    lib.throttle = function (fn, delay, debounce) {\n\t\n\t        var currCall;\n\t        var lastCall = 0;\n\t        var lastExec = 0;\n\t        var timer = null;\n\t        var diff;\n\t        var scope;\n\t        var args;\n\t\n\t        delay = delay || 0;\n\t\n\t        function exec() {\n\t            lastExec = (new Date()).getTime();\n\t            timer = null;\n\t            fn.apply(scope, args || []);\n\t        }\n\t\n\t        var cb = function () {\n\t            currCall = (new Date()).getTime();\n\t            scope = this;\n\t            args = arguments;\n\t            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\t\n\t            clearTimeout(timer);\n\t\n\t            if (debounce) {\n\t                timer = setTimeout(exec, delay);\n\t            }\n\t            else {\n\t                if (diff >= 0) {\n\t                    exec();\n\t                }\n\t                else {\n\t                    timer = setTimeout(exec, -diff);\n\t                }\n\t            }\n\t\n\t            lastCall = currCall;\n\t        };\n\t\n\t        /**\n\t         * Clear throttle.\n\t         * @public\n\t         */\n\t        cb.clear = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t        };\n\t\n\t        return cb;\n\t    };\n\t\n\t    /**\n\t     * Create throttle method or update throttle rate.\n\t     *\n\t     * @example\n\t     * ComponentView.prototype.render = function () {\n\t     *     ...\n\t     *     throttle.createOrUpdate(\n\t     *         this,\n\t     *         '_dispatchAction',\n\t     *         this.model.get('throttle'),\n\t     *         'fixRate'\n\t     *     );\n\t     * };\n\t     * ComponentView.prototype.remove = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     * ComponentView.prototype.dispose = function () {\n\t     *     throttle.clear(this, '_dispatchAction');\n\t     * };\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     * @param {number} [rate]\n\t     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n\t     * @return {Function} throttled function.\n\t     */\n\t    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n\t        var fn = obj[fnAttr];\n\t\n\t        if (!fn) {\n\t            return;\n\t        }\n\t\n\t        var originFn = fn[ORIGIN_METHOD] || fn;\n\t        var lastThrottleType = fn[THROTTLE_TYPE];\n\t        var lastRate = fn[RATE];\n\t\n\t        if (lastRate !== rate || lastThrottleType !== throttleType) {\n\t            if (rate == null || !throttleType) {\n\t                return (obj[fnAttr] = originFn);\n\t            }\n\t\n\t            fn = obj[fnAttr] = lib.throttle(\n\t                originFn, rate, throttleType === 'debounce'\n\t            );\n\t            fn[ORIGIN_METHOD] = originFn;\n\t            fn[THROTTLE_TYPE] = throttleType;\n\t            fn[RATE] = rate;\n\t        }\n\t\n\t        return fn;\n\t    };\n\t\n\t    /**\n\t     * Clear throttle. Example see throttle.createOrUpdate.\n\t     *\n\t     * @public\n\t     * @param {Object} obj\n\t     * @param {string} fnAttr\n\t     */\n\t    lib.clear = function (obj, fnAttr) {\n\t        var fn = obj[fnAttr];\n\t        if (fn && fn[ORIGIN_METHOD]) {\n\t            obj[fnAttr] = fn[ORIGIN_METHOD];\n\t        }\n\t    };\n\t\n\t    module.exports = lib;\n\t\n\n\n/***/ },\n/* 198 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Group = __webpack_require__(37);\n\t    var componentUtil = __webpack_require__(58);\n\t    var clazzUtil = __webpack_require__(15);\n\t\n\t    var Component = function () {\n\t        /**\n\t         * @type {module:zrender/container/Group}\n\t         * @readOnly\n\t         */\n\t        this.group = new Group();\n\t\n\t        /**\n\t         * @type {string}\n\t         * @readOnly\n\t         */\n\t        this.uid = componentUtil.getUID('viewComponent');\n\t    };\n\t\n\t    Component.prototype = {\n\t\n\t        constructor: Component,\n\t\n\t        init: function (ecModel, api) {},\n\t\n\t        render: function (componentModel, ecModel, api, payload) {},\n\t\n\t        dispose: function () {}\n\t\n\t    };\n\t\n\t    var componentProto = Component.prototype;\n\t    componentProto.updateView\n\t        = componentProto.updateLayout\n\t        = componentProto.updateVisual\n\t        = function (seriesModel, ecModel, api, payload) {\n\t            // Do nothing;\n\t        };\n\t    // Enable Component.extend.\n\t    clazzUtil.enableClassExtend(Component);\n\t\n\t    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n\t    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\t\n\t    module.exports = Component;\n\n\n/***/ },\n/* 199 */\n/***/ function(module, exports) {\n\n\t// Pick color from palette for each data item.\n\t// Applicable for charts that require applying color palette\n\t// in data level (like pie, funnel, chord).\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    var filteredIdx = idxMap[rawIdx];\n\t\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null\n\t                        && data.getItemVisual(filteredIdx, 'color', true);\n\t\n\t                    if (!singleDataColor) {\n\t                        // FIXME Performance\n\t                        var itemModel = dataAll.getItemModel(rawIdx);\n\t                        var color = itemModel.get('itemStyle.normal.color')\n\t                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n/* 200 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var Gradient = __webpack_require__(61);\n\t    module.exports = function (ecModel) {\n\t        function encodeColor(seriesModel) {\n\t            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n\t            var data = seriesModel.getData();\n\t            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n\t                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\t\n\t            // FIXME Set color function or use the platte color\n\t            data.setVisual('color', color);\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof color === 'function' && !(color instanceof Gradient)) {\n\t                    data.each(function (idx) {\n\t                        data.setItemVisual(\n\t                            idx, 'color', color(seriesModel.getDataParams(idx))\n\t                        );\n\t                    });\n\t                }\n\t\n\t                // itemStyle in each data item\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var color = itemModel.get(colorAccessPath, true);\n\t                    if (color != null) {\n\t                        data.setItemVisual(idx, 'color', color);\n\t                    }\n\t                });\n\t            }\n\t        }\n\t        ecModel.eachRawSeries(encodeColor);\n\t    };\n\n\n/***/ },\n/* 201 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var Draggable = __webpack_require__(236);\n\t\n\t    var Eventful = __webpack_require__(28);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta,\n\t            zrByTouch: event.zrByTouch\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n\t     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n\t     */\n\t    var Handler = function(storage, painter, proxy, painterRoot) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        this.painterRoot = painterRoot;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            // There might be some doms created by upper layer application\n\t            // at the same level of painter.getViewportRoot() (e.g., tooltip\n\t            // dom created by echarts), where 'globalout' event should not\n\t            // be triggered when mouse enters these doms. (But 'mouseout'\n\t            // should be triggered at the original hovered element as usual).\n\t            var element = event.toElement || event.relatedTarget;\n\t            var innerDom;\n\t            do {\n\t                element = element && element.parentNode;\n\t            }\n\t            while (element && element.nodeType != 9 && !(\n\t                innerDom = element === this.painterRoot\n\t            ));\n\t\n\t            !innerDom && this.trigger('globalout', {event: event});\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * cursor style\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @private\n\t         * @param {Object} targetEl \n\t         * @param {string} eventName \n\t         * @param {Object} event \n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                //  zrender \n\t                this.trigger(eventName, eventPacket);\n\t                // \n\t                //  click  dispose painter \n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 202 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var config = __webpack_require__(36);\n\t    var Style = __webpack_require__(95);\n\t    var Pattern = __webpack_require__(94);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id \n\t     * @param {string} type dom typesuch as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // append~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // \n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t            domStyle['padding'] = 0;\n\t            domStyle['margin'] = 0;\n\t            domStyle['border-width'] = 0;\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * \n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * \n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * alpha\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 203 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(36);\n\t    var util = __webpack_require__(1);\n\t    var log = __webpack_require__(92);\n\t    var BoundingRect = __webpack_require__(14);\n\t    var timsort = __webpack_require__(59);\n\t\n\t    var Layer = __webpack_require__(202);\n\t\n\t    var requestAnimationFrame = __webpack_require__(89);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t\n\t        // domRoot.onselectstart = returnFalse; // \n\t        domRoot.style.cssText = [\n\t            'position:relative',\n\t            'overflow:hidden',\n\t            'width:' + width + 'px',\n\t            'height:' + height + 'px',\n\t            'padding:0',\n\t            'margin:0',\n\t            'border-width:0'\n\t        ].join(';') + ';';\n\t\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root \n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        this._opts = opts = util.extend({}, opts || {});\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * \n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getSize(0);\n\t            this._height = this._getSize(1);\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t\n\t            this._domRoot = root;\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [paintAll=false] displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         *  zlevel \n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // \n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * hover\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * zlevel\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config \n\t         * @param {string} [config.clearColor=0] \n\t         * @param {string} [config.motionBlur=false] \n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 alpha\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            // Save input w/h\n\t            var opts = this._opts;\n\t            width != null && (opts.width = width);\n\t            height != null && (opts.height = height);\n\t\n\t            width = this._getSize(0);\n\t            height = this._getSize(1);\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    if (this._layers.hasOwnProperty(id)) {\n\t                        this._layers[id].resize(width, height);\n\t                    }\n\t                }\n\t                util.each(this._progressiveLayers, function (layer) {\n\t                    layer.resize(width, height);\n\t                });\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getSize: function (whIdx) {\n\t            var opts = this._opts;\n\t            var wh = ['width', 'height'][whIdx];\n\t            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n\t            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n\t            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\t\n\t            if (opts[wh] != null && opts[wh] !== 'auto') {\n\t                return parseFloat(opts[wh]);\n\t            }\n\t\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return (\n\t                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n\t                - (parseInt10(stl[plt]) || 0)\n\t                - (parseInt10(stl[prb]) || 0)\n\t            ) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(93);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 204 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var env = __webpack_require__(10);\n\t\n\t    var Group = __webpack_require__(37);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(59);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     *  (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // idmap\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} [update=false] \n\t         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n\t         *\n\t         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * GroupShapeShape\n\t         * zlevel > z > \n\t         * @param {boolean} [includeIgnore=false]  ignore \n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var userSetClipPath = el.clipPath;\n\t            if (userSetClipPath) {\n\t\n\t                // FIXME \n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                }\n\t                else {\n\t                    clipPaths = [];\n\t                }\n\t\n\t                var currentClipPath = userSetClipPath;\n\t                var parentClipPath = el;\n\t                // Recursively add clip path\n\t                while (currentClipPath) {\n\t                    // clipPath  clipPath \n\t                    currentClipPath.parent = parentClipPath;\n\t                    currentClipPath.updateTransform();\n\t\n\t                    clipPaths.push(currentClipPath);\n\t\n\t                    parentClipPath = currentClipPath;\n\t                    currentClipPath = currentClipPath.clipPath;\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * (Shape)(Group)\n\t         * @param {string|Array.<string>} [elId] Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // elId\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 205 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * , \n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(1);\n\t    var Dispatcher = __webpack_require__(39).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(89);\n\t\n\t    var Animator = __webpack_require__(88);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         *  clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         *  animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * \n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * \n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * animator\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] \n\t         * @param  {Function} [options.getter=null]\n\t         *         gettergetter\n\t         * @param  {Function} [options.setter=null]\n\t         *         settersetter\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            this.addAnimator(animator);\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 206 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @config target onframe\n\t * @config life(1000) \n\t * @config delay(0) \n\t * @config loop(true)\n\t * @config gap(0) \n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(207);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // \n\t        this._life = options.life || 1000;\n\t        // \n\t        this._delay = options.delay || 0;\n\t        // \n\t        // this._startTime = new Date().getTime() + this._delay;// \n\t        this._initialized = false;\n\t\n\t        // \n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // \n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // \n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // \n\t                    //  stage.update \n\t                    return 'restart';\n\t                }\n\t\n\t                // \n\t                // Animation.update\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 207 */\n/***/ function(module, exports) {\n\n\t/**\n\t *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // t^3\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // t^4\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // t^5\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // sin(t)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 2^t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // sqrt(1-t^2)\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // \n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 208 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(90).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 209 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(22);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 210 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 211 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(38).CMD;\n\t    var line = __webpack_require__(210);\n\t    var cubic = __webpack_require__(209);\n\t    var quadratic = __webpack_require__(212);\n\t    var arc = __webpack_require__(208);\n\t    var normalizeRadian = __webpack_require__(90).normalizeRadian;\n\t    var curve = __webpack_require__(22);\n\t\n\t    var windingLine = __webpack_require__(213);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // \n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // \n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc \n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                //  subpath \n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                //  L, C, Q\n\t                //  previous point  point\n\t                //\n\t                //  Arc \n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo  subpath, \n\t                    //  closePath \n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE  L, C, Q  NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc \n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc \n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    //  arc \n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // \n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr scale, x\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        //  subpath \n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 212 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(22);\n\t\n\t    module.exports = {\n\t        /**\n\t         * \n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 213 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 214 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(39);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch, {});\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 215 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 216 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(5);\n\t    var curve = __webpack_require__(22);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * `min``max`\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points \n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * (p0, p1, p2, p3)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * (p0, p1, p2)`min``max`\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * `min``max`\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 217 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(39);\n\t    var zrUtil = __webpack_require__(1);\n\t    var Eventful = __webpack_require__(28);\n\t    var env = __webpack_require__(10);\n\t    var GestureMgr = __webpack_require__(214);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    var pointerEventNames = {\n\t        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n\t    };\n\t\n\t    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n\t        var nm = name.replace('mouse', 'pointer');\n\t        return pointerEventNames[nm] ? nm : name;\n\t    });\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        // Do not do any preventDefault here. Upper application do that if necessary.\n\t        if (gestureInfo) {\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    // function onMSGestureChange(proxy, event) {\n\t    //     if (event.translationX || event.translationY) {\n\t    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n\t    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n\t    //     }\n\t    //     if (event.scale !== 1) {\n\t    //         event.pinchX = event.offsetX;\n\t    //         event.pinchY = event.offsetY;\n\t    //         event.pinchScale = event.scale;\n\t    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n\t    //     }\n\t    // }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // rootdommouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // In touch device, trigger `mousemove`(`mouseover`) should\n\t            // be triggered, and must before `mousedown` triggered.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            // Mark touch, which is useful in distinguish touch and\n\t            // mouse event in upper applicatoin.\n\t            event.zrByTouch = true;\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n\t            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n\t            // we can conveniently implement \"hover style\" in both PC and touch device just\n\t            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n\t            // to remove \"hover style\" on an element, without any additional code for\n\t            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n\t            // style\" will remain for user view)\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        pointerdown: function (event) {\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            // if (useMSGuesture(this, event)) {\n\t            //     this._msGesture.addPointer(event.pointerId);\n\t            // }\n\t        },\n\t\n\t        pointermove: function (event) {\n\t            // FIXME\n\t            // pointermove is so sensitive that it always triggered when\n\t            // tap(click) on touch screen, which affect some judgement in\n\t            // upper application. So, we dont support mousemove on MS touch\n\t            // device yet.\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mousemove.call(this, event);\n\t            }\n\t        },\n\t\n\t        pointerup: function (event) {\n\t            domHandlers.mouseup.call(this, event);\n\t        },\n\t\n\t        pointerout: function (event) {\n\t            // pointerout will be triggered when tap on touch screen\n\t            // (IE11+/Edge on MS Surface) after click event triggered,\n\t            // which is inconsistent with the mousout behavior we defined\n\t            // in touchend. So we unify them.\n\t            // (check domHandlers.touchend for detailed explanation)\n\t            if (!isPointerFromTouch(event)) {\n\t                domHandlers.mouseout.call(this, event);\n\t            }\n\t        }\n\t    };\n\t\n\t    function isPointerFromTouch(event) {\n\t        var pointerType = event.pointerType;\n\t        return pointerType === 'pen' || pointerType === 'touch';\n\t    }\n\t\n\t    // function useMSGuesture(handlerProxy, event) {\n\t    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n\t    // }\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * dom \n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance \n\t     */\n\t    function initDomHandler(instance) {\n\t        zrUtil.each(touchHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(pointerHandlerNames, function (name) {\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        });\n\t\n\t        zrUtil.each(mouseHandlerNames, function (name) {\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        });\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (env.pointerEventsSupported) { // Only IE11+/Edge\n\t            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n\t            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n\t            // at the same time.\n\t            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n\t            // screen, which do not occurs in pointer event.\n\t            // So we use pointer event to both detect touch gesture and mouse behavior.\n\t            mountHandlers(pointerHandlerNames, this);\n\t\n\t            // FIXME\n\t            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n\t            // which does not prevent defuault behavior occasionally (which may cause view port\n\t            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n\t            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n\t            // touch screen. And we only support click behavior on MS touch screen now.\n\t\n\t            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n\t            // We dont support touch on IE on win7.\n\t            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n\t            // if (typeof MSGesture === 'function') {\n\t            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n\t            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n\t            // }\n\t        }\n\t        else {\n\t            if (env.touchEventsSupported) {\n\t                mountHandlers(touchHandlerNames, this);\n\t                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t            }\n\t\n\t            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n\t            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t            // mouse event can not be handle in those devices.\n\t            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n\t            // mouseevent after touch event triggered, see `setTouchTimer`.\n\t            mountHandlers(mouseHandlerNames, this);\n\t        }\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 218 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CompoundPath to improve performance\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    module.exports = Path.extend({\n\t\n\t        type: 'compound',\n\t\n\t        shape: {\n\t\n\t            paths: null\n\t        },\n\t\n\t        _updatePathDirty: function () {\n\t            var dirtyPath = this.__dirtyPath;\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                // Mark as dirty if any subpath is dirty\n\t                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n\t            }\n\t            this.__dirtyPath = dirtyPath;\n\t            this.__dirty = this.__dirty || dirtyPath;\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            this._updatePathDirty();\n\t            var paths = this.shape.paths || [];\n\t            var scale = this.getGlobalScale();\n\t            // Update path scale\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].path.setScale(scale[0], scale[1]);\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var paths = shape.paths || [];\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].buildPath(ctx, paths[i].shape, true);\n\t            }\n\t        },\n\t\n\t        afterBrush: function () {\n\t            var paths = this.shape.paths;\n\t            for (var i = 0; i < paths.length; i++) {\n\t                paths[i].__dirtyPath = false;\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            this._updatePathDirty();\n\t            return Path.prototype.getBoundingRect.call(this);\n\t        }\n\t    });\n\n\n/***/ },\n/* 219 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Gradient = __webpack_require__(61);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 220 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Gradient = __webpack_require__(61);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 221 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(60);\n\t    var zrUtil = __webpack_require__(1);\n\t    var textContain = __webpack_require__(21);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 222 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 223 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(5);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * \n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points \n\t     * @param {number} smooth , 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint \n\t     *                            [[0, 0], [100, 100]], \n\t     *                           \n\t     * @param {Array} \n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // \n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 224 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline \n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(5);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points \n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 225 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(21);\n\t    var BoundingRect = __webpack_require__(14);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var textOffset = style.textOffset;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            if (textOffset) {\n\t                x += textOffset[0];\n\t                y += textOffset[1];\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 226 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 227 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(22);\n\t    var vec2 = __webpack_require__(5);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 228 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 229 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 230 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(96);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 231 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(96);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 232 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(222);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // r1r2r3r4\n\t            // r1          [1, 1, 1, 1]\n\t            // r[1]        [1, 1, 1, 1]\n\t            // r[1, 2]     [1, 2, 1, 2]\n\t            // r[1, 2, 3]  [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 233 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 234 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    var env = __webpack_require__(10);\n\t    var Path = __webpack_require__(6);\n\t\n\t    var shadowTemp = [\n\t        ['shadowBlur', 0],\n\t        ['shadowColor', '#000'],\n\t        ['shadowOffsetX', 0],\n\t        ['shadowOffsetY', 0]\n\t    ];\n\t\n\t    module.exports = Path.extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n\t            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n\t            // where exception \"unexpected call to method or property access\"\n\t            // might be thrown when calling ctx.fill after a path whose area size\n\t            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n\t            // (e.g.,\n\t            //  ctx.moveTo(10, 10);\n\t            //  ctx.lineTo(20, 10);\n\t            //  ctx.closePath();\n\t            //  ctx.clip();\n\t            //  ctx.shadowBlur = 10;\n\t            //  ...\n\t            //  ctx.fill();\n\t            // )\n\t            ? function () {\n\t                var clipPaths = this.__clipPaths;\n\t                var style = this.style;\n\t                var modified;\n\t\n\t                if (clipPaths) {\n\t                    for (var i = 0; i < clipPaths.length; i++) {\n\t                        var shape = clipPaths[i] && clipPaths[i].shape;\n\t                        if (shape && shape.startAngle === shape.endAngle) {\n\t                            for (var j = 0; j < shadowTemp.length; j++) {\n\t                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n\t                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n\t                            }\n\t                            modified = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                Path.prototype.brush.apply(this, arguments);\n\t\n\t                if (modified) {\n\t                    for (var j = 0; j < shadowTemp.length; j++) {\n\t                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n\t                    }\n\t                }\n\t            }\n\t            : Path.prototype.brush,\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 235 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(88);\n\t    var util = __webpack_require__(1);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(92);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * \n\t         *\n\t         * @param {string} path a.b.c\n\t         * @param {boolean} [loop] \n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (!target.hasOwnProperty(name)) {\n\t                    continue;\n\t                }\n\t\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 236 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 237 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * \n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(27);\n\t    var vector = __webpack_require__(5);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * \n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * \n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * \n\t     * , position, rotation, scaletransformtransform\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // \n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // \n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * transformcontext\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * `transform``position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     *  shape \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * \n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 238 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(38);\n\t    var transformPath = __webpack_require__(239);\n\t    var matrix = __webpack_require__(27);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 239 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(38).CMD;\n\t    var vec2 = __webpack_require__(5);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 240 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(91);\n\t    var env = __webpack_require__(10);\n\t    var zrUtil = __webpack_require__(1);\n\t\n\t    var Handler = __webpack_require__(201);\n\t    var Storage = __webpack_require__(204);\n\t    var Animation = __webpack_require__(205);\n\t    var HandlerProxy = __webpack_require__(217);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(203)\n\t    };\n\t\n\t    var instances = {};    // ZRendermap\n\t\n\t    var zrender = {};\n\t\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.3.0';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                if (instances.hasOwnProperty(key)) {\n\t                    instances[key].dispose();\n\t                }\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n\t     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: zrUtil.bind(this.flush, this)\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        //  storage.delFromMap, \n\t        // FIXME ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * \n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * \n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Perform all refresh\n\t         */\n\t        flush: function () {\n\t            if (this._needsRefresh) {\n\t                this.refreshImmediately();\n\t            }\n\t            if (this._needsRefreshHover) {\n\t                this.refreshHoverImmediately();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         * @param {Object} [opts]\n\t         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n\t         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n\t         */\n\t        resize: function(opts) {\n\t            opts = opts || {};\n\t            this.painter.resize(opts.width, opts.height);\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default']  crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 241 */,\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */,\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */,\n/* 252 */,\n/* 253 */,\n/* 254 */,\n/* 255 */,\n/* 256 */,\n/* 257 */,\n/* 258 */,\n/* 259 */,\n/* 260 */,\n/* 261 */,\n/* 262 */,\n/* 263 */,\n/* 264 */,\n/* 265 */,\n/* 266 */,\n/* 267 */,\n/* 268 */,\n/* 269 */,\n/* 270 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t  * vue-router v2.2.0\n\t  * (c) 2017 Evan You\n\t  * @license MIT\n\t  */\n\t'use strict';\n\t\n\t/*  */\n\t\n\tfunction assert (condition, message) {\n\t  if (!condition) {\n\t    throw new Error((\"[vue-router] \" + message))\n\t  }\n\t}\n\t\n\tfunction warn (condition, message) {\n\t  if (!condition) {\n\t    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n\t  }\n\t}\n\t\n\tvar View = {\n\t  name: 'router-view',\n\t  functional: true,\n\t  props: {\n\t    name: {\n\t      type: String,\n\t      default: 'default'\n\t    }\n\t  },\n\t  render: function render (h, ref) {\n\t    var props = ref.props;\n\t    var children = ref.children;\n\t    var parent = ref.parent;\n\t    var data = ref.data;\n\t\n\t    data.routerView = true;\n\t\n\t    var name = props.name;\n\t    var route = parent.$route;\n\t    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\t\n\t    // determine current view depth, also check to see if the tree\n\t    // has been toggled inactive but kept-alive.\n\t    var depth = 0;\n\t    var inactive = false;\n\t    while (parent) {\n\t      if (parent.$vnode && parent.$vnode.data.routerView) {\n\t        depth++;\n\t      }\n\t      if (parent._inactive) {\n\t        inactive = true;\n\t      }\n\t      parent = parent.$parent;\n\t    }\n\t    data.routerViewDepth = depth;\n\t\n\t    // render previous view if the tree is inactive and kept-alive\n\t    if (inactive) {\n\t      return h(cache[name], data, children)\n\t    }\n\t\n\t    var matched = route.matched[depth];\n\t    // render empty node if no matched route\n\t    if (!matched) {\n\t      cache[name] = null;\n\t      return h()\n\t    }\n\t\n\t    var component = cache[name] = matched.components[name];\n\t\n\t    // inject instance registration hooks\n\t    var hooks = data.hook || (data.hook = {});\n\t    hooks.init = function (vnode) {\n\t      matched.instances[name] = vnode.child;\n\t    };\n\t    hooks.prepatch = function (oldVnode, vnode) {\n\t      matched.instances[name] = vnode.child;\n\t    };\n\t    hooks.destroy = function (vnode) {\n\t      if (matched.instances[name] === vnode.child) {\n\t        matched.instances[name] = undefined;\n\t      }\n\t    };\n\t\n\t    // resolve props\n\t    data.props = resolveProps(route, matched.props && matched.props[name]);\n\t\n\t    return h(component, data, children)\n\t  }\n\t};\n\t\n\tfunction resolveProps (route, config) {\n\t  switch (typeof config) {\n\t    case 'undefined':\n\t      return\n\t    case 'object':\n\t      return config\n\t    case 'function':\n\t      return config(route)\n\t    case 'boolean':\n\t      return config ? route.params : undefined\n\t    default:\n\t      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar encodeReserveRE = /[!'()*]/g;\n\tvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\n\tvar commaRE = /%2C/g;\n\t\n\t// fixed encodeURIComponent which is more comformant to RFC3986:\n\t// - escapes [!'()*]\n\t// - preserve commas\n\tvar encode = function (str) { return encodeURIComponent(str)\n\t  .replace(encodeReserveRE, encodeReserveReplacer)\n\t  .replace(commaRE, ','); };\n\t\n\tvar decode = decodeURIComponent;\n\t\n\tfunction resolveQuery (\n\t  query,\n\t  extraQuery\n\t) {\n\t  if ( extraQuery === void 0 ) extraQuery = {};\n\t\n\t  if (query) {\n\t    var parsedQuery;\n\t    try {\n\t      parsedQuery = parseQuery(query);\n\t    } catch (e) {\n\t      (\"production\") !== 'production' && warn(false, e.message);\n\t      parsedQuery = {};\n\t    }\n\t    for (var key in extraQuery) {\n\t      parsedQuery[key] = extraQuery[key];\n\t    }\n\t    return parsedQuery\n\t  } else {\n\t    return extraQuery\n\t  }\n\t}\n\t\n\tfunction parseQuery (query) {\n\t  var res = {};\n\t\n\t  query = query.trim().replace(/^(\\?|#|&)/, '');\n\t\n\t  if (!query) {\n\t    return res\n\t  }\n\t\n\t  query.split('&').forEach(function (param) {\n\t    var parts = param.replace(/\\+/g, ' ').split('=');\n\t    var key = decode(parts.shift());\n\t    var val = parts.length > 0\n\t      ? decode(parts.join('='))\n\t      : null;\n\t\n\t    if (res[key] === undefined) {\n\t      res[key] = val;\n\t    } else if (Array.isArray(res[key])) {\n\t      res[key].push(val);\n\t    } else {\n\t      res[key] = [res[key], val];\n\t    }\n\t  });\n\t\n\t  return res\n\t}\n\t\n\tfunction stringifyQuery (obj) {\n\t  var res = obj ? Object.keys(obj).map(function (key) {\n\t    var val = obj[key];\n\t\n\t    if (val === undefined) {\n\t      return ''\n\t    }\n\t\n\t    if (val === null) {\n\t      return encode(key)\n\t    }\n\t\n\t    if (Array.isArray(val)) {\n\t      var result = [];\n\t      val.slice().forEach(function (val2) {\n\t        if (val2 === undefined) {\n\t          return\n\t        }\n\t        if (val2 === null) {\n\t          result.push(encode(key));\n\t        } else {\n\t          result.push(encode(key) + '=' + encode(val2));\n\t        }\n\t      });\n\t      return result.join('&')\n\t    }\n\t\n\t    return encode(key) + '=' + encode(val)\n\t  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n\t  return res ? (\"?\" + res) : ''\n\t}\n\t\n\t/*  */\n\t\n\tvar trailingSlashRE = /\\/?$/;\n\t\n\tfunction createRoute (\n\t  record,\n\t  location,\n\t  redirectedFrom\n\t) {\n\t  var route = {\n\t    name: location.name || (record && record.name),\n\t    meta: (record && record.meta) || {},\n\t    path: location.path || '/',\n\t    hash: location.hash || '',\n\t    query: location.query || {},\n\t    params: location.params || {},\n\t    fullPath: getFullPath(location),\n\t    matched: record ? formatMatch(record) : []\n\t  };\n\t  if (redirectedFrom) {\n\t    route.redirectedFrom = getFullPath(redirectedFrom);\n\t  }\n\t  return Object.freeze(route)\n\t}\n\t\n\t// the starting route that represents the initial state\n\tvar START = createRoute(null, {\n\t  path: '/'\n\t});\n\t\n\tfunction formatMatch (record) {\n\t  var res = [];\n\t  while (record) {\n\t    res.unshift(record);\n\t    record = record.parent;\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getFullPath (ref) {\n\t  var path = ref.path;\n\t  var query = ref.query; if ( query === void 0 ) query = {};\n\t  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\t\n\t  return (path || '/') + stringifyQuery(query) + hash\n\t}\n\t\n\tfunction isSameRoute (a, b) {\n\t  if (b === START) {\n\t    return a === b\n\t  } else if (!b) {\n\t    return false\n\t  } else if (a.path && b.path) {\n\t    return (\n\t      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query)\n\t    )\n\t  } else if (a.name && b.name) {\n\t    return (\n\t      a.name === b.name &&\n\t      a.hash === b.hash &&\n\t      isObjectEqual(a.query, b.query) &&\n\t      isObjectEqual(a.params, b.params)\n\t    )\n\t  } else {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction isObjectEqual (a, b) {\n\t  if ( a === void 0 ) a = {};\n\t  if ( b === void 0 ) b = {};\n\t\n\t  var aKeys = Object.keys(a);\n\t  var bKeys = Object.keys(b);\n\t  if (aKeys.length !== bKeys.length) {\n\t    return false\n\t  }\n\t  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n\t}\n\t\n\tfunction isIncludedRoute (current, target) {\n\t  return (\n\t    current.path.replace(trailingSlashRE, '/').indexOf(\n\t      target.path.replace(trailingSlashRE, '/')\n\t    ) === 0 &&\n\t    (!target.hash || current.hash === target.hash) &&\n\t    queryIncludes(current.query, target.query)\n\t  )\n\t}\n\t\n\tfunction queryIncludes (current, target) {\n\t  for (var key in target) {\n\t    if (!(key in current)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\t/*  */\n\t\n\t// work around weird flow bug\n\tvar toTypes = [String, Object];\n\tvar eventTypes = [String, Array];\n\t\n\tvar Link = {\n\t  name: 'router-link',\n\t  props: {\n\t    to: {\n\t      type: toTypes,\n\t      required: true\n\t    },\n\t    tag: {\n\t      type: String,\n\t      default: 'a'\n\t    },\n\t    exact: Boolean,\n\t    append: Boolean,\n\t    replace: Boolean,\n\t    activeClass: String,\n\t    event: {\n\t      type: eventTypes,\n\t      default: 'click'\n\t    }\n\t  },\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var router = this.$router;\n\t    var current = this.$route;\n\t    var ref = router.resolve(this.to, current, this.append);\n\t    var location = ref.location;\n\t    var route = ref.route;\n\t    var href = ref.href;\n\t    var classes = {};\n\t    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n\t    var compareTarget = location.path ? createRoute(null, location) : route;\n\t    classes[activeClass] = this.exact\n\t      ? isSameRoute(current, compareTarget)\n\t      : isIncludedRoute(current, compareTarget);\n\t\n\t    var handler = function (e) {\n\t      if (guardEvent(e)) {\n\t        if (this$1.replace) {\n\t          router.replace(location);\n\t        } else {\n\t          router.push(location);\n\t        }\n\t      }\n\t    };\n\t\n\t    var on = { click: guardEvent };\n\t    if (Array.isArray(this.event)) {\n\t      this.event.forEach(function (e) { on[e] = handler; });\n\t    } else {\n\t      on[this.event] = handler;\n\t    }\n\t\n\t    var data = {\n\t      class: classes\n\t    };\n\t\n\t    if (this.tag === 'a') {\n\t      data.on = on;\n\t      data.attrs = { href: href };\n\t    } else {\n\t      // find the first <a> child and apply listener and href\n\t      var a = findAnchor(this.$slots.default);\n\t      if (a) {\n\t        // in case the <a> is a static node\n\t        a.isStatic = false;\n\t        var extend = _Vue.util.extend;\n\t        var aData = a.data = extend({}, a.data);\n\t        aData.on = on;\n\t        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n\t        aAttrs.href = href;\n\t      } else {\n\t        // doesn't have <a> child, apply listener to self\n\t        data.on = on;\n\t      }\n\t    }\n\t\n\t    return h(this.tag, data, this.$slots.default)\n\t  }\n\t};\n\t\n\tfunction guardEvent (e) {\n\t  // don't redirect with control keys\n\t  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n\t  // don't redirect when preventDefault called\n\t  if (e.defaultPrevented) { return }\n\t  // don't redirect on right click\n\t  if (e.button !== undefined && e.button !== 0) { return }\n\t  // don't redirect if `target=\"_blank\"`\n\t  if (e.target && e.target.getAttribute) {\n\t    var target = e.target.getAttribute('target');\n\t    if (/\\b_blank\\b/i.test(target)) { return }\n\t  }\n\t  // this may be a Weex event which doesn't have this method\n\t  if (e.preventDefault) {\n\t    e.preventDefault();\n\t  }\n\t  return true\n\t}\n\t\n\tfunction findAnchor (children) {\n\t  if (children) {\n\t    var child;\n\t    for (var i = 0; i < children.length; i++) {\n\t      child = children[i];\n\t      if (child.tag === 'a') {\n\t        return child\n\t      }\n\t      if (child.children && (child = findAnchor(child.children))) {\n\t        return child\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar _Vue;\n\t\n\tfunction install (Vue) {\n\t  if (install.installed) { return }\n\t  install.installed = true;\n\t\n\t  _Vue = Vue;\n\t\n\t  Object.defineProperty(Vue.prototype, '$router', {\n\t    get: function get () { return this.$root._router }\n\t  });\n\t\n\t  Object.defineProperty(Vue.prototype, '$route', {\n\t    get: function get () { return this.$root._route }\n\t  });\n\t\n\t  Vue.mixin({\n\t    beforeCreate: function beforeCreate () {\n\t      if (this.$options.router) {\n\t        this._router = this.$options.router;\n\t        this._router.init(this);\n\t        Vue.util.defineReactive(this, '_route', this._router.history.current);\n\t      }\n\t    }\n\t  });\n\t\n\t  Vue.component('router-view', View);\n\t  Vue.component('router-link', Link);\n\t\n\t  var strats = Vue.config.optionMergeStrategies;\n\t  // use the same hook merging strategy for route hooks\n\t  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n\t}\n\t\n\t/*  */\n\t\n\tvar inBrowser = typeof window !== 'undefined';\n\t\n\t/*  */\n\t\n\tfunction resolvePath (\n\t  relative,\n\t  base,\n\t  append\n\t) {\n\t  if (relative.charAt(0) === '/') {\n\t    return relative\n\t  }\n\t\n\t  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n\t    return base + relative\n\t  }\n\t\n\t  var stack = base.split('/');\n\t\n\t  // remove trailing segment if:\n\t  // - not appending\n\t  // - appending to trailing slash (last segment is empty)\n\t  if (!append || !stack[stack.length - 1]) {\n\t    stack.pop();\n\t  }\n\t\n\t  // resolve relative path\n\t  var segments = relative.replace(/^\\//, '').split('/');\n\t  for (var i = 0; i < segments.length; i++) {\n\t    var segment = segments[i];\n\t    if (segment === '.') {\n\t      continue\n\t    } else if (segment === '..') {\n\t      stack.pop();\n\t    } else {\n\t      stack.push(segment);\n\t    }\n\t  }\n\t\n\t  // ensure leading slash\n\t  if (stack[0] !== '') {\n\t    stack.unshift('');\n\t  }\n\t\n\t  return stack.join('/')\n\t}\n\t\n\tfunction parsePath (path) {\n\t  var hash = '';\n\t  var query = '';\n\t\n\t  var hashIndex = path.indexOf('#');\n\t  if (hashIndex >= 0) {\n\t    hash = path.slice(hashIndex);\n\t    path = path.slice(0, hashIndex);\n\t  }\n\t\n\t  var queryIndex = path.indexOf('?');\n\t  if (queryIndex >= 0) {\n\t    query = path.slice(queryIndex + 1);\n\t    path = path.slice(0, queryIndex);\n\t  }\n\t\n\t  return {\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\t\n\tfunction cleanPath (path) {\n\t  return path.replace(/\\/\\//g, '/')\n\t}\n\t\n\t/*  */\n\t\n\tfunction createRouteMap (\n\t  routes,\n\t  oldPathMap,\n\t  oldNameMap\n\t) {\n\t  var pathMap = oldPathMap || Object.create(null);\n\t  var nameMap = oldNameMap || Object.create(null);\n\t\n\t  routes.forEach(function (route) {\n\t    addRouteRecord(pathMap, nameMap, route);\n\t  });\n\t\n\t  return {\n\t    pathMap: pathMap,\n\t    nameMap: nameMap\n\t  }\n\t}\n\t\n\tfunction addRouteRecord (\n\t  pathMap,\n\t  nameMap,\n\t  route,\n\t  parent,\n\t  matchAs\n\t) {\n\t  var path = route.path;\n\t  var name = route.name;\n\t  if (false) {\n\t    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n\t    assert(\n\t      typeof route.component !== 'string',\n\t      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n\t      \"string id. Use an actual component instead.\"\n\t    );\n\t  }\n\t\n\t  var record = {\n\t    path: normalizePath(path, parent),\n\t    components: route.components || { default: route.component },\n\t    instances: {},\n\t    name: name,\n\t    parent: parent,\n\t    matchAs: matchAs,\n\t    redirect: route.redirect,\n\t    beforeEnter: route.beforeEnter,\n\t    meta: route.meta || {},\n\t    props: route.props == null\n\t      ? {}\n\t      : route.components\n\t        ? route.props\n\t        : { default: route.props }\n\t  };\n\t\n\t  if (route.children) {\n\t    // Warn if route is named and has a default child route.\n\t    // If users navigate to this route by name, the default child will\n\t    // not be rendered (GH Issue #629)\n\t    if (false) {\n\t      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n\t        warn(\n\t          false,\n\t          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n\t          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n\t          \"the default child route will not be rendered. Remove the name from \" +\n\t          \"this route and use the name of the default child route for named \" +\n\t          \"links instead.\"\n\t        );\n\t      }\n\t    }\n\t    route.children.forEach(function (child) {\n\t      var childMatchAs = matchAs\n\t        ? cleanPath((matchAs + \"/\" + (child.path)))\n\t        : undefined;\n\t      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n\t    });\n\t  }\n\t\n\t  if (route.alias !== undefined) {\n\t    if (Array.isArray(route.alias)) {\n\t      route.alias.forEach(function (alias) {\n\t        var aliasRoute = {\n\t          path: alias,\n\t          children: route.children\n\t        };\n\t        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n\t      });\n\t    } else {\n\t      var aliasRoute = {\n\t        path: route.alias,\n\t        children: route.children\n\t      };\n\t      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n\t    }\n\t  }\n\t\n\t  if (!pathMap[record.path]) {\n\t    pathMap[record.path] = record;\n\t  }\n\t\n\t  if (name) {\n\t    if (!nameMap[name]) {\n\t      nameMap[name] = record;\n\t    } else if (false) {\n\t      warn(\n\t        false,\n\t        \"Duplicate named routes definition: \" +\n\t        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\tfunction normalizePath (path, parent) {\n\t  path = path.replace(/\\/$/, '');\n\t  if (path[0] === '/') { return path }\n\t  if (parent == null) { return path }\n\t  return cleanPath(((parent.path) + \"/\" + path))\n\t}\n\t\n\tvar index$1 = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\t\n\tvar isarray = index$1;\n\t\n\t/**\n\t * Expose `pathToRegexp`.\n\t */\n\tvar index = pathToRegexp;\n\tvar parse_1 = parse;\n\tvar compile_1 = compile;\n\tvar tokensToFunction_1 = tokensToFunction;\n\tvar tokensToRegExp_1 = tokensToRegExp;\n\t\n\t/**\n\t * The main path matching regexp utility.\n\t *\n\t * @type {RegExp}\n\t */\n\tvar PATH_REGEXP = new RegExp([\n\t  // Match escaped characters that would otherwise appear in future matches.\n\t  // This allows the user to escape special characters that won't transform.\n\t  '(\\\\\\\\.)',\n\t  // Match Express-style parameters and un-named parameters with a prefix\n\t  // and optional suffixes. Matches appear as:\n\t  //\n\t  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n\t  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n\t  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n\t  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n\t].join('|'), 'g');\n\t\n\t/**\n\t * Parse a string for the raw tokens.\n\t *\n\t * @param  {string}  str\n\t * @param  {Object=} options\n\t * @return {!Array}\n\t */\n\tfunction parse (str, options) {\n\t  var tokens = [];\n\t  var key = 0;\n\t  var index = 0;\n\t  var path = '';\n\t  var defaultDelimiter = options && options.delimiter || '/';\n\t  var res;\n\t\n\t  while ((res = PATH_REGEXP.exec(str)) != null) {\n\t    var m = res[0];\n\t    var escaped = res[1];\n\t    var offset = res.index;\n\t    path += str.slice(index, offset);\n\t    index = offset + m.length;\n\t\n\t    // Ignore already escaped sequences.\n\t    if (escaped) {\n\t      path += escaped[1];\n\t      continue\n\t    }\n\t\n\t    var next = str[index];\n\t    var prefix = res[2];\n\t    var name = res[3];\n\t    var capture = res[4];\n\t    var group = res[5];\n\t    var modifier = res[6];\n\t    var asterisk = res[7];\n\t\n\t    // Push the current path onto the tokens.\n\t    if (path) {\n\t      tokens.push(path);\n\t      path = '';\n\t    }\n\t\n\t    var partial = prefix != null && next != null && next !== prefix;\n\t    var repeat = modifier === '+' || modifier === '*';\n\t    var optional = modifier === '?' || modifier === '*';\n\t    var delimiter = res[2] || defaultDelimiter;\n\t    var pattern = capture || group;\n\t\n\t    tokens.push({\n\t      name: name || key++,\n\t      prefix: prefix || '',\n\t      delimiter: delimiter,\n\t      optional: optional,\n\t      repeat: repeat,\n\t      partial: partial,\n\t      asterisk: !!asterisk,\n\t      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n\t    });\n\t  }\n\t\n\t  // Match any characters still remaining.\n\t  if (index < str.length) {\n\t    path += str.substr(index);\n\t  }\n\t\n\t  // If the path exists, push it onto the end.\n\t  if (path) {\n\t    tokens.push(path);\n\t  }\n\t\n\t  return tokens\n\t}\n\t\n\t/**\n\t * Compile a string to a template function for the path.\n\t *\n\t * @param  {string}             str\n\t * @param  {Object=}            options\n\t * @return {!function(Object=, Object=)}\n\t */\n\tfunction compile (str, options) {\n\t  return tokensToFunction(parse(str, options))\n\t}\n\t\n\t/**\n\t * Prettier encoding of URI path segments.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeURIComponentPretty (str) {\n\t  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n\t *\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tfunction encodeAsterisk (str) {\n\t  return encodeURI(str).replace(/[?#]/g, function (c) {\n\t    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n\t  })\n\t}\n\t\n\t/**\n\t * Expose a method for transforming tokens into the path function.\n\t */\n\tfunction tokensToFunction (tokens) {\n\t  // Compile all the tokens into regexps.\n\t  var matches = new Array(tokens.length);\n\t\n\t  // Compile all the patterns before compilation.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    if (typeof tokens[i] === 'object') {\n\t      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n\t    }\n\t  }\n\t\n\t  return function (obj, opts) {\n\t    var path = '';\n\t    var data = obj || {};\n\t    var options = opts || {};\n\t    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\t\n\t    for (var i = 0; i < tokens.length; i++) {\n\t      var token = tokens[i];\n\t\n\t      if (typeof token === 'string') {\n\t        path += token;\n\t\n\t        continue\n\t      }\n\t\n\t      var value = data[token.name];\n\t      var segment;\n\t\n\t      if (value == null) {\n\t        if (token.optional) {\n\t          // Prepend partial segment prefixes.\n\t          if (token.partial) {\n\t            path += token.prefix;\n\t          }\n\t\n\t          continue\n\t        } else {\n\t          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n\t        }\n\t      }\n\t\n\t      if (isarray(value)) {\n\t        if (!token.repeat) {\n\t          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n\t        }\n\t\n\t        if (value.length === 0) {\n\t          if (token.optional) {\n\t            continue\n\t          } else {\n\t            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n\t          }\n\t        }\n\t\n\t        for (var j = 0; j < value.length; j++) {\n\t          segment = encode(value[j]);\n\t\n\t          if (!matches[i].test(segment)) {\n\t            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n\t          }\n\t\n\t          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n\t        }\n\t\n\t        continue\n\t      }\n\t\n\t      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\t\n\t      if (!matches[i].test(segment)) {\n\t        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n\t      }\n\t\n\t      path += token.prefix + segment;\n\t    }\n\t\n\t    return path\n\t  }\n\t}\n\t\n\t/**\n\t * Escape a regular expression string.\n\t *\n\t * @param  {string} str\n\t * @return {string}\n\t */\n\tfunction escapeString (str) {\n\t  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Escape the capturing group by escaping special characters and meaning.\n\t *\n\t * @param  {string} group\n\t * @return {string}\n\t */\n\tfunction escapeGroup (group) {\n\t  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n\t}\n\t\n\t/**\n\t * Attach the keys as a property of the regexp.\n\t *\n\t * @param  {!RegExp} re\n\t * @param  {Array}   keys\n\t * @return {!RegExp}\n\t */\n\tfunction attachKeys (re, keys) {\n\t  re.keys = keys;\n\t  return re\n\t}\n\t\n\t/**\n\t * Get the flags for a regexp from the options.\n\t *\n\t * @param  {Object} options\n\t * @return {string}\n\t */\n\tfunction flags (options) {\n\t  return options.sensitive ? '' : 'i'\n\t}\n\t\n\t/**\n\t * Pull out keys from a regexp.\n\t *\n\t * @param  {!RegExp} path\n\t * @param  {!Array}  keys\n\t * @return {!RegExp}\n\t */\n\tfunction regexpToRegexp (path, keys) {\n\t  // Use a negative lookahead to match only capturing groups.\n\t  var groups = path.source.match(/\\((?!\\?)/g);\n\t\n\t  if (groups) {\n\t    for (var i = 0; i < groups.length; i++) {\n\t      keys.push({\n\t        name: i,\n\t        prefix: null,\n\t        delimiter: null,\n\t        optional: false,\n\t        repeat: false,\n\t        partial: false,\n\t        asterisk: false,\n\t        pattern: null\n\t      });\n\t    }\n\t  }\n\t\n\t  return attachKeys(path, keys)\n\t}\n\t\n\t/**\n\t * Transform an array into a regexp.\n\t *\n\t * @param  {!Array}  path\n\t * @param  {Array}   keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction arrayToRegexp (path, keys, options) {\n\t  var parts = [];\n\t\n\t  for (var i = 0; i < path.length; i++) {\n\t    parts.push(pathToRegexp(path[i], keys, options).source);\n\t  }\n\t\n\t  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\t\n\t  return attachKeys(regexp, keys)\n\t}\n\t\n\t/**\n\t * Create a path regexp from string input.\n\t *\n\t * @param  {string}  path\n\t * @param  {!Array}  keys\n\t * @param  {!Object} options\n\t * @return {!RegExp}\n\t */\n\tfunction stringToRegexp (path, keys, options) {\n\t  return tokensToRegExp(parse(path, options), keys, options)\n\t}\n\t\n\t/**\n\t * Expose a function for taking tokens and returning a RegExp.\n\t *\n\t * @param  {!Array}          tokens\n\t * @param  {(Array|Object)=} keys\n\t * @param  {Object=}         options\n\t * @return {!RegExp}\n\t */\n\tfunction tokensToRegExp (tokens, keys, options) {\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys || options);\n\t    keys = [];\n\t  }\n\t\n\t  options = options || {};\n\t\n\t  var strict = options.strict;\n\t  var end = options.end !== false;\n\t  var route = '';\n\t\n\t  // Iterate over the tokens and create our regexp string.\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    var token = tokens[i];\n\t\n\t    if (typeof token === 'string') {\n\t      route += escapeString(token);\n\t    } else {\n\t      var prefix = escapeString(token.prefix);\n\t      var capture = '(?:' + token.pattern + ')';\n\t\n\t      keys.push(token);\n\t\n\t      if (token.repeat) {\n\t        capture += '(?:' + prefix + capture + ')*';\n\t      }\n\t\n\t      if (token.optional) {\n\t        if (!token.partial) {\n\t          capture = '(?:' + prefix + '(' + capture + '))?';\n\t        } else {\n\t          capture = prefix + '(' + capture + ')?';\n\t        }\n\t      } else {\n\t        capture = prefix + '(' + capture + ')';\n\t      }\n\t\n\t      route += capture;\n\t    }\n\t  }\n\t\n\t  var delimiter = escapeString(options.delimiter || '/');\n\t  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\t\n\t  // In non-strict mode we allow a slash at the end of match. If the path to\n\t  // match already ends with a slash, we remove it for consistency. The slash\n\t  // is valid at the end of a path match, not in the middle. This is important\n\t  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\t  if (!strict) {\n\t    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n\t  }\n\t\n\t  if (end) {\n\t    route += '$';\n\t  } else {\n\t    // In non-ending mode, we need the capturing groups to match as much as\n\t    // possible by using a positive lookahead to the end or next path segment.\n\t    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n\t  }\n\t\n\t  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n\t}\n\t\n\t/**\n\t * Normalize the given path string, returning a regular expression.\n\t *\n\t * An empty array can be passed in for the keys, which will hold the\n\t * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n\t * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n\t *\n\t * @param  {(string|RegExp|Array)} path\n\t * @param  {(Array|Object)=}       keys\n\t * @param  {Object=}               options\n\t * @return {!RegExp}\n\t */\n\tfunction pathToRegexp (path, keys, options) {\n\t  if (!isarray(keys)) {\n\t    options = /** @type {!Object} */ (keys || options);\n\t    keys = [];\n\t  }\n\t\n\t  options = options || {};\n\t\n\t  if (path instanceof RegExp) {\n\t    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n\t  }\n\t\n\t  if (isarray(path)) {\n\t    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n\t  }\n\t\n\t  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n\t}\n\t\n\tindex.parse = parse_1;\n\tindex.compile = compile_1;\n\tindex.tokensToFunction = tokensToFunction_1;\n\tindex.tokensToRegExp = tokensToRegExp_1;\n\t\n\t/*  */\n\t\n\tvar regexpCache = Object.create(null);\n\t\n\tfunction getRouteRegex (path) {\n\t  var hit = regexpCache[path];\n\t  var keys, regexp;\n\t\n\t  if (hit) {\n\t    keys = hit.keys;\n\t    regexp = hit.regexp;\n\t  } else {\n\t    keys = [];\n\t    regexp = index(path, keys);\n\t    regexpCache[path] = { keys: keys, regexp: regexp };\n\t  }\n\t\n\t  return { keys: keys, regexp: regexp }\n\t}\n\t\n\tvar regexpCompileCache = Object.create(null);\n\t\n\tfunction fillParams (\n\t  path,\n\t  params,\n\t  routeMsg\n\t) {\n\t  try {\n\t    var filler =\n\t      regexpCompileCache[path] ||\n\t      (regexpCompileCache[path] = index.compile(path));\n\t    return filler(params || {}, { pretty: true })\n\t  } catch (e) {\n\t    if (false) {\n\t      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n\t    }\n\t    return ''\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction normalizeLocation (\n\t  raw,\n\t  current,\n\t  append\n\t) {\n\t  var next = typeof raw === 'string' ? { path: raw } : raw;\n\t  // named target\n\t  if (next.name || next._normalized) {\n\t    return next\n\t  }\n\t\n\t  // relative params\n\t  if (!next.path && next.params && current) {\n\t    next = assign({}, next);\n\t    next._normalized = true;\n\t    var params = assign(assign({}, current.params), next.params);\n\t    if (current.name) {\n\t      next.name = current.name;\n\t      next.params = params;\n\t    } else if (current.matched) {\n\t      var rawPath = current.matched[current.matched.length - 1].path;\n\t      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n\t    } else if (false) {\n\t      warn(false, \"relative params navigation requires a current route.\");\n\t    }\n\t    return next\n\t  }\n\t\n\t  var parsedPath = parsePath(next.path || '');\n\t  var basePath = (current && current.path) || '/';\n\t  var path = parsedPath.path\n\t    ? resolvePath(parsedPath.path, basePath, append || next.append)\n\t    : (current && current.path) || '/';\n\t  var query = resolveQuery(parsedPath.query, next.query);\n\t  var hash = next.hash || parsedPath.hash;\n\t  if (hash && hash.charAt(0) !== '#') {\n\t    hash = \"#\" + hash;\n\t  }\n\t\n\t  return {\n\t    _normalized: true,\n\t    path: path,\n\t    query: query,\n\t    hash: hash\n\t  }\n\t}\n\t\n\tfunction assign (a, b) {\n\t  for (var key in b) {\n\t    a[key] = b[key];\n\t  }\n\t  return a\n\t}\n\t\n\t/*  */\n\t\n\tfunction createMatcher (routes) {\n\t  var ref = createRouteMap(routes);\n\t  var pathMap = ref.pathMap;\n\t  var nameMap = ref.nameMap;\n\t\n\t  function addRoutes (routes) {\n\t    createRouteMap(routes, pathMap, nameMap);\n\t  }\n\t\n\t  function match (\n\t    raw,\n\t    currentRoute,\n\t    redirectedFrom\n\t  ) {\n\t    var location = normalizeLocation(raw, currentRoute);\n\t    var name = location.name;\n\t\n\t    if (name) {\n\t      var record = nameMap[name];\n\t      if (false) {\n\t        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n\t      }\n\t      var paramNames = getRouteRegex(record.path).keys\n\t        .filter(function (key) { return !key.optional; })\n\t        .map(function (key) { return key.name; });\n\t\n\t      if (typeof location.params !== 'object') {\n\t        location.params = {};\n\t      }\n\t\n\t      if (currentRoute && typeof currentRoute.params === 'object') {\n\t        for (var key in currentRoute.params) {\n\t          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n\t            location.params[key] = currentRoute.params[key];\n\t          }\n\t        }\n\t      }\n\t\n\t      if (record) {\n\t        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n\t        return _createRoute(record, location, redirectedFrom)\n\t      }\n\t    } else if (location.path) {\n\t      location.params = {};\n\t      for (var path in pathMap) {\n\t        if (matchRoute(path, location.params, location.path)) {\n\t          return _createRoute(pathMap[path], location, redirectedFrom)\n\t        }\n\t      }\n\t    }\n\t    // no match\n\t    return _createRoute(null, location)\n\t  }\n\t\n\t  function redirect (\n\t    record,\n\t    location\n\t  ) {\n\t    var originalRedirect = record.redirect;\n\t    var redirect = typeof originalRedirect === 'function'\n\t        ? originalRedirect(createRoute(record, location))\n\t        : originalRedirect;\n\t\n\t    if (typeof redirect === 'string') {\n\t      redirect = { path: redirect };\n\t    }\n\t\n\t    if (!redirect || typeof redirect !== 'object') {\n\t      (\"production\") !== 'production' && warn(\n\t        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n\t      );\n\t      return _createRoute(null, location)\n\t    }\n\t\n\t    var re = redirect;\n\t    var name = re.name;\n\t    var path = re.path;\n\t    var query = location.query;\n\t    var hash = location.hash;\n\t    var params = location.params;\n\t    query = re.hasOwnProperty('query') ? re.query : query;\n\t    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n\t    params = re.hasOwnProperty('params') ? re.params : params;\n\t\n\t    if (name) {\n\t      // resolved named direct\n\t      var targetRecord = nameMap[name];\n\t      if (false) {\n\t        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n\t      }\n\t      return match({\n\t        _normalized: true,\n\t        name: name,\n\t        query: query,\n\t        hash: hash,\n\t        params: params\n\t      }, undefined, location)\n\t    } else if (path) {\n\t      // 1. resolve relative redirect\n\t      var rawPath = resolveRecordPath(path, record);\n\t      // 2. resolve params\n\t      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n\t      // 3. rematch with existing query and hash\n\t      return match({\n\t        _normalized: true,\n\t        path: resolvedPath,\n\t        query: query,\n\t        hash: hash\n\t      }, undefined, location)\n\t    } else {\n\t      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n\t      return _createRoute(null, location)\n\t    }\n\t  }\n\t\n\t  function alias (\n\t    record,\n\t    location,\n\t    matchAs\n\t  ) {\n\t    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n\t    var aliasedMatch = match({\n\t      _normalized: true,\n\t      path: aliasedPath\n\t    });\n\t    if (aliasedMatch) {\n\t      var matched = aliasedMatch.matched;\n\t      var aliasedRecord = matched[matched.length - 1];\n\t      location.params = aliasedMatch.params;\n\t      return _createRoute(aliasedRecord, location)\n\t    }\n\t    return _createRoute(null, location)\n\t  }\n\t\n\t  function _createRoute (\n\t    record,\n\t    location,\n\t    redirectedFrom\n\t  ) {\n\t    if (record && record.redirect) {\n\t      return redirect(record, redirectedFrom || location)\n\t    }\n\t    if (record && record.matchAs) {\n\t      return alias(record, location, record.matchAs)\n\t    }\n\t    return createRoute(record, location, redirectedFrom)\n\t  }\n\t\n\t  return {\n\t    match: match,\n\t    addRoutes: addRoutes\n\t  }\n\t}\n\t\n\tfunction matchRoute (\n\t  path,\n\t  params,\n\t  pathname\n\t) {\n\t  var ref = getRouteRegex(path);\n\t  var regexp = ref.regexp;\n\t  var keys = ref.keys;\n\t  var m = pathname.match(regexp);\n\t\n\t  if (!m) {\n\t    return false\n\t  } else if (!params) {\n\t    return true\n\t  }\n\t\n\t  for (var i = 1, len = m.length; i < len; ++i) {\n\t    var key = keys[i - 1];\n\t    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n\t    if (key) { params[key.name] = val; }\n\t  }\n\t\n\t  return true\n\t}\n\t\n\tfunction resolveRecordPath (path, record) {\n\t  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar positionStore = Object.create(null);\n\t\n\tfunction setupScroll () {\n\t  window.addEventListener('popstate', function (e) {\n\t    if (e.state && e.state.key) {\n\t      setStateKey(e.state.key);\n\t    }\n\t  });\n\t\n\t  window.addEventListener('scroll', saveScrollPosition);\n\t}\n\t\n\tfunction handleScroll (\n\t  router,\n\t  to,\n\t  from,\n\t  isPop\n\t) {\n\t  if (!router.app) {\n\t    return\n\t  }\n\t\n\t  var behavior = router.options.scrollBehavior;\n\t  if (!behavior) {\n\t    return\n\t  }\n\t\n\t  if (false) {\n\t    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n\t  }\n\t\n\t  // wait until re-render finishes before scrolling\n\t  router.app.$nextTick(function () {\n\t    var position = getScrollPosition();\n\t    var shouldScroll = behavior(to, from, isPop ? position : null);\n\t    if (!shouldScroll) {\n\t      return\n\t    }\n\t    var isObject = typeof shouldScroll === 'object';\n\t    if (isObject && typeof shouldScroll.selector === 'string') {\n\t      var el = document.querySelector(shouldScroll.selector);\n\t      if (el) {\n\t        position = getElementPosition(el);\n\t      } else if (isValidPosition(shouldScroll)) {\n\t        position = normalizePosition(shouldScroll);\n\t      }\n\t    } else if (isObject && isValidPosition(shouldScroll)) {\n\t      position = normalizePosition(shouldScroll);\n\t    }\n\t\n\t    if (position) {\n\t      window.scrollTo(position.x, position.y);\n\t    }\n\t  });\n\t}\n\t\n\tfunction saveScrollPosition () {\n\t  var key = getStateKey();\n\t  if (key) {\n\t    positionStore[key] = {\n\t      x: window.pageXOffset,\n\t      y: window.pageYOffset\n\t    };\n\t  }\n\t}\n\t\n\tfunction getScrollPosition () {\n\t  var key = getStateKey();\n\t  if (key) {\n\t    return positionStore[key]\n\t  }\n\t}\n\t\n\tfunction getElementPosition (el) {\n\t  var docRect = document.documentElement.getBoundingClientRect();\n\t  var elRect = el.getBoundingClientRect();\n\t  return {\n\t    x: elRect.left - docRect.left,\n\t    y: elRect.top - docRect.top\n\t  }\n\t}\n\t\n\tfunction isValidPosition (obj) {\n\t  return isNumber(obj.x) || isNumber(obj.y)\n\t}\n\t\n\tfunction normalizePosition (obj) {\n\t  return {\n\t    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n\t    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n\t  }\n\t}\n\t\n\tfunction isNumber (v) {\n\t  return typeof v === 'number'\n\t}\n\t\n\t/*  */\n\t\n\tvar supportsPushState = inBrowser && (function () {\n\t  var ua = window.navigator.userAgent;\n\t\n\t  if (\n\t    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n\t    ua.indexOf('Mobile Safari') !== -1 &&\n\t    ua.indexOf('Chrome') === -1 &&\n\t    ua.indexOf('Windows Phone') === -1\n\t  ) {\n\t    return false\n\t  }\n\t\n\t  return window.history && 'pushState' in window.history\n\t})();\n\t\n\t// use User Timing api (if present) for more accurate key precision\n\tvar Time = inBrowser && window.performance && window.performance.now\n\t  ? window.performance\n\t  : Date;\n\t\n\tvar _key = genKey();\n\t\n\tfunction genKey () {\n\t  return Time.now().toFixed(3)\n\t}\n\t\n\tfunction getStateKey () {\n\t  return _key\n\t}\n\t\n\tfunction setStateKey (key) {\n\t  _key = key;\n\t}\n\t\n\tfunction pushState (url, replace) {\n\t  // try...catch the pushState call to get around Safari\n\t  // DOM Exception 18 where it limits to 100 pushState calls\n\t  var history = window.history;\n\t  try {\n\t    if (replace) {\n\t      history.replaceState({ key: _key }, '', url);\n\t    } else {\n\t      _key = genKey();\n\t      history.pushState({ key: _key }, '', url);\n\t    }\n\t    saveScrollPosition();\n\t  } catch (e) {\n\t    window.location[replace ? 'replace' : 'assign'](url);\n\t  }\n\t}\n\t\n\tfunction replaceState (url) {\n\t  pushState(url, true);\n\t}\n\t\n\t/*  */\n\t\n\tfunction runQueue (queue, fn, cb) {\n\t  var step = function (index) {\n\t    if (index >= queue.length) {\n\t      cb();\n\t    } else {\n\t      if (queue[index]) {\n\t        fn(queue[index], function () {\n\t          step(index + 1);\n\t        });\n\t      } else {\n\t        step(index + 1);\n\t      }\n\t    }\n\t  };\n\t  step(0);\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar History = function History (router, base) {\n\t  this.router = router;\n\t  this.base = normalizeBase(base);\n\t  // start with a route object that stands for \"nowhere\"\n\t  this.current = START;\n\t  this.pending = null;\n\t  this.ready = false;\n\t  this.readyCbs = [];\n\t};\n\t\n\tHistory.prototype.listen = function listen (cb) {\n\t  this.cb = cb;\n\t};\n\t\n\tHistory.prototype.onReady = function onReady (cb) {\n\t  if (this.ready) {\n\t    cb();\n\t  } else {\n\t    this.readyCbs.push(cb);\n\t  }\n\t};\n\t\n\tHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t  var route = this.router.match(location, this.current);\n\t  this.confirmTransition(route, function () {\n\t    this$1.updateRoute(route);\n\t    onComplete && onComplete(route);\n\t    this$1.ensureURL();\n\t\n\t    // fire ready cbs once\n\t    if (!this$1.ready) {\n\t      this$1.ready = true;\n\t      this$1.readyCbs.forEach(function (cb) {\n\t        cb(route);\n\t      });\n\t    }\n\t  }, onAbort);\n\t};\n\t\n\tHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t  var current = this.current;\n\t  var abort = function () { onAbort && onAbort(); };\n\t  if (\n\t    isSameRoute(route, current) &&\n\t    // in the case the route map has been dynamically appended to\n\t    route.matched.length === current.matched.length\n\t  ) {\n\t    this.ensureURL();\n\t    return abort()\n\t  }\n\t\n\t  var ref = resolveQueue(this.current.matched, route.matched);\n\t    var updated = ref.updated;\n\t    var deactivated = ref.deactivated;\n\t    var activated = ref.activated;\n\t\n\t  var queue = [].concat(\n\t    // in-component leave guards\n\t    extractLeaveGuards(deactivated),\n\t    // global before hooks\n\t    this.router.beforeHooks,\n\t    // in-component update hooks\n\t    extractUpdateHooks(updated),\n\t    // in-config enter guards\n\t    activated.map(function (m) { return m.beforeEnter; }),\n\t    // async components\n\t    resolveAsyncComponents(activated)\n\t  );\n\t\n\t  this.pending = route;\n\t  var iterator = function (hook, next) {\n\t    if (this$1.pending !== route) {\n\t      return abort()\n\t    }\n\t    hook(route, current, function (to) {\n\t      if (to === false) {\n\t        // next(false) -> abort navigation, ensure current URL\n\t        this$1.ensureURL(true);\n\t        abort();\n\t      } else if (typeof to === 'string' || typeof to === 'object') {\n\t        // next('/') or next({ path: '/' }) -> redirect\n\t        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n\t        abort();\n\t      } else {\n\t        // confirm transition and pass on the value\n\t        next(to);\n\t      }\n\t    });\n\t  };\n\t\n\t  runQueue(queue, iterator, function () {\n\t    var postEnterCbs = [];\n\t    var isValid = function () { return this$1.current === route; };\n\t    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n\t    // wait until async components are resolved before\n\t    // extracting in-component enter guards\n\t    runQueue(enterGuards, iterator, function () {\n\t      if (this$1.pending !== route) {\n\t        return abort()\n\t      }\n\t      this$1.pending = null;\n\t      onComplete(route);\n\t      if (this$1.router.app) {\n\t        this$1.router.app.$nextTick(function () {\n\t          postEnterCbs.forEach(function (cb) { return cb(); });\n\t        });\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\tHistory.prototype.updateRoute = function updateRoute (route) {\n\t  var prev = this.current;\n\t  this.current = route;\n\t  this.cb && this.cb(route);\n\t  this.router.afterHooks.forEach(function (hook) {\n\t    hook && hook(route, prev);\n\t  });\n\t};\n\t\n\tfunction normalizeBase (base) {\n\t  if (!base) {\n\t    if (inBrowser) {\n\t      // respect <base> tag\n\t      var baseEl = document.querySelector('base');\n\t      base = baseEl ? baseEl.getAttribute('href') : '/';\n\t    } else {\n\t      base = '/';\n\t    }\n\t  }\n\t  // make sure there's the starting slash\n\t  if (base.charAt(0) !== '/') {\n\t    base = '/' + base;\n\t  }\n\t  // remove trailing slash\n\t  return base.replace(/\\/$/, '')\n\t}\n\t\n\tfunction resolveQueue (\n\t  current,\n\t  next\n\t) {\n\t  var i;\n\t  var max = Math.max(current.length, next.length);\n\t  for (i = 0; i < max; i++) {\n\t    if (current[i] !== next[i]) {\n\t      break\n\t    }\n\t  }\n\t  return {\n\t    updated: next.slice(0, i),\n\t    activated: next.slice(i),\n\t    deactivated: current.slice(i)\n\t  }\n\t}\n\t\n\tfunction extractGuards (\n\t  records,\n\t  name,\n\t  bind,\n\t  reverse\n\t) {\n\t  var guards = flatMapComponents(records, function (def, instance, match, key) {\n\t    var guard = extractGuard(def, name);\n\t    if (guard) {\n\t      return Array.isArray(guard)\n\t        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n\t        : bind(guard, instance, match, key)\n\t    }\n\t  });\n\t  return flatten(reverse ? guards.reverse() : guards)\n\t}\n\t\n\tfunction extractGuard (\n\t  def,\n\t  key\n\t) {\n\t  if (typeof def !== 'function') {\n\t    // extend now so that global mixins are applied.\n\t    def = _Vue.extend(def);\n\t  }\n\t  return def.options[key]\n\t}\n\t\n\tfunction extractLeaveGuards (deactivated) {\n\t  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n\t}\n\t\n\tfunction extractUpdateHooks (updated) {\n\t  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n\t}\n\t\n\tfunction bindGuard (guard, instance) {\n\t  return function boundRouteGuard () {\n\t    return guard.apply(instance, arguments)\n\t  }\n\t}\n\t\n\tfunction extractEnterGuards (\n\t  activated,\n\t  cbs,\n\t  isValid\n\t) {\n\t  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n\t    return bindEnterGuard(guard, match, key, cbs, isValid)\n\t  })\n\t}\n\t\n\tfunction bindEnterGuard (\n\t  guard,\n\t  match,\n\t  key,\n\t  cbs,\n\t  isValid\n\t) {\n\t  return function routeEnterGuard (to, from, next) {\n\t    return guard(to, from, function (cb) {\n\t      next(cb);\n\t      if (typeof cb === 'function') {\n\t        cbs.push(function () {\n\t          // #750\n\t          // if a router-view is wrapped with an out-in transition,\n\t          // the instance may not have been registered at this time.\n\t          // we will need to poll for registration until current route\n\t          // is no longer valid.\n\t          poll(cb, match.instances, key, isValid);\n\t        });\n\t      }\n\t    })\n\t  }\n\t}\n\t\n\tfunction poll (\n\t  cb, // somehow flow cannot infer this is a function\n\t  instances,\n\t  key,\n\t  isValid\n\t) {\n\t  if (instances[key]) {\n\t    cb(instances[key]);\n\t  } else if (isValid()) {\n\t    setTimeout(function () {\n\t      poll(cb, instances, key, isValid);\n\t    }, 16);\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponents (matched) {\n\t  return flatMapComponents(matched, function (def, _, match, key) {\n\t    // if it's a function and doesn't have Vue options attached,\n\t    // assume it's an async component resolve function.\n\t    // we are not using Vue's default async resolving mechanism because\n\t    // we want to halt the navigation until the incoming component has been\n\t    // resolved.\n\t    if (typeof def === 'function' && !def.options) {\n\t      return function (to, from, next) {\n\t        var resolve = once(function (resolvedDef) {\n\t          match.components[key] = resolvedDef;\n\t          next();\n\t        });\n\t\n\t        var reject = once(function (reason) {\n\t          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n\t          next(false);\n\t        });\n\t\n\t        var res = def(resolve, reject);\n\t        if (res && typeof res.then === 'function') {\n\t          res.then(resolve, reject);\n\t        }\n\t      }\n\t    }\n\t  })\n\t}\n\t\n\tfunction flatMapComponents (\n\t  matched,\n\t  fn\n\t) {\n\t  return flatten(matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) { return fn(\n\t      m.components[key],\n\t      m.instances[key],\n\t      m, key\n\t    ); })\n\t  }))\n\t}\n\t\n\tfunction flatten (arr) {\n\t  return Array.prototype.concat.apply([], arr)\n\t}\n\t\n\t// in Webpack 2, require.ensure now also returns a Promise\n\t// so the resolve/reject functions may get called an extra time\n\t// if the user uses an arrow function shorthand that happens to\n\t// return that Promise.\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (called) { return }\n\t    called = true;\n\t    return fn.apply(this, arguments)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar HTML5History = (function (History$$1) {\n\t  function HTML5History (router, base) {\n\t    var this$1 = this;\n\t\n\t    History$$1.call(this, router, base);\n\t\n\t    var expectScroll = router.options.scrollBehavior;\n\t\n\t    if (expectScroll) {\n\t      setupScroll();\n\t    }\n\t\n\t    window.addEventListener('popstate', function (e) {\n\t      this$1.transitionTo(getLocation(this$1.base), function (route) {\n\t        if (expectScroll) {\n\t          handleScroll(router, route, this$1.current, true);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n\t  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n\t  HTML5History.prototype.constructor = HTML5History;\n\t\n\t  HTML5History.prototype.go = function go (n) {\n\t    window.history.go(n);\n\t  };\n\t\n\t  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      pushState(cleanPath(this$1.base + route.fullPath));\n\t      handleScroll(this$1.router, route, this$1.current, false);\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      replaceState(cleanPath(this$1.base + route.fullPath));\n\t      handleScroll(this$1.router, route, this$1.current, false);\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  HTML5History.prototype.ensureURL = function ensureURL (push) {\n\t    if (getLocation(this.base) !== this.current.fullPath) {\n\t      var current = cleanPath(this.base + this.current.fullPath);\n\t      push ? pushState(current) : replaceState(current);\n\t    }\n\t  };\n\t\n\t  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n\t    return getLocation(this.base)\n\t  };\n\t\n\t  return HTML5History;\n\t}(History));\n\t\n\tfunction getLocation (base) {\n\t  var path = window.location.pathname;\n\t  if (base && path.indexOf(base) === 0) {\n\t    path = path.slice(base.length);\n\t  }\n\t  return (path || '/') + window.location.search + window.location.hash\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar HashHistory = (function (History$$1) {\n\t  function HashHistory (router, base, fallback) {\n\t    History$$1.call(this, router, base);\n\t    // check history fallback deeplinking\n\t    if (fallback && checkFallback(this.base)) {\n\t      return\n\t    }\n\t    ensureSlash();\n\t  }\n\t\n\t  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n\t  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n\t  HashHistory.prototype.constructor = HashHistory;\n\t\n\t  // this is delayed until the app mounts\n\t  // to avoid the hashchange listener being fired too early\n\t  HashHistory.prototype.setupListeners = function setupListeners () {\n\t    var this$1 = this;\n\t\n\t    window.addEventListener('hashchange', function () {\n\t      if (!ensureSlash()) {\n\t        return\n\t      }\n\t      this$1.transitionTo(getHash(), function (route) {\n\t        replaceHash(route.fullPath);\n\t      });\n\t    });\n\t  };\n\t\n\t  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n\t    this.transitionTo(location, function (route) {\n\t      pushHash(route.fullPath);\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n\t    this.transitionTo(location, function (route) {\n\t      replaceHash(route.fullPath);\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  HashHistory.prototype.go = function go (n) {\n\t    window.history.go(n);\n\t  };\n\t\n\t  HashHistory.prototype.ensureURL = function ensureURL (push) {\n\t    var current = this.current.fullPath;\n\t    if (getHash() !== current) {\n\t      push ? pushHash(current) : replaceHash(current);\n\t    }\n\t  };\n\t\n\t  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n\t    return getHash()\n\t  };\n\t\n\t  return HashHistory;\n\t}(History));\n\t\n\tfunction checkFallback (base) {\n\t  var location = getLocation(base);\n\t  if (!/^\\/#/.test(location)) {\n\t    window.location.replace(\n\t      cleanPath(base + '/#' + location)\n\t    );\n\t    return true\n\t  }\n\t}\n\t\n\tfunction ensureSlash () {\n\t  var path = getHash();\n\t  if (path.charAt(0) === '/') {\n\t    return true\n\t  }\n\t  replaceHash('/' + path);\n\t  return false\n\t}\n\t\n\tfunction getHash () {\n\t  // We can't use window.location.hash here because it's not\n\t  // consistent across browsers - Firefox will pre-decode it!\n\t  var href = window.location.href;\n\t  var index = href.indexOf('#');\n\t  return index === -1 ? '' : href.slice(index + 1)\n\t}\n\t\n\tfunction pushHash (path) {\n\t  window.location.hash = path;\n\t}\n\t\n\tfunction replaceHash (path) {\n\t  var i = window.location.href.indexOf('#');\n\t  window.location.replace(\n\t    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n\t  );\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar AbstractHistory = (function (History$$1) {\n\t  function AbstractHistory (router, base) {\n\t    History$$1.call(this, router, base);\n\t    this.stack = [];\n\t    this.index = -1;\n\t  }\n\t\n\t  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n\t  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n\t  AbstractHistory.prototype.constructor = AbstractHistory;\n\t\n\t  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n\t      this$1.index++;\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n\t    var this$1 = this;\n\t\n\t    this.transitionTo(location, function (route) {\n\t      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n\t      onComplete && onComplete(route);\n\t    }, onAbort);\n\t  };\n\t\n\t  AbstractHistory.prototype.go = function go (n) {\n\t    var this$1 = this;\n\t\n\t    var targetIndex = this.index + n;\n\t    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n\t      return\n\t    }\n\t    var route = this.stack[targetIndex];\n\t    this.confirmTransition(route, function () {\n\t      this$1.index = targetIndex;\n\t      this$1.updateRoute(route);\n\t    });\n\t  };\n\t\n\t  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n\t    var current = this.stack[this.stack.length - 1];\n\t    return current ? current.fullPath : '/'\n\t  };\n\t\n\t  AbstractHistory.prototype.ensureURL = function ensureURL () {\n\t    // noop\n\t  };\n\t\n\t  return AbstractHistory;\n\t}(History));\n\t\n\t/*  */\n\t\n\tvar VueRouter = function VueRouter (options) {\n\t  if ( options === void 0 ) options = {};\n\t\n\t  this.app = null;\n\t  this.apps = [];\n\t  this.options = options;\n\t  this.beforeHooks = [];\n\t  this.afterHooks = [];\n\t  this.matcher = createMatcher(options.routes || []);\n\t\n\t  var mode = options.mode || 'hash';\n\t  this.fallback = mode === 'history' && !supportsPushState;\n\t  if (this.fallback) {\n\t    mode = 'hash';\n\t  }\n\t  if (!inBrowser) {\n\t    mode = 'abstract';\n\t  }\n\t  this.mode = mode;\n\t\n\t  switch (mode) {\n\t    case 'history':\n\t      this.history = new HTML5History(this, options.base);\n\t      break\n\t    case 'hash':\n\t      this.history = new HashHistory(this, options.base, this.fallback);\n\t      break\n\t    case 'abstract':\n\t      this.history = new AbstractHistory(this, options.base);\n\t      break\n\t    default:\n\t      if (false) {\n\t        assert(false, (\"invalid mode: \" + mode));\n\t      }\n\t  }\n\t};\n\t\n\tvar prototypeAccessors = { currentRoute: {} };\n\t\n\tVueRouter.prototype.match = function match (\n\t  raw,\n\t  current,\n\t  redirectedFrom\n\t) {\n\t  return this.matcher.match(raw, current, redirectedFrom)\n\t};\n\t\n\tprototypeAccessors.currentRoute.get = function () {\n\t  return this.history && this.history.current\n\t};\n\t\n\tVueRouter.prototype.init = function init (app /* Vue component instance */) {\n\t    var this$1 = this;\n\t\n\t  (\"production\") !== 'production' && assert(\n\t    install.installed,\n\t    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n\t    \"before creating root instance.\"\n\t  );\n\t\n\t  this.apps.push(app);\n\t\n\t  // main app already initialized.\n\t  if (this.app) {\n\t    return\n\t  }\n\t\n\t  this.app = app;\n\t\n\t  var history = this.history;\n\t\n\t  if (history instanceof HTML5History) {\n\t    history.transitionTo(history.getCurrentLocation());\n\t  } else if (history instanceof HashHistory) {\n\t    var setupHashListener = function () {\n\t      history.setupListeners();\n\t    };\n\t    history.transitionTo(\n\t      history.getCurrentLocation(),\n\t      setupHashListener,\n\t      setupHashListener\n\t    );\n\t  }\n\t\n\t  history.listen(function (route) {\n\t    this$1.apps.forEach(function (app) {\n\t      app._route = route;\n\t    });\n\t  });\n\t};\n\t\n\tVueRouter.prototype.beforeEach = function beforeEach (fn) {\n\t  this.beforeHooks.push(fn);\n\t};\n\t\n\tVueRouter.prototype.afterEach = function afterEach (fn) {\n\t  this.afterHooks.push(fn);\n\t};\n\t\n\tVueRouter.prototype.onReady = function onReady (cb) {\n\t  this.history.onReady(cb);\n\t};\n\t\n\tVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n\t  this.history.push(location, onComplete, onAbort);\n\t};\n\t\n\tVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n\t  this.history.replace(location, onComplete, onAbort);\n\t};\n\t\n\tVueRouter.prototype.go = function go (n) {\n\t  this.history.go(n);\n\t};\n\t\n\tVueRouter.prototype.back = function back () {\n\t  this.go(-1);\n\t};\n\t\n\tVueRouter.prototype.forward = function forward () {\n\t  this.go(1);\n\t};\n\t\n\tVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n\t  var route = to\n\t    ? this.resolve(to).route\n\t    : this.currentRoute;\n\t  if (!route) {\n\t    return []\n\t  }\n\t  return [].concat.apply([], route.matched.map(function (m) {\n\t    return Object.keys(m.components).map(function (key) {\n\t      return m.components[key]\n\t    })\n\t  }))\n\t};\n\t\n\tVueRouter.prototype.resolve = function resolve (\n\t  to,\n\t  current,\n\t  append\n\t) {\n\t  var location = normalizeLocation(to, current || this.history.current, append);\n\t  var route = this.match(location, current);\n\t  var fullPath = route.redirectedFrom || route.fullPath;\n\t  var base = this.history.base;\n\t  var href = createHref(base, fullPath, this.mode);\n\t  return {\n\t    location: location,\n\t    route: route,\n\t    href: href,\n\t    // for backwards compat\n\t    normalizedTo: location,\n\t    resolved: route\n\t  }\n\t};\n\t\n\tVueRouter.prototype.addRoutes = function addRoutes (routes) {\n\t  this.matcher.addRoutes(routes);\n\t  if (this.history.current !== START) {\n\t    this.history.transitionTo(this.history.getCurrentLocation());\n\t  }\n\t};\n\t\n\tObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\t\n\tfunction createHref (base, fullPath, mode) {\n\t  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n\t  return base ? cleanPath(base + '/' + path) : path\n\t}\n\t\n\tVueRouter.install = install;\n\tVueRouter.version = '2.2.0';\n\t\n\tif (inBrowser && window.Vue) {\n\t  window.Vue.use(VueRouter);\n\t}\n\t\n\tmodule.exports = VueRouter;\n\n\n/***/ },\n/* 271 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 272 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/vendor.15b1f4a37d4fc42aae31.js","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            result = source.constructor.from(source);\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/util.js\n// module id = 1\n// module chunks = 1","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts (dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLDomElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = zrUtil.clone(theme);\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = new ExtensionAPI(this);\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLDomElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        // FIXME\n        // ugly\n        this.__lastOnlyGraphic = !!(option && option.graphic);\n        zrUtil.each(option, function (o, mainType) {\n            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);\n        }, this);\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.time && console.time('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            // console.time && console.timeEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            // FIXME\n            // ugly\n            if (this.__lastOnlyGraphic) {\n                each(this._componentsViews, function (componentView) {\n                    var componentModel = componentView.__model;\n                    if (componentModel && componentModel.mainType === 'graphic') {\n                        componentView.render(componentModel, ecModel, this._api, payload);\n                        updateZ(componentModel, componentView);\n                    }\n                }, this);\n                this.__lastOnlyGraphic = false;\n            }\n            else {\n                updateMethods.update.call(this, payload);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            var view = ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId];\n            if (view && view.__alive) {\n                view[method](model, ecModel, ecIns._api, payload);\n            }\n        }, ecIns);\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // if (__DEV__) {\n        //     zrUtil.assert(\n        //         !this[IN_MAIN_PROCESS],\n        //         '`dispatchAction` should not be called during main process.'\n        //         + 'unless updateMathod is \"none\".'\n        //     );\n        // }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        for (var i = 0; i < payloads.length; i++) {\n            var batchItem = payloads[i];\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = viewId;\n            view.__alive = true;\n            view.__id = viewId;\n            view.__model = model;\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                if (previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var actions = [];\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.4.0',\n        dependencies: {\n            zrender: '3.3.0'\n        }\n    };\n\n    function enableConnect(chart) {\n\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n\n    }\n    /**\n     * @param {HTMLDomElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        dom.setAttribute &&\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (zrUtil.isDom(chart)) {\n            chart = echarts.getInstanceByDom(chart);\n        }\n        else if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLDomElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        return instances[key];\n    };\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(require('./preprocessor/backwardCompat'));\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n\n    // --------\n    // Exports\n    // --------\n    //\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/echarts.js\n// module id = 2\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var round = Math.round;\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var subPixelOptimize = graphic.subPixelOptimize;\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                if (hoverStyle.hasOwnProperty(name)) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            el.setStyle(el.__hoverStl);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * Set text option in the style\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string} color\n     */\n    graphic.setText = function (textStyle, labelModel, color) {\n        var labelPosition = labelModel.getShallow('position') || 'inside';\n        var labelOffset = labelModel.getShallow('offset');\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\n        var textStyleModel = labelModel.getModel('textStyle');\n        zrUtil.extend(textStyle, {\n            textDistance: labelModel.getShallow('distance') || 5,\n            textFont: textStyleModel.getFont(),\n            textPosition: labelPosition,\n            textOffset: labelOffset,\n            textFill: textStyleModel.getTextColor() || labelColor\n        });\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)\n                : (el.attr(props), cb && cb());\n        }\n        else {\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} vertex [x, y]\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (vertex, transform, invert) {\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], vertex, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    module.exports = graphic;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/graphic.js\n// module id = 3\n// module chunks = 1","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * Fix rounding error of float numbers\n     * @param {number} x\n     * @return {number}\n     */\n    number.round = function (x, precision) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        return +(+x).toFixed(precision);\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n        var dotIndex = str.indexOf('.');\n        if (dotIndex < 0) {\n            return 0;\n        }\n        return str.length - 1 - dotIndex;\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    /**\n     * @param {string|Date|number} value\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Treat as ISO format. See issue #3623\n            var ret = new Date(value);\n            if (isNaN(+ret)) {\n                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local\n                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));\n            }\n            return ret;\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));\n    };\n\n    // \"Nice Numbers for Graph Labels\" of Graphic Gems\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true, take ceiling if round = false\n     * The primary observation is that the nicest numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     * @param  {number} val\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exp10 = number.quantity(val);\n        var f = val / exp10; // between 1 and 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        return nf * exp10;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/number.js\n// module id = 4\n// module chunks = 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/vector.js\n// module id = 5\n// module chunks = 1","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Path.js\n// module id = 6\n// module chunks = 1","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_wks.js\n// module id = 7\n// module chunks = 1","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_global.js\n// module id = 8\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n    /**\n     * ,\n     * @type {string|number} x\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     */\n    formatUtil.normalizeCssArray = function (val) {\n        var len = val.length;\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        else if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    };\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var y = date.getFullYear();\n        var M = date.getMonth() + 1;\n        var d = date.getDate();\n        var h = date.getHours();\n        var m = date.getMinutes();\n        var s = date.getSeconds();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .toLowerCase()\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    module.exports = formatUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/format.js\n// module id = 9\n// module chunks = 1","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/env.js\n// module id = 10\n// module chunks = 1","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 11\n// module chunks = 1","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Model.js\n// module id = 12\n// module chunks = 1","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             textStyle: {\n     *                 fontSize: 18\n     *             }\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            each(subOpts, function (subOptName) {\n                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);\n                if (val != null) {\n                    emphasisOpt[subOptName] = val;\n                }\n            });\n        }\n    };\n\n    modelUtil.LABEL_OPTIONS = ['position', 'offset', 'show', 'textStyle', 'distance', 'formatter'];\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n\n            var seriesIndex = this.seriesIndex;\n            var seriesName = this.name;\n\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: seriesIndex,\n                seriesName: seriesName,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: data.getItemVisual(dataIndex, 'color'),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get(['label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = {};\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && (idMap[existCpt.id] = item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && (idMap[opt.id] = item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-';\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap[keyInfo.id]);\n            }\n\n            idMap[keyInfo.id] = item;\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, goeName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = parsedKey[2];\n\n            if (!mainType || !queryType) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            queryParam[queryType.toLowerCase()] = value;\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/model.js\n// module id = 13\n// module chunks = 1","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/BoundingRect.js\n// module id = 14\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/clazz.js\n// module id = 15\n// module chunks = 1","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_core.js\n// module id = 16\n// module chunks = 1","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Component.js\n// module id = 17\n// module chunks = 1","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_an-object.js\n// module id = 18\n// module chunks = 1","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_hide.js\n// module id = 19\n// module chunks = 1","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        // If width and height are not given\n        // 1. Graph should not exceeds the container\n        // 2. Aspect must be keeped\n        // 3. Graph should take the space as more as possible\n        if (isNaN(width) && isNaN(height)) {\n            if (aspect > containerWidth / containerHeight) {\n                width = containerWidth * 0.8;\n            }\n            else {\n                height = containerHeight * 0.8;\n            }\n        }\n\n        if (aspect != null) {\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n        var hNames = ['width', 'left', 'right']; // Order by priority.\n        var vNames = ['height', 'top', 'bottom']; // Order by priority.\n        var hResult = merge(hNames);\n        var vResult = merge(vNames);\n\n        copy(hNames, targetOption, hResult);\n        copy(vNames, targetOption, vResult);\n\n        function merge(names) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = opt.ignoreSize ? 1 : 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/layout.js\n// module id = 20\n// module chunks = 1","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText  Canvas \n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME \n        var lineHeight = getTextWidth('', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/text.js\n// module id = 21\n// module chunks = 1","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/curve.js\n// module id = 22\n// module chunks = 1","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_ctx.js\n// module id = 23\n// module chunks = 1","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_descriptors.js\n// module id = 24\n// module chunks = 1","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iterators.js\n// module id = 25\n// module chunks = 1","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-dp.js\n// module id = 26\n// module chunks = 1","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/matrix.js\n// module id = 27\n// module chunks = 1","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/mixin/Eventful.js\n// module id = 28\n// module chunks = 1","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/tool/color.js\n// module id = 29\n// module chunks = 1","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_cof.js\n// module id = 30\n// module chunks = 1","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_has.js\n// module id = 31\n// module chunks = 1","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_is-object.js\n// module id = 32\n// module chunks = 1","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 34\n// module chunks = 1","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 35\n// module chunks = 1","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/config.js\n// module id = 36\n// module chunks = 1","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/container/Group.js\n// module id = 37\n// module chunks = 1","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/PathProxy.js\n// module id = 38\n// module chunks = 1","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/event.js\n// module id = 39\n// module chunks = 1","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_a-function.js\n// module id = 41\n// module chunks = 1","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_defined.js\n// module id = 42\n// module chunks = 1","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_dom-create.js\n// module id = 43\n// module chunks = 1","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_export.js\n// module id = 44\n// module chunks = 1","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_property-desc.js\n// module id = 45\n// module chunks = 1","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_set-to-string-tag.js\n// module id = 46\n// module chunks = 1","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_shared-key.js\n// module id = 47\n// module chunks = 1","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-integer.js\n// module id = 48\n// module chunks = 1","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-iobject.js\n// module id = 49\n// module chunks = 1","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-length.js\n// module id = 50\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.6.20.0@babel-runtime/core-js/array/from.js\n// module id = 51\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.6.20.0@babel-runtime/core-js/json/stringify.js\n// module id = 52\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Interface of Coordinate System Class\n     *\n     * create:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *     @return {Object} coordinate system instance\n     *\n     * update:\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {module:echarts/ExtensionAPI} api\n     *\n     * convertToPixel:\n     * convertFromPixel:\n     *     These two methods is also responsible for determine whether this\n     *     coodinate system is applicable to the given `finder`.\n     *     Each coordinate system will be tried, util one returns none\n     *     null/undefined value.\n     *     @param {module:echarts/model/Global} ecModel\n     *     @param {Object} finder\n     *     @param {Array|number} value\n     *     @return {Array|number} convert result.\n     *\n     * containPoint:\n     *     @param {Array.<number>} point In pixel coordinate system.\n     *     @return {boolean}\n     */\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/CoordinateSystem.js\n// module id = 54\n// module chunks = 1","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = originalExtent[1] - originalExtent[0];\n        }\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        axis.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 55\n// module chunks = 1","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    var transferProperties = function (a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string>} dimensions\n     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n            }\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var size = data.length;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var idList = [];\n        var nameRepeatCount = {};\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var dataItem = data[idx];\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);\n            }\n\n            indices.push(idx);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < data.length; i++) {\n            if (!nameList[i]) {\n                if (data[i] && data[i].name != null) {\n                    nameList[i] = data[i].name;\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = data[i] && data[i].id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null) {\n            return NaN;\n        }\n\n        var value = storage[dim] && storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {number}\n     */\n    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var nearestIdx = -1;\n        if (dimData) {\n            var minDist = Number.MAX_VALUE;\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var diff = value - this.get(dim, i, stack);\n                var dist = Math.abs(diff);\n                if (\n                    diff <= maxDistance\n                    && (dist < minDist\n                        // For the case of two data are same on xAxis, which has sequence data.\n                        // Show the nearest index\n                        // https://github.com/ecomfe/echarts/issues/2869\n                        || (dist === minDist && diff > 0)\n                    )\n                ) {\n                    minDist = dist;\n                    nearestIdx = i;\n                }\n            }\n        }\n        return nearestIdx;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData[this.getRawIndex(idx)];\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} ignoreParent\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/List.js\n// module id = 56\n// module chunks = 1","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 57\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/component.js\n// module id = 58\n// module chunks = 1","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/timsort.js\n// module id = 59\n// module chunks = 1","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Displayable.js\n// module id = 60\n// module chunks = 1","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Gradient.js\n// module id = 61\n// module chunks = 1","/*!\n * Vue.js v2.1.10\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b)\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set$1 (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set$1(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tidentity: identity,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tisServerRendering: isServerRendering,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (\n  vnode,\n  hydrating,\n  parentElm,\n  refElm\n) {\n  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n    var child = vnode.componentInstance = createComponentInstanceForVnode(\n      vnode,\n      activeInstance,\n      parentElm,\n      refElm\n    );\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.componentInstance = oldVnode.componentInstance;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.componentInstance._isMounted) {\n    vnode.componentInstance._isMounted = true;\n    callHook(vnode.componentInstance, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.componentInstance._inactive = false;\n    callHook(vnode.componentInstance, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.componentInstance._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.componentInstance.$destroy();\n    } else {\n      vnode.componentInstance._inactive = true;\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once,\n    capture: capture\n  }\n});\n\nfunction createEventHandle (fn) {\n  var handle = {\n    fn: fn,\n    invoker: function () {\n      var arguments$1 = arguments;\n\n      var fn = handle.fn;\n      if (Array.isArray(fn)) {\n        for (var i = 0; i < fn.length; i++) {\n          fn[i].apply(null, arguments$1);\n        }\n      } else {\n        fn.apply(null, arguments);\n      }\n    }\n  };\n  return handle\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.invoker) {\n        cur = on[name] = createEventHandle(cur);\n      }\n      add(event.name, cur.invoker, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fn = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name].invoker, event.capture);\n    }\n  }\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// nomralization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constrcuts that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = {};\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (_parentVnode && _parentVnode.data.scopedSlots) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n        }\n        throw e\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // convert text to vnode\n  Vue.prototype._v = createTextVNode;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = createEmptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        extend(props, bindObject);\n      }\n      return scopedSlotFn(props) || fallback\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && process.env.NODE_ENV !== 'production') {\n        slotNodes._rendered && warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback\n    }\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        process.env.NODE_ENV !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var type = data.attrs && data.attrs.type;\n            var hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // check v-on keyCodes\n  Vue.prototype._k = function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInAlias\n  ) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  };\n}\n\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add$1 (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$2 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true;\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function updateComponent () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            process.env.NODE_ENV !== 'production' && warn(\n              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n              this.vm\n            );\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, props) {\n  var propsData = vm.$options.propsData || {};\n  var keys = vm.$options._propKeys = Object.keys(props);\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( i ) {\n    var key = keys[i];\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) loop( i );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm, computed) {\n  for (var key in computed) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && key in vm) {\n      warn(\n        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n        \"overwritten by a computed property with the same name.\",\n        vm\n      );\n    }\n    var userDef = computed[key];\n    if (typeof userDef === 'function') {\n      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n      computedSharedDefinition.set = noop;\n    } else {\n      computedSharedDefinition.get = userDef.get\n        ? userDef.cache !== false\n          ? makeComputedGetter(userDef.get, vm)\n          : bind$1(userDef.get, vm)\n        : noop;\n      computedSharedDefinition.set = userDef.set\n        ? bind$1(userDef.set, vm)\n        : noop;\n    }\n    Object.defineProperty(vm, key, computedSharedDefinition);\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm, methods) {\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production' && methods[key] == null) {\n      warn(\n        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n        \"Did you reference the function correctly?\",\n        vm\n      );\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set$1;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      extendOptions._scopeId = options._scopeId;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else {\n    return pattern.test(name)\n  }\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set$1;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.1.10';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar target$1;\n\nfunction add$2 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      remove$3(event, handler, capture, _target);\n      arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$3 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(vnode, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (vnode, newVal) {\n  var value = vnode.elm.value;\n  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    leaveToClass: (name + \"-leave-to\"),\n    appearToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    var key = child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.isUnknownElement = isUnknownElement;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n// wrap mount\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\nif (process.env.NODE_ENV !== 'production' &&\n    inBrowser && typeof console !== 'undefined') {\n  console[console.info ? 'info' : 'log'](\n    \"You are running Vue in development mode.\\n\" +\n    \"Make sure to turn on production mode when deploying for production.\\n\" +\n    \"See more tips at https://vuejs.org/guide/deployment.html\"\n  );\n}\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\n      process.env.NODE_ENV !== 'production' &&\n      inBrowser && !isEdge && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isScriptOrStyle = makeMap('script,style', true);\nvar reCache = {};\n\nvar ltRE = /&lt;/g;\nvar gtRE = /&gt;/g;\nvar nlRE = /&#10;/g;\nvar ampRE = /&amp;/g;\nvar quoteRE = /&quot;/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  if (shouldDecodeNewlines) {\n    value = value.replace(nlRE, '\\n');\n  }\n  return value\n    .replace(ltRE, '<')\n    .replace(gtRE, '>')\n    .replace(ampRE, '&')\n    .replace(quoteRE, '\"')\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !isScriptOrStyle(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd > 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last && options.chars) {\n      options.chars(html);\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !/[\\w$]/.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue parser]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\nvar bindRE = /^:|^v-bind:/;\nvar onRE = /^@|^v-on:/;\nvar argRE = /:(.*)$/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$1;\nvar platformGetTagNamespace;\nvar platformMustUseProp;\nvar platformIsPreTag;\nvar preTransforms;\nvar transforms;\nvar postTransforms;\nvar delimiters;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$1 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$1(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production' && !warned) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warned = true;\n            warn$1(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes:\\n' + template\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warned = true;\n            warn$1(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements:\\n' + template\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production' && !warned) {\n          warned = true;\n          warn$1(\n            \"Component template should contain exactly one root element:\" +\n            \"\\n\\n\" + template + \"\\n\\n\" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {\n          warned = true;\n          warn$1(\n            'Component template requires a root element, rather than just text:\\n\\n' + template\n          );\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n          currentParent.children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$1(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$1(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once = getAndRemoveAttr(el, 'v-once');\n  if (once != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$1(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, arg, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        if (argMatch && (arg = argMatch[1])) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$1(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$1('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: 'if($event.target !== $event.currentTarget)return;',\n  ctrl: 'if(!$event.ctrlKey)return;',\n  shift: 'if(!$event.shiftKey)return;',\n  alt: 'if(!$event.altKey)return;',\n  meta: 'if(!$event.metaKey)return;'\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  } else if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  } else if (!handler.modifiers) {\n    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\")\n  } else {\n    var code = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        code += modifierCode[key];\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code = genKeyFilter(keys) + code;\n    }\n    var handlerCode = simplePathRE.test(handler.value)\n      ? handler.value + '($event)'\n      : handler.value;\n    return 'function($event){' + code + handlerCode + '}'\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$2 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$2,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$2;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$2 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$2);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$2('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n}\n\nfunction genScopedSlot (key, el) {\n  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = getNormalizationType(children);\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n        ? normalizationType ? (\",\" + normalizationType) : ''\n        : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n/**\n * Compile a template.\n */\nfunction compile$1 (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\n/*  */\n\n// operators like typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"- avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n      );\n    } else {\n      errors.push((\"- invalid expression: \" + text));\n    }\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nvar warn$3;\n\nfunction model$1 (\n  el,\n  dir,\n  _warn\n) {\n  warn$3 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$3(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n  }\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else {\n    genDefaultModel(el, value, modifiers);\n  }\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, 'click',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (el.tag === 'input' && el.attrsMap.value) {\n      warn$3(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n        'inline value attributes will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n    if (el.tag === 'textarea' && el.children.length) {\n      warn$3(\n        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n        'inline content inside <textarea> will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n  }\n\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n  var needCompositionGuard = !lazy && type !== 'range';\n  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n  var valueExpression = isNative\n    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n  valueExpression = number || type === 'number'\n    ? (\"_n(\" + valueExpression + \")\")\n    : valueExpression;\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (isNative && needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  // inputs with type=\"file\" are read only and setting the input's\n  // value will throw an error.\n  if (process.env.NODE_ENV !== 'production' &&\n      type === 'file') {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n      \"File inputs are read only. Use a v-on:change listener instead.\"\n    );\n  }\n\n  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    el.children.some(checkOptionWarning);\n  }\n\n  var number = modifiers && modifiers.number;\n  var assignment = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n    (el.attrsMap.multiple == null ? '[0]' : '');\n\n  var code = genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction checkOptionWarning (option) {\n  if (option.type === 1 &&\n    option.tag === 'option' &&\n    option.attrsMap.selected != null) {\n    warn$3(\n      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n      'inline selected attributes on <option> will be ignored when using v-model. ' +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n    return true\n  }\n  return false\n}\n\nfunction genAssignmentCode (value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model$1,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar cache = Object.create(null);\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  staticKeys: genStaticKeys(modules$1),\n  directives: directives$1,\n  isReservedTag: isReservedTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  getTagNamespace: getTagNamespace,\n  isPreTag: isPreTag\n};\n\nfunction compile$$1 (\n  template,\n  options\n) {\n  options = options\n    ? extend(extend({}, baseOptions), options)\n    : baseOptions;\n  return compile$1(template, options)\n}\n\nfunction compileToFunctions (\n  template,\n  options,\n  vm\n) {\n  var _warn = (options && options.warn) || warn;\n  // detect possible CSP restriction\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      new Function('return 1');\n    } catch (e) {\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        _warn(\n          'It seems you are using the standalone build of Vue.js in an ' +\n          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n          'The template compiler cannot work in this environment. Consider ' +\n          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n          'templates into render functions.'\n        );\n      }\n    }\n  }\n  var key = options && options.delimiters\n    ? String(options.delimiters) + template\n    : template;\n  if (cache[key]) {\n    return cache[key]\n  }\n  var res = {};\n  var compiled = compile$$1(template, options);\n  res.render = makeFunction(compiled.render);\n  var l = compiled.staticRenderFns.length;\n  res.staticRenderFns = new Array(l);\n  for (var i = 0; i < l; i++) {\n    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n      _warn(\n        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n        detectErrors(compiled.ast).join('\\n') +\n        '\\n\\n',\n        vm\n      );\n    }\n  }\n  return (cache[key] = res)\n}\n\nfunction makeFunction (code) {\n  try {\n    return new Function(code)\n  } catch (e) {\n    return noop\n  }\n}\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      var ref = compileToFunctions(template, {\n        warn: warn,\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.common.js\n// module id = 62\n// module chunks = 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_classof.js\n// module id = 63\n// module chunks = 1","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_enum-bug-keys.js\n// module id = 64\n// module chunks = 1","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_fails.js\n// module id = 65\n// module chunks = 1","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_html.js\n// module id = 66\n// module chunks = 1","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_is-array-iter.js\n// module id = 67\n// module chunks = 1","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iter-call.js\n// module id = 68\n// module chunks = 1","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iter-define.js\n// module id = 69\n// module chunks = 1","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iter-detect.js\n// module id = 70\n// module chunks = 1","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_library.js\n// module id = 71\n// module chunks = 1","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_shared.js\n// module id = 72\n// module chunks = 1","var ctx                = require('./_ctx')\n  , invoke             = require('./_invoke')\n  , html               = require('./_html')\n  , cel                = require('./_dom-create')\n  , global             = require('./_global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./_cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_task.js\n// module id = 73\n// module chunks = 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-object.js\n// module id = 74\n// module chunks = 1","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_uid.js\n// module id = 75\n// module chunks = 1","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/core.get-iterator-method.js\n// module id = 76\n// module chunks = 1","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/es6.string.iterator.js\n// module id = 77\n// module chunks = 1","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/grid.js\n// module id = 80\n// module chunks = 1","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         * @return {module:echarts/model/Component}\n         */\n        getCoordSysModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.option.gridIndex,\n                id: this.option.gridId\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 81\n// module chunks = 1","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    //  GridModel, AxisModel \n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var textStyleModel = axisModel.getModel('axisLabel.textStyle');\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = textStyleModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtentFromData(data, dim);\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.getCoordSysModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 82\n// module chunks = 1","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} [defaultNames]    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} [extraPrefix]             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 83\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', this.getInitialData(option, ecModel));\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `position` and `show`\n            // FIXME Set label in mergeOption\n            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `position` and `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return [coordDim];\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return dataDim;\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var result = [];\n\n                zrUtil.each(value, function (val, idx) {\n                    var dimInfo = data.getDimensionInfo(idx);\n                    var dimType = dimInfo && dimInfo.type;\n                    var valStr;\n\n                    if (dimType === 'ordinal') {\n                        valStr = val + '';\n                    }\n                    else if (dimType === 'time') {\n                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);\n                    }\n                    else {\n                        valStr = addCommas(val);\n                    }\n\n                    valStr && result.push(valStr);\n                });\n\n                return result.join(', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = encodeHTML(\n                zrUtil.isArray(value) ? formatArrayValue(value) : addCommas(value)\n            );\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:' + encodeHTML(color) + '\"></span>';\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            return !multipleSeries\n                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl\n                    + (name\n                        ? encodeHTML(name) + ' : ' + formattedValue\n                        : formattedValue\n                    )\n                  )\n                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Array.<number>} data indices.\n         */\n        getAxisTooltipDataIndex: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Series.js\n// module id = 84\n// module chunks = 1","\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            if (colorNameMap[name]) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/colorPalette.js\n// module id = 85\n// module chunks = 1","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Chart.js\n// module id = 86\n// module chunks = 1","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/Element.js\n// module id = 87\n// module chunks = 1","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} easing\n         *         {@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/animation/Animator.js\n// module id = 88\n// module chunks = 1","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/animation/requestAnimationFrame.js\n// module id = 89\n// module chunks = 1","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/util.js\n// module id = 90\n// module chunks = 1","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/guid.js\n// module id = 91\n// module chunks = 1","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/log.js\n// module id = 92\n// module chunks = 1","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // \n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // \n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // \n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Image.js\n// module id = 93\n// module chunks = 1","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Pattern.js\n// module id = 94\n// module chunks = 1","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Style.js\n// module id = 95\n// module chunks = 1","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/helper/poly.js\n// module id = 96\n// module chunks = 1","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/fn/array/from.js\n// module id = 98\n// module chunks = 1","var core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/fn/json/stringify.js\n// module id = 99\n// module chunks = 1","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nmodule.exports = require('../modules/_core').Promise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/fn/promise.js\n// module id = 100\n// module chunks = 1","module.exports = function(){ /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_add-to-unscopables.js\n// module id = 101\n// module chunks = 1","module.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_an-instance.js\n// module id = 102\n// module chunks = 1","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_array-includes.js\n// module id = 103\n// module chunks = 1","'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_create-property.js\n// module id = 104\n// module chunks = 1","var ctx         = require('./_ctx')\n  , call        = require('./_iter-call')\n  , isArrayIter = require('./_is-array-iter')\n  , anObject    = require('./_an-object')\n  , toLength    = require('./_to-length')\n  , getIterFn   = require('./core.get-iterator-method')\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_for-of.js\n// module id = 105\n// module chunks = 1","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_ie8-dom-define.js\n// module id = 106\n// module chunks = 1","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_invoke.js\n// module id = 107\n// module chunks = 1","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iobject.js\n// module id = 108\n// module chunks = 1","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iter-create.js\n// module id = 109\n// module chunks = 1","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_iter-step.js\n// module id = 110\n// module chunks = 1","var global    = require('./_global')\n  , macrotask = require('./_task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./_cof')(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_microtask.js\n// module id = 111\n// module chunks = 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-create.js\n// module id = 112\n// module chunks = 1","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-dps.js\n// module id = 113\n// module chunks = 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-gpo.js\n// module id = 114\n// module chunks = 1","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-keys-internal.js\n// module id = 115\n// module chunks = 1","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_object-keys.js\n// module id = 116\n// module chunks = 1","var hide = require('./_hide');\nmodule.exports = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_redefine-all.js\n// module id = 117\n// module chunks = 1","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_redefine.js\n// module id = 118\n// module chunks = 1","'use strict';\nvar global      = require('./_global')\n  , core        = require('./_core')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_set-species.js\n// module id = 119\n// module chunks = 1","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./_an-object')\n  , aFunction = require('./_a-function')\n  , SPECIES   = require('./_wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_species-constructor.js\n// module id = 120\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_string-at.js\n// module id = 121\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-index.js\n// module id = 122\n// module chunks = 1","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/_to-primitive.js\n// module id = 123\n// module chunks = 1","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/es6.array.from.js\n// module id = 124\n// module chunks = 1","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/es6.array.iterator.js\n// module id = 125\n// module chunks = 1","'use strict';\nvar LIBRARY            = require('./_library')\n  , global             = require('./_global')\n  , ctx                = require('./_ctx')\n  , classof            = require('./_classof')\n  , $export            = require('./_export')\n  , isObject           = require('./_is-object')\n  , aFunction          = require('./_a-function')\n  , anInstance         = require('./_an-instance')\n  , forOf              = require('./_for-of')\n  , speciesConstructor = require('./_species-constructor')\n  , task               = require('./_task').set\n  , microtask          = require('./_microtask')()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/es6.promise.js\n// module id = 127\n// module chunks = 1","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.2.4.1@core-js/library/modules/web.dom.iterable.js\n// module id = 128\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/.6.20.0@babel-runtime/core-js/promise.js\n// module id = 129\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\n    ];\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/ExtensionAPI.js\n// module id = 141\n// module chunks = 1","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/action/createDataSelectAction.js\n// module id = 142\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('../coord/cartesian/Grid');\n\n    require('./bar/BarSeries');\n    require('./bar/BarView');\n\n    var barLayoutGrid = require('../layout/barGrid');\n    var echarts = require('../echarts');\n\n    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));\n    // Visual coding for legend\n    echarts.registerVisual(function (ecModel) {\n        ecModel.eachSeriesByType('bar', function (seriesModel) {\n            var data = seriesModel.getData();\n            data.setVisual('legendSymbol', 'roundRect');\n        });\n    });\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 143\n// module chunks = 1","\n\n    module.exports = require('./BaseBarSeries').extend({\n\n        type: 'series.bar',\n\n        dependencies: ['grid', 'polar'],\n\n        brushSelector: 'rect'\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 144\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var helper = require('./helper');\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth'];\n\n    // FIXME\n    // Just for compatible with ec2.\n    zrUtil.extend(require('../../model/Model').prototype, require('./barItemStyle'));\n\n    var BarView = require('../../echarts').extendChartView({\n\n        type: 'bar',\n\n        render: function (seriesModel, ecModel, api) {\n            var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n            if (coordinateSystemType === 'cartesian2d') {\n                this._renderOnCartesian(seriesModel, ecModel, api);\n            }\n\n            return this.group;\n        },\n\n        dispose: zrUtil.noop,\n\n        _renderOnCartesian: function (seriesModel, ecModel, api) {\n            var group = this.group;\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n            var isHorizontal = baseAxis.isHorizontal();\n            var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n\n            data.diff(oldData)\n                .add(function (dataIndex) {\n                    if (!data.hasValue(dataIndex)) {\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(dataIndex);\n                    var layout = getRectItemLayout(data, dataIndex, itemModel);\n                    var el = createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel);\n                    data.setItemGraphicEl(dataIndex, el);\n                    group.add(el);\n\n                    updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .update(function (newIndex, oldIndex) {\n                    var el = oldData.getItemGraphicEl(oldIndex);\n\n                    if (!data.hasValue(newIndex)) {\n                        group.remove(el);\n                        return;\n                    }\n\n                    var itemModel = data.getItemModel(newIndex);\n                    var layout = getRectItemLayout(data, newIndex, itemModel);\n\n                    if (el) {\n                        graphic.updateProps(el, {shape: layout}, animationModel, newIndex);\n                    }\n                    else {\n                        el = createRect(data, newIndex, itemModel, layout, isHorizontal, animationModel, true);\n                    }\n\n                    data.setItemGraphicEl(newIndex, el);\n                    // Add back\n                    group.add(el);\n\n                    updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontal);\n                })\n                .remove(function (dataIndex) {\n                    var el = oldData.getItemGraphicEl(dataIndex);\n                    el && removeRect(dataIndex, animationModel, el);\n                })\n                .execute();\n\n            this._data = data;\n        },\n\n        remove: function (ecModel, api) {\n            var group = this.group;\n            var data = this._data;\n            if (ecModel.get('animation')) {\n                if (data) {\n                    data.eachItemGraphicEl(function (el) {\n                        removeRect(el.dataIndex, ecModel, el);\n                    });\n                }\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    });\n\n    function createRect(data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n        var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)});\n\n        // Animation\n        if (animationModel) {\n            var rectShape = rect.shape;\n            var animateProperty = isHorizontal ? 'height' : 'width';\n            var animateTarget = {};\n            rectShape[animateProperty] = 0;\n            animateTarget[animateProperty] = layout[animateProperty];\n            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n                shape: animateTarget\n            }, animationModel, dataIndex);\n        }\n\n        return rect;\n    }\n\n    function removeRect(dataIndex, animationModel, el) {\n        // Not show text when animating\n        el.style.text = '';\n        graphic.updateProps(el, {\n            shape: {\n                width: 0\n            }\n        }, animationModel, dataIndex, function () {\n            el.parent && el.parent.remove(el);\n        });\n    }\n\n    function getRectItemLayout(data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = getLineWidth(itemModel, layout);\n\n        // fix layout with lineWidth\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n            x: layout.x + signX * fixedLineWidth / 2,\n            y: layout.y + signY * fixedLineWidth / 2,\n            width: layout.width - signX * fixedLineWidth,\n            height: layout.height - signY * fixedLineWidth\n        };\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal) {\n        var color = data.getItemVisual(dataIndex, 'color');\n        var opacity = data.getItemVisual(dataIndex, 'opacity');\n        var itemStyleModel = itemModel.getModel('itemStyle.normal');\n        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n        el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n\n        el.useStyle(zrUtil.defaults(\n            {\n                fill: color,\n                opacity: opacity\n            },\n            itemStyleModel.getBarItemStyle()\n        ));\n\n        var labelPositionOutside = isHorizontal\n            ? (layout.height > 0 ? 'bottom' : 'top')\n            : (layout.width > 0 ? 'left' : 'right');\n\n        helper.setLabel(\n            el.style, hoverStyle, itemModel, color,\n            seriesModel, dataIndex, labelPositionOutside\n        );\n\n        graphic.setHoverStyle(el, hoverStyle);\n    }\n\n    // In case width or height are too small.\n    function getLineWidth(itemModel, rawLayout) {\n        var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n        return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n    }\n\n    module.exports = BarView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 145\n// module chunks = 1","'use strict';\n\n\n    var SeriesModel = require('../../model/Series');\n    var createListFromArray = require('../helper/createListFromArray');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.__base_bar__',\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'cartesian2d') {\n                    throw new Error('Bar only support cartesian2d coordinateSystem');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        getMarkerPosition: function (value) {\n            var coordSys = this.coordinateSystem;\n            if (coordSys) {\n                // PENDING if clamp ?\n                var pt = coordSys.dataToPoint(value, true);\n                var data = this.getData();\n                var offset = data.getLayout('offset');\n                var size = data.getLayout('size');\n                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n                pt[offsetIndex] += offset + size / 2;\n                return pt;\n            }\n            return [NaN, NaN];\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // \n            z: 2,                       // \n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n            // stack: null\n\n            // Cartesian coordinate system\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // 0\n            barMinHeight: 0,\n\n            // barMaxWidth: null,\n            // \n            // barWidth: null,\n            // 30%\n            // barGap: '30%',\n            // 20%\n            // barCategoryGap: '20%',\n            // label: {\n            //     normal: {\n            //         show: false\n            //     }\n            // },\n            itemStyle: {\n                normal: {\n                    // color: ''\n                },\n                emphasis: {}\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 146\n// module chunks = 1","\n\n\n    var getBarItemStyle = require('../../model/mixin/makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            // Compatitable with 2\n            ['stroke', 'barBorderColor'],\n            ['lineWidth', 'barBorderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getBarItemStyle: function (excludes) {\n            var style = getBarItemStyle.call(this, excludes);\n            if (this.getBorderLineDash) {\n                var lineDash = this.getBorderLineDash();\n                lineDash && (style.lineDash = lineDash);\n            }\n            return style;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 147\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n\n    var helper = {};\n\n    helper.setLabel = function (\n        normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside\n    ) {\n        var labelModel = itemModel.getModel('label.normal');\n        var hoverLabelModel = itemModel.getModel('label.emphasis');\n\n        if (labelModel.get('show')) {\n            setLabel(\n                normalStyle, labelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'normal'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            normalStyle.text = '';\n        }\n\n        if (hoverLabelModel.get('show')) {\n            setLabel(\n                hoverStyle, hoverLabelModel, color,\n                zrUtil.retrieve(\n                    seriesModel.getFormattedLabel(dataIndex, 'emphasis'),\n                    seriesModel.getRawValue(dataIndex)\n                ),\n                labelPositionOutside\n            );\n        }\n        else {\n            hoverStyle.text = '';\n        }\n    };\n\n    function setLabel(style, model, color, labelText, labelPositionOutside) {\n        graphic.setText(style, model, color);\n        style.text = labelText;\n        if (style.textPosition === 'outside') {\n            style.textPosition = labelPositionOutside;\n        }\n    }\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 148\n// module chunks = 1","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            completeDimensions(dimensions, data);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 149\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie.js\n// module id = 150\n// module chunks = 1","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // textStyle: null      // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieSeries.js\n// module id = 151\n// module chunks = 1","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieView.js\n// module id = 152\n// module chunks = 1","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/labelLayout.js\n// module id = 153\n// module chunks = 1","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += dir * angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/pieLayout.js\n// module id = 154\n// module chunks = 1","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 155\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n\n            if (!axisModel.get('axisTick.show') || axis.isBlank()) {\n                return;\n            }\n\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var axis = axisModel.axis;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show || axis.isBlank()) {\n                return;\n            }\n\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            zrUtil.each(ticks, function (tickVal, index) {\n                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {\n                     return;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(tickVal);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(tickVal);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + tickVal,\n\n                    style: {\n                        text: labels[index],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n\n            }, this);\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n\n            // If min or max are user set, we need to check\n            // If the tick on min(max) are overlap on their neighbour tick\n            // If they are overlapped, we need to hide the min(max) tick label\n            if (axisModel.getMin() != null) {\n                var firstLabel = textEls[0];\n                var nextLabel = textEls[1];\n                if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                    firstLabel.ignore = true;\n                }\n            }\n            if (axisModel.getMax() != null) {\n                var lastLabel = textEls[textEls.length - 1];\n                var prevLabel = textEls[textEls.length - 2];\n                if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                    lastLabel.ignore = true;\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 156\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.getCoordSysModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            if (axis.isBlank()) {\n                return;\n            }\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisView.js\n// module id = 157\n// module chunks = 1","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionElement(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/listComponent.js\n// module id = 158\n// module chunks = 1","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/selectableMixin.js\n// module id = 159\n// module chunks = 1","/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend.js\n// module id = 160\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendModel.js\n// module id = 161\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendView.js\n// module id = 162\n// module chunks = 1","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendAction.js\n// module id = 163\n// module chunks = 1","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendFilter.js\n// module id = 164\n// module chunks = 1","'use strict';\n\n\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 6,\n            show: true,\n\n            text: '',\n            // \n            // link: null,\n            // self | blank\n            target: 'blank',\n            subtext: '',\n\n            // \n            // sublink: null,\n            // self | blank\n            subtarget: 'blank',\n\n            // 'center'  'left'  'right'\n            //  {number}xpx\n            left: 0,\n            // 'top'  'bottom'  'center'\n            //  {number}ypx\n            top: 0,\n\n            // \n            // 'auto' | 'left' | 'right' | 'center'\n            //  left \n            // textAlign: null\n            //\n            // \n            // 'auto' | 'top' | 'bottom' | 'middle'\n            //  top \n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // \n            borderColor: '#ccc',\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // px10\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/title.js\n// module id = 165\n// module chunks = 1","// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 166\n// module chunks = 1","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 167\n// module chunks = 1","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'item'  'axis'\n            trigger: 'item',\n\n            //  'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            //  content\n            alwaysShowContent: false,\n\n            //  {Array} | {Function}\n            // position: null\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // \n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // \n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 168\n// module chunks = 1","\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {boolean} confine Whether confine tooltip content in view rect.\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, confine, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        if (confine) {\n            var pos = confineTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            // From self\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = payload.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            var isTriggerAxis = this._tooltipModel.get('trigger') === 'axis';\n            function seriesHaveDataOnIndex(_series) {\n                var data = _series.getData();\n                var dataIndex = modelUtil.queryDataIndex(data, payload);\n                // Have single dataIndex\n                if (dataIndex != null && !zrUtil.isArray(dataIndex)\n                    && data.hasValue(dataIndex)\n                ) {\n                    return true;\n                }\n            }\n\n            if (payload.x == null || payload.y == null) {\n                if (isTriggerAxis) {\n                    // Find another series.\n                    if (seriesModel && !seriesHaveDataOnIndex(seriesModel)) {\n                        seriesModel = null;\n                    }\n                    if (!seriesModel) {\n                        // Find the first series can use axis trigger And data is not null\n                        ecModel.eachSeries(function (_series) {\n                            if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                                if (seriesHaveDataOnIndex(_series)) {\n                                    seriesModel = _series;\n                                }\n                            }\n                        });\n                    }\n                }\n                else {\n                    // Use the first series by default.\n                    seriesModel = seriesModel || ecModel.getSeriesByIndex(0);\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: payload.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(payload.x, payload.y);\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var data = dataModel.getData();\n                var itemModel = data.getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: dataIndex,\n                    dataIndex: data.getRawIndex(dataIndex), // expose to user.\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                if (baseAxis.isBlank() || zrUtil.eqNaN(point[0]) || zrUtil.eqNaN(point[1])) {\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                var enableAnimation = tooltipModel.get('animation');\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point, enableAnimation\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point, enableAnimation) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation =\n                enableAnimation\n                && axisPointerType !== 'cross'\n                && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point, enableAnimation) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = enableAnimation\n                && axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = ({x: 1, radius: 1, single: 1})[baseAxis.dim] ? 0 : 1;\n\n            if (!seriesList.length) {\n                return;\n            }\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n            var sampleSeriesIndex;\n            zrUtil.each(payloadBatch, function (payload, idx) {\n                if (seriesList[idx].getData().hasValue(payload.dataIndexInside)) {\n                    sampleSeriesIndex = idx;\n                }\n            });\n            // Fallback to 0.\n            sampleSeriesIndex = sampleSeriesIndex || 0;\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            var dataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                // expose to user.\n                dataIndex: seriesList[sampleSeriesIndex].getData().getRawIndex(dataIndex),\n                seriesIndex: payloadBatch[sampleSeriesIndex].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[sampleSeriesIndex].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[sampleSeriesIndex].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'),\n                        point[0], point[1],\n                        rootTooltipModel.get('confine'),\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n                var confine = tooltipModel.get('confine');\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params, true);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y, confine,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y, confine,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 169\n// module chunks = 1","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        isBlank: function () {\n            return this._isBlank;\n        },\n\n        /**\n         * When axis extent depends on data and no data exists,\n         * axis ticks should not be drawn, which is named 'blank'.\n         */\n        setBlank: function (isBlank) {\n            this._isBlank = isBlank;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 170\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // \n        z: 0,                       // \n        // \n        inverse: false,\n\n        // \n        name: '',\n        // 'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // degree\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // \n        nameTextStyle: {},\n        // \n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // \n        axisLine: {\n            // show\n            show: true,\n            onZero: true,\n            // lineStyle\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        axisTick: {\n            // show\n            show: true,\n            // grid\n            inside: false,\n            // length\n            length: 5,\n            // lineStyle\n            lineStyle: {\n                width: 1\n            }\n        },\n        // axis.axisLabel\n        axisLabel: {\n            show: true,\n            // grid\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // \n        splitLine: {\n            // show\n            show: true,\n            // lineStylelineStyle\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // \n        splitArea: {\n            // show\n            show: false,\n            // areaStyleareaStyle\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // \n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // \n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // \n        boundaryGap: [0, 0],\n        // ,  'dataMin' \n        // min: null,\n        //  'dataMax' \n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 0_min_max\n        // scale: false,\n        // 5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 171\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (min != null && min !== 'dataMin' && !zrUtil.eqNaN(min)) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (max != null && max !== 'dataMax' && !zrUtil.eqNaN(max)) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 172\n// module chunks = 1","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 173\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 174\n// module chunks = 1","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 175\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 176\n// module chunks = 1","'use strict';\n// Grid \n//  Cartesian2D \n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 177\n// module chunks = 1","'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/axisLabelInterval.js\n// module id = 178\n// module chunks = 1","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n            var oldKeyGetter = this._oldKeyGetter;\n            var newKeyGetter = this._newKeyGetter;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetter) {\n        for (var i = 0; i < arr.length; i++) {\n            var key = keyGetter(arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/DataDiffer.js\n// module id = 179\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function getSeriesStackId(seriesModel) {\n        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n        return axis.dim + axis.index;\n    }\n\n    function calBarWidthAndOffset(barSeries, api) {\n        // Columns info on each category axis. Key is cartesian name\n        var columnsMap = {};\n\n        zrUtil.each(barSeries, function (seriesModel, idx) {\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n\n            var baseAxis = cartesian.getBaseAxis();\n            var axisExtent = baseAxis.getExtent();\n            var bandWidth = baseAxis.type === 'category'\n                ? baseAxis.getBandWidth()\n                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());\n\n            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {\n                bandWidth: bandWidth,\n                remainedWidth: bandWidth,\n                autoWidthCount: 0,\n                categoryGap: '20%',\n                gap: '30%',\n                stacks: {}\n            };\n            var stacks = columnsOnAxis.stacks;\n            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;\n\n            var stackId = getSeriesStackId(seriesModel);\n\n            if (!stacks[stackId]) {\n                columnsOnAxis.autoWidthCount++;\n            }\n            stacks[stackId] = stacks[stackId] || {\n                width: 0,\n                maxWidth: 0\n            };\n\n            var barWidth = parsePercent(\n                seriesModel.get('barWidth'), bandWidth\n            );\n            var barMaxWidth = parsePercent(\n                seriesModel.get('barMaxWidth'), bandWidth\n            );\n            var barGap = seriesModel.get('barGap');\n            var barCategoryGap = seriesModel.get('barCategoryGap');\n\n            // Caution: In a single coordinate system, these barGrid attributes\n            // will be shared by series. Consider that they have default values,\n            // only the attributes set on the last series will work.\n            // Do not change this fact unless there will be a break change.\n\n            // TODO\n            if (barWidth && !stacks[stackId].width) {\n                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n                stacks[stackId].width = barWidth;\n                columnsOnAxis.remainedWidth -= barWidth;\n            }\n\n            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n            (barGap != null) && (columnsOnAxis.gap = barGap);\n            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);\n        });\n\n        var result = {};\n\n        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n\n            result[coordSysName] = {};\n\n            var stacks = columnsOnAxis.stacks;\n            var bandWidth = columnsOnAxis.bandWidth;\n            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n\n            var remainedWidth = columnsOnAxis.remainedWidth;\n            var autoWidthCount = columnsOnAxis.autoWidthCount;\n            var autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            // Find if any auto calculated bar exceeded maxBarWidth\n            zrUtil.each(stacks, function (column, stack) {\n                var maxWidth = column.maxWidth;\n                if (!column.width && maxWidth && maxWidth < autoWidth) {\n                    maxWidth = Math.min(maxWidth, remainedWidth);\n                    remainedWidth -= maxWidth;\n                    column.width = maxWidth;\n                    autoWidthCount--;\n                }\n            });\n\n            // Recalculate width again\n            autoWidth = (remainedWidth - categoryGap)\n                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n            autoWidth = Math.max(autoWidth, 0);\n\n            var widthSum = 0;\n            var lastColumn;\n            zrUtil.each(stacks, function (column, idx) {\n                if (!column.width) {\n                    column.width = autoWidth;\n                }\n                lastColumn = column;\n                widthSum += column.width * (1 + barGapPercent);\n            });\n            if (lastColumn) {\n                widthSum -= lastColumn.width * barGapPercent;\n            }\n\n            var offset = -widthSum / 2;\n            zrUtil.each(stacks, function (column, stackId) {\n                result[coordSysName][stackId] = result[coordSysName][stackId] || {\n                    offset: offset,\n                    width: column.width\n                };\n\n                offset += column.width * (1 + barGapPercent);\n            });\n        });\n\n        return result;\n    }\n\n    /**\n     * @param {string} seriesType\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function barLayoutGrid(seriesType, ecModel, api) {\n\n        var barWidthAndOffset = calBarWidthAndOffset(\n            zrUtil.filter(\n                ecModel.getSeriesByType(seriesType),\n                function (seriesModel) {\n                    return !ecModel.isSeriesFiltered(seriesModel)\n                        && seriesModel.coordinateSystem\n                        && seriesModel.coordinateSystem.type === 'cartesian2d';\n                }\n            )\n        );\n\n        var lastStackCoords = {};\n        var lastStackCoordsOrigin = {};\n\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\n            var data = seriesModel.getData();\n            var cartesian = seriesModel.coordinateSystem;\n            var baseAxis = cartesian.getBaseAxis();\n\n            var stackId = getSeriesStackId(seriesModel);\n            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n            var columnOffset = columnLayoutInfo.offset;\n            var columnWidth = columnLayoutInfo.width;\n            var valueAxis = cartesian.getOtherAxis(baseAxis);\n\n            var barMinHeight = seriesModel.get('barMinHeight') || 0;\n\n            var valueAxisStart = baseAxis.onZero\n                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))\n                : valueAxis.getGlobalExtent()[0];\n\n            var coords = cartesian.dataToPoints(data, true);\n            lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n            data.setLayout({\n                offset: columnOffset,\n                size: columnWidth\n            });\n\n            data.each(valueAxis.dim, function (value, idx) {\n                if (isNaN(value)) {\n                    return;\n                }\n\n                if (!lastStackCoords[stackId][idx]) {\n                    lastStackCoords[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                    lastStackCoordsOrigin[stackId][idx] = {\n                        p: valueAxisStart, // Positive stack\n                        n: valueAxisStart  // Negative stack\n                    };\n                }\n                var sign = value >= 0 ? 'p' : 'n';\n                var coord = coords[idx];\n                var lastCoord = lastStackCoords[stackId][idx][sign];\n                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n                var x;\n                var y;\n                var width;\n                var height;\n\n                if (valueAxis.isHorizontal()) {\n                    x = lastCoord;\n                    y = coord[1] + columnOffset;\n                    width = coord[0] - lastCoordOrigin;\n                    height = columnWidth;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += width;\n                    if (Math.abs(width) < barMinHeight) {\n                        width = (width < 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += width;\n                }\n                else {\n                    x = coord[0] + columnOffset;\n                    y = lastCoord;\n                    width = columnWidth;\n                    height = coord[1] - lastCoordOrigin;\n\n                    lastStackCoordsOrigin[stackId][idx][sign] += height;\n                    if (Math.abs(height) < barMinHeight) {\n                        // Include zero to has a positive bar\n                        height = (height <= 0 ? -1 : 1) * barMinHeight;\n                    }\n                    lastStackCoords[stackId][idx][sign] += height;\n                }\n\n                data.setItemLayout(idx, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                });\n            }, true);\n\n        }, this);\n    }\n\n    module.exports = barLayoutGrid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 180\n// module chunks = 1","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/loading/default.js\n// module id = 181\n// module chunks = 1","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption();\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap[mainType], newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap[mainType] = [];\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap[mainType][index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.series);\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap[mainType];\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap[mainType];\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts;\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap[mainType];\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                each(componentsMap, function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap[mainType], cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.series[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.series;\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.series.slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.series, cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.series[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.series, cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.series);\n\n            var componentTypes = [];\n            each(componentsMap, function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap[componentType], function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap[type] || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Series has not been initialized yet.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/Global.js\n// module id = 182\n// module chunks = 1","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/OptionManager.js\n// module id = 183\n// module chunks = 1","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: true,\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/globalDefault.js\n// module id = 184\n// module chunks = 1","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/areaStyle.js\n// module id = 185\n// module chunks = 1","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/boxLayout.js\n// module id = 186\n// module chunks = 1","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes) {\n            var style = getItemStyle.call(this, excludes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/itemStyle.js\n// module id = 187\n// module chunks = 1","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/lineStyle.js\n// module id = 188\n// module chunks = 1","\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function getShallow(model, path) {\n        return model && model.getShallow(path);\n    }\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @return {string}\n         */\n        getTextColor: function () {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (ecModel && ecModel.get('textStyle.color'));\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            var ecModel = this.ecModel;\n            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n            return [\n                // FIXME in node-canvas fontWeight is before fontStyle\n                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),\n                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),\n                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',\n                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'\n            ].join(' ');\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('baseline')\n            );\n        },\n\n        truncateText: function (text, containerWidth, ellipsis, options) {\n            return textContain.truncateText(\n                text, containerWidth, this.getFont(), ellipsis, options\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/model/mixin/textStyle.js\n// module id = 189\n// module chunks = 1","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option) {\n        each(option.series, function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            compatStyle(seriesOpt);\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/backwardCompat.js\n// module id = 190\n// module chunks = 1","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (itemStyleOpt) {\n            zrUtil.each(POSSIBLE_STYLES, function (styleName) {\n                var normalItemStyleOpt = itemStyleOpt.normal;\n                var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].normal) {\n                        opt[styleName].normal = normalItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                    }\n                    normalItemStyleOpt[styleName] = null;\n                }\n                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                    opt[styleName] = opt[styleName] || {};\n                    if (!opt[styleName].emphasis) {\n                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                    }\n                    else {\n                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                    }\n                    emphasisItemStyleOpt[styleName] = null;\n                }\n            });\n        }\n    }\n\n    module.exports = function (seriesOpt) {\n        if (!seriesOpt) {\n            return;\n        }\n        compatItemStyle(seriesOpt);\n        compatItemStyle(seriesOpt.markPoint);\n        compatItemStyle(seriesOpt.markLine);\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n            }\n            // mark point data\n            var markPoint = seriesOpt.markPoint;\n            if (markPoint && markPoint.data) {\n                var mpData = markPoint.data;\n                for (var i = 0; i < mpData.length; i++) {\n                    compatItemStyle(mpData[i]);\n                }\n            }\n            // mark line data\n            var markLine = seriesOpt.markLine;\n            if (markLine && markLine.data) {\n                var mlData = markLine.data;\n                for (var i = 0; i < mlData.length; i++) {\n                    if (zrUtil.isArray(mlData[i])) {\n                        compatItemStyle(mlData[i][0]);\n                        compatItemStyle(mlData[i][1]);\n                    }\n                    else {\n                        compatItemStyle(mlData[i]);\n                    }\n                }\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 191\n// module chunks = 1","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataFilter.js\n// module id = 192\n// module chunks = 1","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 193\n// module chunks = 1","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 194\n// module chunks = 1","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 195\n// module chunks = 1","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 196\n// module chunks = 1","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            diff = currCall - (debounce ? lastCall : lastExec) - delay;\n\n            clearTimeout(timer);\n\n            if (debounce) {\n                timer = setTimeout(exec, delay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/throttle.js\n// module id = 197\n// module chunks = 1","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/view/Component.js\n// module id = 198\n// module chunks = 1","// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/dataColor.js\n// module id = 199\n// module chunks = 1","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/seriesColor.js\n// module id = 200\n// module chunks = 1","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetEl \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/Handler.js\n// module id = 201\n// module chunks = 1","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/Layer.js\n// module id = 202\n// module chunks = 1","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/Painter.js\n// module id = 203\n// module chunks = 1","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // idmap\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [elId] Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // elId\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/Storage.js\n// module id = 204\n// module chunks = 1","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/animation/Animation.js\n// module id = 205\n// module chunks = 1","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/animation/Clip.js\n// module id = 206\n// module chunks = 1","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/animation/easing.js\n// module id = 207\n// module chunks = 1","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/arc.js\n// module id = 208\n// module chunks = 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/cubic.js\n// module id = 209\n// module chunks = 1","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/line.js\n// module id = 210\n// module chunks = 1","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/path.js\n// module id = 211\n// module chunks = 1","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/quadratic.js\n// module id = 212\n// module chunks = 1","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/contain/windingLine.js\n// module id = 213\n// module chunks = 1","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/GestureMgr.js\n// module id = 214\n// module chunks = 1","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/LRU.js\n// module id = 215\n// module chunks = 1","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/core/bbox.js\n// module id = 216\n// module chunks = 1","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/dom/HandlerProxy.js\n// module id = 217\n// module chunks = 1","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/CompoundPath.js\n// module id = 218\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/LinearGradient.js\n// module id = 219\n// module chunks = 1","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/RadialGradient.js\n// module id = 220\n// module chunks = 1","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/Text.js\n// module id = 221\n// module chunks = 1","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/helper/roundRect.js\n// module id = 222\n// module chunks = 1","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 223\n// module chunks = 1","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 224\n// module chunks = 1","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var textOffset = style.textOffset;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            if (textOffset) {\n                x += textOffset[0];\n                y += textOffset[1];\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/mixin/RectText.js\n// module id = 225\n// module chunks = 1","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Arc.js\n// module id = 226\n// module chunks = 1","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 227\n// module chunks = 1","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Circle.js\n// module id = 228\n// module chunks = 1","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Line.js\n// module id = 229\n// module chunks = 1","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Polygon.js\n// module id = 230\n// module chunks = 1","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Polyline.js\n// module id = 231\n// module chunks = 1","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Rect.js\n// module id = 232\n// module chunks = 1","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Ring.js\n// module id = 233\n// module chunks = 1","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var env = require('../../core/env');\n    var Path = require('../Path');\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: (env.browser.ie && env.browser.version >= 11) // version: '11.0'\n            // Fix weird bug in some version of IE11 (like 11.0.9600.17801),\n            // where exception \"unexpected call to method or property access\"\n            // might be thrown when calling ctx.fill after a path whose area size\n            // is zero is drawn and ctx.clip() is called and shadowBlur is set.\n            // (e.g.,\n            //  ctx.moveTo(10, 10);\n            //  ctx.lineTo(20, 10);\n            //  ctx.closePath();\n            //  ctx.clip();\n            //  ctx.shadowBlur = 10;\n            //  ...\n            //  ctx.fill();\n            // )\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var shape = clipPaths[i] && clipPaths[i].shape;\n                        if (shape && shape.startAngle === shape.endAngle) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                Path.prototype.brush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n            : Path.prototype.brush,\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/graphic/shape/Sector.js\n// module id = 234\n// module chunks = 1","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path a.b.c\n         * @param {boolean} [loop] \n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/mixin/Animatable.js\n// module id = 235\n// module chunks = 1","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/mixin/Draggable.js\n// module id = 236\n// module chunks = 1","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * transformcontext\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/mixin/Transformable.js\n// module id = 237\n// module chunks = 1","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/tool/path.js\n// module id = 238\n// module chunks = 1","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/tool/transformPath.js\n// module id = 239\n// module chunks = 1","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.3.0';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromMap, \n        // FIXME ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/~/zrender/lib/zrender.js\n// module id = 240\n// module chunks = 1","/**\n  * vue-router v2.2.0\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n'use strict';\n\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (h, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // inject instance registration hooks\n    var hooks = data.hook || (data.hook = {});\n    hooks.init = function (vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.prepatch = function (oldVnode, vnode) {\n      matched.instances[name] = vnode.child;\n    };\n    hooks.destroy = function (vnode) {\n      if (matched.instances[name] === vnode.child) {\n        matched.instances[name] = undefined;\n      }\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      warn(false, (\"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", expecting an object, function or boolean.\"));\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more comformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  if (query) {\n    var parsedQuery;\n    try {\n      parsedQuery = parseQuery(query);\n    } catch (e) {\n      process.env.NODE_ENV !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n    return parsedQuery\n  } else {\n    return extraQuery\n  }\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.slice().forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom\n) {\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom);\n  }\n  return Object.freeze(route)\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (ref) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  return (path || '/') + stringifyQuery(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n    var classes = {};\n    var activeClass = this.activeClass || router.options.linkActiveClass || 'router-link-active';\n    var compareTarget = location.path ? createRoute(null, location) : route;\n    classes[activeClass] = this.exact\n      ? isSameRoute(current, compareTarget)\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.target && e.target.getAttribute) {\n    var target = e.target.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this.$root._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this.$root._route }\n  });\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (this.$options.router) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  if (relative.charAt(0) === '/') {\n    return relative\n  }\n\n  if (relative.charAt(0) === '?' || relative.charAt(0) === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '.') {\n      continue\n    } else if (segment === '..') {\n      stack.pop();\n    } else {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathMap,\n  oldNameMap\n) {\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathMap, nameMap, route);\n  });\n\n  return {\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var record = {\n    path: normalizePath(path, parent),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    if (Array.isArray(route.alias)) {\n      route.alias.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n      });\n    } else {\n      var aliasRoute = {\n        path: route.alias,\n        children: route.children\n      };\n      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);\n    }\n  }\n\n  if (!pathMap[record.path]) {\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction normalizePath (path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCache = Object.create(null);\n\nfunction getRouteRegex (path) {\n  var hit = regexpCache[path];\n  var keys, regexp;\n\n  if (hit) {\n    keys = hit.keys;\n    regexp = hit.regexp;\n  } else {\n    keys = [];\n    regexp = index(path, keys);\n    regexpCache[path] = { keys: keys, regexp: regexp };\n  }\n\n  return { keys: keys, regexp: regexp }\n}\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : (current && current.path) || '/';\n  var query = resolveQuery(parsedPath.query, next.query);\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nfunction createMatcher (routes) {\n  var ref = createRouteMap(routes);\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      var paramNames = getRouteRegex(record.path).keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var path in pathMap) {\n        if (matchRoute(path, location.params, location.path)) {\n          return _createRoute(pathMap[path], location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      process.env.NODE_ENV !== 'production' && warn(\n        false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n      );\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  path,\n  params,\n  pathname\n) {\n  var ref = getRouteRegex(path);\n  var regexp = ref.regexp;\n  var keys = ref.keys;\n  var m = pathname.match(regexp);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) { params[key.name] = val; }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  window.addEventListener('popstate', function (e) {\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n\n  window.addEventListener('scroll', saveScrollPosition);\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return\n    }\n    var isObject = typeof shouldScroll === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        position = getElementPosition(el);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el) {\n  var docRect = document.documentElement.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left,\n    y: elRect.top - docRect.top\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n    saveScrollPosition();\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n  }\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, onAbort);\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function () { onAbort && onAbort(); };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    hook(route, current, function (to) {\n      if (to === false) {\n        // next(false) -> abort navigation, ensure current URL\n        this$1.ensureURL(true);\n        abort();\n      } else if (typeof to === 'string' || typeof to === 'object') {\n        // next('/') or next({ path: '/' }) -> redirect\n        (typeof to === 'object' && to.replace) ? this$1.replace(to) : this$1.push(to);\n        abort();\n      } else {\n        // confirm transition and pass on the value\n        next(to);\n      }\n    });\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    runQueue(enterGuards, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { return cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl ? baseEl.getAttribute('href') : '/';\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  return function boundRouteGuard () {\n    return guard.apply(instance, arguments)\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\nfunction resolveAsyncComponents (matched) {\n  return flatMapComponents(matched, function (def, _, match, key) {\n    // if it's a function and doesn't have Vue options attached,\n    // assume it's an async component resolve function.\n    // we are not using Vue's default async resolving mechanism because\n    // we want to halt the navigation until the incoming component has been\n    // resolved.\n    if (typeof def === 'function' && !def.options) {\n      return function (to, from, next) {\n        var resolve = once(function (resolvedDef) {\n          match.components[key] = resolvedDef;\n          next();\n        });\n\n        var reject = once(function (reason) {\n          warn(false, (\"Failed to resolve async component \" + key + \": \" + reason));\n          next(false);\n        });\n\n        var res = def(resolve, reject);\n        if (res && typeof res.then === 'function') {\n          res.then(resolve, reject);\n        }\n      }\n    }\n  })\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (called) { return }\n    called = true;\n    return fn.apply(this, arguments)\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, this$1.current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, this$1.current, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash (path) {\n  var i = window.location.href.indexOf('#');\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  );\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || []);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  this.beforeHooks.push(fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  this.afterHooks.push(fn);\n};\n\nVueRouter.prototype.onReady = function onReady (cb) {\n  this.history.onReady(cb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(to, current || this.history.current, append);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.2.0';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\nmodule.exports = VueRouter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-router/dist/vue-router.common.js\n// module id = 270\n// module chunks = 1","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 271\n// module chunks = 1","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/addStyles.js\n// module id = 272\n// module chunks = 1"],"sourceRoot":""}